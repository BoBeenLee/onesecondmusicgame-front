// tslint:disable
/**
 * 알쏭달쏭 API
 * 알쏠달쏭 API 명세
 *
 * The version of the OpenAPI document: v1.0.27
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 스코어 정보
 * @export
 * @interface AbstractScore
 */
export interface AbstractScore {
    /**
     * 
     * @type {number}
     * @memberof AbstractScore
     */
    point?: number;
    /**
     * 
     * @type {number}
     * @memberof AbstractScore
     */
    id?: number;
}
/**
 * 사용자가 1개의 문제를 풀었을 때 1개의 GameAnswer 객체를 제출해야 한다.
 * @export
 * @interface GameAnswer
 */
export interface GameAnswer {
    /**
     * (기억이 잘 안나지만) 문제에 해당하는 highlightId
     * @type {number}
     * @memberof GameAnswer
     */
    id?: number;
    /**
     * 사용자가 입력한 정답.
     * @type {string}
     * @memberof GameAnswer
     */
    answer?: string;
}
/**
 * 
 * @export
 * @interface GameAnswerCheckRequest
 */
export interface GameAnswerCheckRequest {
    /**
     * 
     * @type {number}
     * @memberof GameAnswerCheckRequest
     */
    trackId?: number;
    /**
     * 
     * @type {string}
     * @memberof GameAnswerCheckRequest
     */
    answer?: string;
    /**
     * 
     * @type {string}
     * @memberof GameAnswerCheckRequest
     */
    playToken?: string;
}
/**
 * 
 * @export
 * @interface GamePlayHighlightDTO
 */
export interface GamePlayHighlightDTO {
    /**
     * 
     * @type {number}
     * @memberof GamePlayHighlightDTO
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof GamePlayHighlightDTO
     */
    millisecond?: number;
    /**
     * 
     * @type {number}
     * @memberof GamePlayHighlightDTO
     */
    trackId?: number;
    /**
     * 
     * @type {string}
     * @memberof GamePlayHighlightDTO
     */
    progressiveUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof GamePlayHighlightDTO
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof GamePlayHighlightDTO
     */
    artworkUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof GamePlayHighlightDTO
     */
    singer?: string;
}
/**
 * 게임 종료 시 정답 유무를 채점하기 위하여 사용되는 정보
 * @export
 * @interface GameResultRequest
 */
export interface GameResultRequest {
    /**
     * 사용자가 입력한 정답 리스트
     * @type {Array<GameAnswer>}
     * @memberof GameResultRequest
     */
    gameAnswerList: Array<GameAnswer>;
    /**
     * 게임 시작 시 발급받은 playToken
     * @type {string}
     * @memberof GameResultRequest
     */
    playToken: string;
}
/**
 * 
 * @export
 * @interface GameResultResponse
 */
export interface GameResultResponse {
    /**
     * 
     * @type {number}
     * @memberof GameResultResponse
     */
    gainPointOfThisGame?: number;
    /**
     * 
     * @type {number}
     * @memberof GameResultResponse
     */
    totalPoint?: number;
    /**
     * 
     * @type {number}
     * @memberof GameResultResponse
     */
    myRanking?: number;
    /**
     * 
     * @type {number}
     * @memberof GameResultResponse
     */
    heartCount?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof GameResultResponse
     */
    resultComment?: Array<string>;
}
/**
 * 게임 결과
 * @export
 * @interface GameResultResponseV2
 */
export interface GameResultResponseV2 {
    /**
     * 이번판으로 휙득한 게임 점수.
     * @type {number}
     * @memberof GameResultResponseV2
     */
    gainPointOfThisGame?: number;
    /**
     * 각 시즌에 대한 랭킹/점수 포인트
     * @type {Array<ScoreViewModel>}
     * @memberof GameResultResponseV2
     */
    scoreViewModelList?: Array<ScoreViewModel>;
    /**
     * 남은 하트 갯수
     * @type {number}
     * @memberof GameResultResponseV2
     */
    heartCount?: number;
    /**
     * 게임 종료 후 결과 화면에 노출되는 2줄짜리 코멘트
     * @type {Array<string>}
     * @memberof GameResultResponseV2
     */
    resultComment?: Array<string>;
}
/**
 * 
 * @export
 * @interface GameStartRequest
 */
export interface GameStartRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof GameStartRequest
     */
    singerList?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof GameStartRequest
     */
    numOfHighlightPerGame?: number;
}
/**
 * 
 * @export
 * @interface GameStartResponse
 */
export interface GameStartResponse {
    /**
     * 
     * @type {Array<GamePlayHighlightDTO>}
     * @memberof GameStartResponse
     */
    playHighlightList?: Array<GamePlayHighlightDTO>;
    /**
     * 
     * @type {string}
     * @memberof GameStartResponse
     */
    playToken?: string;
}
/**
 * 
 * @export
 * @interface HeartResponse
 */
export interface HeartResponse {
    /**
     * 
     * @type {number}
     * @memberof HeartResponse
     */
    heartCount?: number;
    /**
     * 
     * @type {number}
     * @memberof HeartResponse
     */
    leftTime?: number;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {GameStartRequest}
     * @memberof InlineObject
     */
    gameRequest?: GameStartRequest;
    /**
     * 
     * @type {MusicUser}
     * @memberof InlineObject
     */
    musicUser?: MusicUser;
}
/**
 * 
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
    /**
     * 
     * @type {GameResultRequest}
     * @memberof InlineObject1
     */
    resultRequest?: GameResultRequest;
    /**
     * 
     * @type {MusicUser}
     * @memberof InlineObject1
     */
    musicUser?: MusicUser;
}
/**
 * 
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
    /**
     * 
     * @type {GameAnswerCheckRequest}
     * @memberof InlineObject2
     */
    answerCheckRequest?: GameAnswerCheckRequest;
    /**
     * 
     * @type {MusicUser}
     * @memberof InlineObject2
     */
    musicUser?: MusicUser;
}
/**
 * 
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
    /**
     * 
     * @type {any}
     * @memberof InlineObject3
     */
    profileImage?: any;
}
/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    itemType?: ItemItemTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    count?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ItemItemTypeEnum {
    SKIP = 'SKIP',
    CHARGEALLHEART = 'CHARGE_ALL_HEART'
}

/**
 * 
 * @export
 * @interface ItemUseRequest
 */
export interface ItemUseRequest {
    /**
     * 
     * @type {string}
     * @memberof ItemUseRequest
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof ItemUseRequest
     */
    highlightId?: number;
    /**
     * 
     * @type {string}
     * @memberof ItemUseRequest
     */
    playToken?: string;
}
/**
 * 
 * @export
 * @interface Like
 */
export interface Like {
    /**
     * 
     * @type {number}
     * @memberof Like
     */
    id?: number;
    /**
     * 
     * @type {Song}
     * @memberof Like
     */
    song?: Song;
    /**
     * 
     * @type {number}
     * @memberof Like
     */
    count?: number;
}
/**
 * 
 * @export
 * @interface LikeHistoryResponse
 */
export interface LikeHistoryResponse {
    /**
     * 
     * @type {number}
     * @memberof LikeHistoryResponse
     */
    trackId?: number;
    /**
     * 
     * @type {string}
     * @memberof LikeHistoryResponse
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof LikeHistoryResponse
     */
    singer?: string;
    /**
     * 
     * @type {string}
     * @memberof LikeHistoryResponse
     */
    artworkUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof LikeHistoryResponse
     */
    createdAt?: string;
}
/**
 * 
 * @export
 * @interface LikeRequest
 */
export interface LikeRequest {
    /**
     * 
     * @type {string}
     * @memberof LikeRequest
     */
    songUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof LikeRequest
     */
    trackId?: number;
    /**
     * 
     * @type {string}
     * @memberof LikeRequest
     */
    singerName?: string;
}
/**
 * 
 * @export
 * @interface LikeResponse
 */
export interface LikeResponse {
    /**
     * 
     * @type {number}
     * @memberof LikeResponse
     */
    trackId?: number;
    /**
     * 
     * @type {number}
     * @memberof LikeResponse
     */
    count?: number;
}
/**
 * 
 * @export
 * @interface LoggedInMusicUser
 */
export interface LoggedInMusicUser {
    /**
     * 
     * @type {string}
     * @memberof LoggedInMusicUser
     */
    token?: string;
    /**
     * 
     * @type {number}
     * @memberof LoggedInMusicUser
     */
    accessTime?: number;
    /**
     * 
     * @type {string}
     * @memberof LoggedInMusicUser
     */
    nickname?: string;
    /**
     * 
     * @type {string}
     * @memberof LoggedInMusicUser
     */
    profileImageUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof LoggedInMusicUser
     */
    clientId?: string;
}
/**
 * 
 * @export
 * @interface MusicUser
 */
export interface MusicUser {
    /**
     * 
     * @type {number}
     * @memberof MusicUser
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof MusicUser
     */
    nickname?: string;
    /**
     * 
     * @type {string}
     * @memberof MusicUser
     */
    socialType?: string;
    /**
     * 
     * @type {string}
     * @memberof MusicUser
     */
    profileDisplayPhotoFileName?: string;
    /**
     * 
     * @type {string}
     * @memberof MusicUser
     */
    role?: string;
}
/**
 * 현재 내 랭킹
 * @export
 * @interface MyRankView
 */
export interface MyRankView {
    /**
     * 내 닉네임
     * @type {string}
     * @memberof MyRankView
     */
    nickname?: string;
    /**
     * 내 포인트(스코어)
     * @type {number}
     * @memberof MyRankView
     */
    point?: number;
    /**
     * 내 랭킹
     * @type {number}
     * @memberof MyRankView
     */
    ranking?: number;
    /**
     * 내 프로필 이미지
     * @type {string}
     * @memberof MyRankView
     */
    profileImageUrl?: string;
}
/**
 * 
 * @export
 * @interface NicknameChangeRequest
 */
export interface NicknameChangeRequest {
    /**
     * 
     * @type {string}
     * @memberof NicknameChangeRequest
     */
    newNickname?: string;
}
/**
 * 
 * @export
 * @interface PageSongResponse
 */
export interface PageSongResponse {
    /**
     * 
     * @type {number}
     * @memberof PageSongResponse
     */
    totalPages?: number;
    /**
     * 
     * @type {number}
     * @memberof PageSongResponse
     */
    totalElements?: number;
    /**
     * 
     * @type {Sort}
     * @memberof PageSongResponse
     */
    sort?: Sort;
    /**
     * 
     * @type {boolean}
     * @memberof PageSongResponse
     */
    first?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageSongResponse
     */
    last?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageSongResponse
     */
    numberOfElements?: number;
    /**
     * 
     * @type {Pageable}
     * @memberof PageSongResponse
     */
    pageable?: Pageable;
    /**
     * 
     * @type {number}
     * @memberof PageSongResponse
     */
    size?: number;
    /**
     * 
     * @type {Array<SongResponse>}
     * @memberof PageSongResponse
     */
    content?: Array<SongResponse>;
    /**
     * 
     * @type {number}
     * @memberof PageSongResponse
     */
    number?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageSongResponse
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    page?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    size?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pageable
     */
    sort?: Array<string>;
}
/**
 * 랭킹 리스트
 * @export
 * @interface RankView
 */
export interface RankView {
    /**
     * 해당 랭킹의 유저 닉네임
     * @type {string}
     * @memberof RankView
     */
    nickname?: string;
    /**
     * 해당 랭킹 유저의 포인트(스코어)
     * @type {number}
     * @memberof RankView
     */
    point?: number;
    /**
     * 해당 랭킹 유저의 프로필 이미지
     * @type {string}
     * @memberof RankView
     */
    profileImageUrl?: string;
    /**
     * 해당 랭킹 유저의 등락 순위
     * @type {number}
     * @memberof RankView
     */
    rankDiff?: number;
}
/**
 * 랭킹 정보를 저장하는 뷰 모델.
 * @export
 * @interface RankViewModel
 */
export interface RankViewModel {
    /**
     * 랭킹 기준 시간
     * @type {number}
     * @memberof RankViewModel
     */
    time?: number;
    /**
     * 랭킹 리스트
     * @type {Array<RankView>}
     * @memberof RankViewModel
     */
    rankViewList?: Array<RankView>;
}
/**
 * 
 * @export
 * @interface ResponseBodyWrapperListString
 */
export interface ResponseBodyWrapperListString {
    /**
     * 응답 성공 시 응답 클래스
     * @type {Array<string>}
     * @memberof ResponseBodyWrapperListString
     */
    result?: Array<string>;
    /**
     * 응답 실패 사유
     * @type {string}
     * @memberof ResponseBodyWrapperListString
     */
    errorMsg?: string;
}
/**
 * 
 * @export
 * @interface ResponseDTO
 */
export interface ResponseDTO {
    /**
     * 
     * @type {number}
     * @memberof ResponseDTO
     */
    status?: number;
    /**
     * 
     * @type {object}
     * @memberof ResponseDTO
     */
    body?: object;
}
/**
 * 
 * @export
 * @interface ResponseDTOBoolean
 */
export interface ResponseDTOBoolean {
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOBoolean
     */
    status?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseDTOBoolean
     */
    body?: boolean;
}
/**
 * 
 * @export
 * @interface ResponseDTOGameResultResponse
 */
export interface ResponseDTOGameResultResponse {
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOGameResultResponse
     */
    status?: number;
    /**
     * 
     * @type {GameResultResponse}
     * @memberof ResponseDTOGameResultResponse
     */
    body?: GameResultResponse;
}
/**
 * 
 * @export
 * @interface ResponseDTOGameResultResponseV2
 */
export interface ResponseDTOGameResultResponseV2 {
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOGameResultResponseV2
     */
    status?: number;
    /**
     * 
     * @type {GameResultResponseV2}
     * @memberof ResponseDTOGameResultResponseV2
     */
    body?: GameResultResponseV2;
}
/**
 * 
 * @export
 * @interface ResponseDTOGameStartResponse
 */
export interface ResponseDTOGameStartResponse {
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOGameStartResponse
     */
    status?: number;
    /**
     * 
     * @type {GameStartResponse}
     * @memberof ResponseDTOGameStartResponse
     */
    body?: GameStartResponse;
}
/**
 * 
 * @export
 * @interface ResponseDTOHeartResponse
 */
export interface ResponseDTOHeartResponse {
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOHeartResponse
     */
    status?: number;
    /**
     * 
     * @type {HeartResponse}
     * @memberof ResponseDTOHeartResponse
     */
    body?: HeartResponse;
}
/**
 * 
 * @export
 * @interface ResponseDTOLikeResponse
 */
export interface ResponseDTOLikeResponse {
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOLikeResponse
     */
    status?: number;
    /**
     * 
     * @type {LikeResponse}
     * @memberof ResponseDTOLikeResponse
     */
    body?: LikeResponse;
}
/**
 * 
 * @export
 * @interface ResponseDTOListItem
 */
export interface ResponseDTOListItem {
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOListItem
     */
    status?: number;
    /**
     * 
     * @type {Array<Item>}
     * @memberof ResponseDTOListItem
     */
    body?: Array<Item>;
}
/**
 * 
 * @export
 * @interface ResponseDTOListLikeHistoryResponse
 */
export interface ResponseDTOListLikeHistoryResponse {
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOListLikeHistoryResponse
     */
    status?: number;
    /**
     * 
     * @type {Array<LikeHistoryResponse>}
     * @memberof ResponseDTOListLikeHistoryResponse
     */
    body?: Array<LikeHistoryResponse>;
}
/**
 * 
 * @export
 * @interface ResponseDTOListSinger
 */
export interface ResponseDTOListSinger {
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOListSinger
     */
    status?: number;
    /**
     * 
     * @type {Array<Singer>}
     * @memberof ResponseDTOListSinger
     */
    body?: Array<Singer>;
}
/**
 * 
 * @export
 * @interface ResponseDTOListString
 */
export interface ResponseDTOListString {
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOListString
     */
    status?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseDTOListString
     */
    body?: Array<string>;
}
/**
 * 
 * @export
 * @interface ResponseDTOListUserLikeHistoryResponse
 */
export interface ResponseDTOListUserLikeHistoryResponse {
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOListUserLikeHistoryResponse
     */
    status?: number;
    /**
     * 
     * @type {Array<UserLikeHistoryResponse>}
     * @memberof ResponseDTOListUserLikeHistoryResponse
     */
    body?: Array<UserLikeHistoryResponse>;
}
/**
 * 
 * @export
 * @interface ResponseDTOLoggedInMusicUser
 */
export interface ResponseDTOLoggedInMusicUser {
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOLoggedInMusicUser
     */
    status?: number;
    /**
     * 
     * @type {LoggedInMusicUser}
     * @memberof ResponseDTOLoggedInMusicUser
     */
    body?: LoggedInMusicUser;
}
/**
 * 
 * @export
 * @interface ResponseDTOPageSongResponse
 */
export interface ResponseDTOPageSongResponse {
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOPageSongResponse
     */
    status?: number;
    /**
     * 
     * @type {PageSongResponse}
     * @memberof ResponseDTOPageSongResponse
     */
    body?: PageSongResponse;
}
/**
 * 
 * @export
 * @interface ResponseDTORankViewModel
 */
export interface ResponseDTORankViewModel {
    /**
     * 
     * @type {number}
     * @memberof ResponseDTORankViewModel
     */
    status?: number;
    /**
     * 
     * @type {RankViewModel}
     * @memberof ResponseDTORankViewModel
     */
    body?: RankViewModel;
}
/**
 * 
 * @export
 * @interface ResponseDTOResponseStatusType
 */
export interface ResponseDTOResponseStatusType {
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOResponseStatusType
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof ResponseDTOResponseStatusType
     */
    body?: ResponseDTOResponseStatusTypeBodyEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ResponseDTOResponseStatusTypeBodyEnum {
    DEFAULTFAIL = 'DEFAULT_FAIL',
    RESPONSESUCCESS = 'RESPONSE_SUCCESS',
    REQUESTISNULL = 'REQUEST_IS_NULL',
    REQUESTLOGINFAIL = 'REQUEST_LOGIN_FAIL',
    USERALRD = 'USER_ALRD',
    USERINFONOTFOUND = 'USER_INFO_NOT_FOUND',
    SOCIALTYPENOTFOUND = 'SOCIAL_TYPE_NOT_FOUND',
    SONGREGISTEREDARLD = 'SONG_REGISTERED_ARLD',
    SONGFAILEDTOREGISTER = 'SONG_FAILED_TO_REGISTER',
    SONGFAILEDCOSPROGRESSISNOTEXIST = 'SONG_FAILED_COS_PROGRESS_IS_NOT_EXIST',
    SONGINFONOTFOUND = 'SONG_INFO_NOT_FOUND',
    SONGHIGHLIGHTEXCEED = 'SONG_HIGHLIGHT_EXCEED',
    HEARTHASBEENINITIALIZEDARLD = 'HEART_HAS_BEEN_INITIALIZED_ARLD',
    REWARDNOTFOUND = 'REWARD_NOT_FOUND',
    REWARDCANNOT = 'REWARD_CANNOT',
    ITEMTYPENOTFOUND = 'ITEM_TYPE_NOT_FOUND',
    ITEMUSEDALLALRD = 'ITEM_USED_ALL_ALRD',
    SINGERINFOCANNOTGETTING = 'SINGER_INFO_CANNOT_GETTING',
    SONGNOTSTREAMABLE = 'SONG_NOT_STREAMABLE',
    GAMECANNOTSTART = 'GAME_CANNOT_START',
    GAMEISNOTVALID = 'GAME_IS_NOT_VALID',
    GAMESTARTEDALREADY = 'GAME_STARTED_ALREADY',
    POINTEXCEEDMAXIMUMCANGETINONEROUND = 'POINT_EXCEED_MAXIMUM_CAN_GET_IN_ONE_ROUND',
    ALREADYLIKESONG = 'ALREADY_LIKE_SONG',
    CANNOTDISLIKESONG = 'CANNOT_DISLIKE_SONG'
}

/**
 * 
 * @export
 * @interface ResponseDTOReward
 */
export interface ResponseDTOReward {
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOReward
     */
    status?: number;
    /**
     * 
     * @type {Reward}
     * @memberof ResponseDTOReward
     */
    body?: Reward;
}
/**
 * 
 * @export
 * @interface ResponseDTOSeasonRankingView
 */
export interface ResponseDTOSeasonRankingView {
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOSeasonRankingView
     */
    status?: number;
    /**
     * 
     * @type {SeasonRankingView}
     * @memberof ResponseDTOSeasonRankingView
     */
    body?: SeasonRankingView;
}
/**
 * 
 * @export
 * @interface ResponseDTOSetString
 */
export interface ResponseDTOSetString {
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOSetString
     */
    status?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseDTOSetString
     */
    body?: Array<string>;
}
/**
 * 
 * @export
 * @interface ResponseDTOSong
 */
export interface ResponseDTOSong {
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOSong
     */
    status?: number;
    /**
     * 
     * @type {Song}
     * @memberof ResponseDTOSong
     */
    body?: Song;
}
/**
 * 
 * @export
 * @interface ResponseDTOString
 */
export interface ResponseDTOString {
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOString
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof ResponseDTOString
     */
    body?: string;
}
/**
 * 
 * @export
 * @interface Reward
 */
export interface Reward {
    /**
     * 
     * @type {number}
     * @memberof Reward
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Reward
     */
    rewardType?: string;
}
/**
 * 게임 결과 화면에 노출되는 스코어 관련 정보
 * @export
 * @interface ScoreViewModel
 */
export interface ScoreViewModel {
    /**
     * 
     * @type {AbstractScore}
     * @memberof ScoreViewModel
     */
    score?: AbstractScore;
    /**
     * 스코어에 해당하는 랭킹.
     * @type {number}
     * @memberof ScoreViewModel
     */
    ranking?: number;
    /**
     * 스코어에 해당하는 랭킹 타입.
     * @type {string}
     * @memberof ScoreViewModel
     */
    scoreType?: ScoreViewModelScoreTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ScoreViewModelScoreTypeEnum {
    SEASON = 'SEASON',
    MONTHLY = 'MONTHLY'
}

/**
 * 
 * @export
 * @interface SeasonRankingView
 */
export interface SeasonRankingView {
    /**
     * 
     * @type {RankViewModel}
     * @memberof SeasonRankingView
     */
    currentSeasonRanking?: RankViewModel;
    /**
     * 지난 시즌 탑 3
     * @type {Array<RankView>}
     * @memberof SeasonRankingView
     */
    lastSeasonTop3?: Array<RankView>;
    /**
     * 
     * @type {MyRankView}
     * @memberof SeasonRankingView
     */
    myRank?: MyRankView;
    /**
     * 이번 시즌이 끝날 때 까지 남은 시간
     * @type {number}
     * @memberof SeasonRankingView
     */
    timeToFinishThisSeason?: number;
}
/**
 * 가수 정보를 갖고 있는 오브젝트.
 * @export
 * @interface Singer
 */
export interface Singer {
    /**
     * 가수 ID
     * @type {number}
     * @memberof Singer
     */
    id?: number;
    /**
     * 가수 이름
     * @type {string}
     * @memberof Singer
     */
    singerName?: string;
    /**
     * 사용자들에게 얼마나 많은 좋아요를 받았는지 여부.
     * @type {number}
     * @memberof Singer
     */
    exportedCount?: number;
    /**
     * 해당 가수가 문제로 출제 될 수 있는 highlight를 갖고 있는지에 대한 여부.
     * @type {boolean}
     * @memberof Singer
     */
    hasHighlight?: boolean;
    /**
     * 가수의 최근 앨범 이미지 URL
     * @type {string}
     * @memberof Singer
     */
    artworkUrl?: string;
}
/**
 * 가수가 갖고있는 노래의 정보
 * @export
 * @interface Song
 */
export interface Song {
    /**
     * 노래 ID
     * @type {number}
     * @memberof Song
     */
    id?: number;
    /**
     * 노래 streaming url
     * @type {string}
     * @memberof Song
     */
    url?: string;
    /**
     * 노래 앨범 url
     * @type {string}
     * @memberof Song
     */
    artworkUrl?: string;
    /**
     * 노래 trackId, 이 값은 SoundCloud의 노래의 trackId랑 같은 값임
     * @type {number}
     * @memberof Song
     */
    trackId?: number;
    /**
     * 사용자들에게 노출될 title
     * @type {string}
     * @memberof Song
     */
    title?: string;
    /**
     * 노래의 정답. 사용자는 이 답을 입력 해야지만 정답 처리가 된다
     * @type {string}
     * @memberof Song
     */
    refinedTitle?: string;
    /**
     * 이 노래의 주인인 가수 이름.
     * @type {string}
     * @memberof Song
     */
    singerName?: string;
    /**
     * 
     * @type {Singer}
     * @memberof Song
     */
    singer?: Singer;
    /**
     * true : 사용자들에게 출제 되고 있는 문제임 / false : 사용자들에게 출제 되고 있지 않은 노래임.
     * @type {boolean}
     * @memberof Song
     */
    exported?: boolean;
    /**
     * 
     * @type {Like}
     * @memberof Song
     */
    like?: Like;
    /**
     * 
     * @type {MusicUser}
     * @memberof Song
     */
    musicUser?: MusicUser;
    /**
     * 해당 노래가 갖고있는 Highlight들의 집합. 해당 highlight 정보를 이용하여 게임 플레이를 진행함.
     * @type {Array<SongHighlight>}
     * @memberof Song
     */
    songHighlight?: Array<SongHighlight>;
    /**
     * 노래의 길이(milliseconds)
     * @type {number}
     * @memberof Song
     */
    duration?: number;
}
/**
 * 특정 Song에 등록된 Highlight들. 해당 객체의 정보를 바탕으로 문제가 출제된다.
 * @export
 * @interface SongHighlight
 */
export interface SongHighlight {
    /**
     * songHighlight ID
     * @type {number}
     * @memberof SongHighlight
     */
    id?: number;
    /**
     * 사용자가 노래를 듣게 될 시작부분.
     * @type {number}
     * @memberof SongHighlight
     */
    millisecond?: number;
    /**
     * 해당 highlight가 출제되고 있는지에 대한 여부
     * @type {boolean}
     * @memberof SongHighlight
     */
    elected?: boolean;
    /**
     * 
     * @type {Song}
     * @memberof SongHighlight
     */
    song?: Song;
}
/**
 * 
 * @export
 * @interface SongHighlightAddRequest
 */
export interface SongHighlightAddRequest {
    /**
     * 
     * @type {number}
     * @memberof SongHighlightAddRequest
     */
    songId: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof SongHighlightAddRequest
     */
    highlightSeconds: Array<number>;
}
/**
 * 
 * @export
 * @interface SongRegisterRequest
 */
export interface SongRegisterRequest {
    /**
     * 
     * @type {string}
     * @memberof SongRegisterRequest
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof SongRegisterRequest
     */
    singerName: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof SongRegisterRequest
     */
    highlightSeconds?: Array<number>;
}
/**
 * 
 * @export
 * @interface SongResponse
 */
export interface SongResponse {
    /**
     * 
     * @type {string}
     * @memberof SongResponse
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof SongResponse
     */
    artworkUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof SongResponse
     */
    trackId?: number;
    /**
     * 
     * @type {string}
     * @memberof SongResponse
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof SongResponse
     */
    singer?: string;
    /**
     * 
     * @type {number}
     * @memberof SongResponse
     */
    like?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SongResponse
     */
    alreadyLike?: boolean;
}
/**
 * 
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    sorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    unsorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    empty?: boolean;
}
/**
 * 
 * @export
 * @interface Track
 */
export interface Track {
    /**
     * 
     * @type {number}
     * @memberof Track
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    stream_url?: string;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    artwork_url?: string;
    /**
     * 
     * @type {number}
     * @memberof Track
     */
    comment_count?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Track
     */
    streamable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    singerName?: string;
}
/**
 * 
 * @export
 * @interface UserLikeHistoryResponse
 */
export interface UserLikeHistoryResponse {
    /**
     * 
     * @type {string}
     * @memberof UserLikeHistoryResponse
     */
    accessId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLikeHistoryResponse
     */
    nickname?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLikeHistoryResponse
     */
    createdAt?: string;
}
/**
 * 
 * @export
 * @interface UserLoginRequest
 */
export interface UserLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof UserLoginRequest
     */
    accessId: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginRequest
     */
    accessToken: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginRequest
     */
    refreshToken?: string;
}
/**
 * 
 * @export
 * @interface UserSignUpRequest
 */
export interface UserSignUpRequest {
    /**
     * 
     * @type {string}
     * @memberof UserSignUpRequest
     */
    accessId: string;
    /**
     * 
     * @type {string}
     * @memberof UserSignUpRequest
     */
    deviceId: string;
    /**
     * 
     * @type {string}
     * @memberof UserSignUpRequest
     */
    nickname: string;
    /**
     * 
     * @type {string}
     * @memberof UserSignUpRequest
     */
    socialType: string;
    /**
     * 
     * @type {string}
     * @memberof UserSignUpRequest
     */
    invitedBy?: string;
}

/**
 * AdvertiseKeywordControllerApi - axios parameter creator
 * @export
 */
export const AdvertiseKeywordControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdvertiseKeyword: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/advertise/keywords`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdvertiseKeywordControllerApi - functional programming interface
 * @export
 */
export const AdvertiseKeywordControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdvertiseKeyword(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOListString>> {
            const localVarAxiosArgs = await AdvertiseKeywordControllerApiAxiosParamCreator(configuration).getAdvertiseKeyword(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AdvertiseKeywordControllerApi - factory interface
 * @export
 */
export const AdvertiseKeywordControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdvertiseKeyword(options?: any): AxiosPromise<ResponseDTOListString> {
            return AdvertiseKeywordControllerApiFp(configuration).getAdvertiseKeyword(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdvertiseKeywordControllerApi - object-oriented interface
 * @export
 * @class AdvertiseKeywordControllerApi
 * @extends {BaseAPI}
 */
export class AdvertiseKeywordControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvertiseKeywordControllerApi
     */
    public getAdvertiseKeyword(options?: any) {
        return AdvertiseKeywordControllerApiFp(this.configuration).getAdvertiseKeyword(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * Class01APIV2Api - axios parameter creator
 * @export
 */
export const Class01APIV2ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 시즌 랭킹, 월간 랭킹 부분을 누적하여 저장하는 API. 하위 호환성을 위하여 V2로 분기함.
         * @summary 게임 결과 데이터 가져오는 API
         * @param {GameResultRequest} gameResultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameResult1: async (gameResultRequest: GameResultRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameResultRequest' is not null or undefined
            if (gameResultRequest === null || gameResultRequest === undefined) {
                throw new RequiredError('gameResultRequest','Required parameter gameResultRequest was null or undefined when calling gameResult1.');
            }
            const localVarPath = `/v2/game/result`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof gameResultRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(gameResultRequest !== undefined ? gameResultRequest : {}) : (gameResultRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class01APIV2Api - functional programming interface
 * @export
 */
export const Class01APIV2ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 시즌 랭킹, 월간 랭킹 부분을 누적하여 저장하는 API. 하위 호환성을 위하여 V2로 분기함.
         * @summary 게임 결과 데이터 가져오는 API
         * @param {GameResultRequest} gameResultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameResult1(gameResultRequest: GameResultRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOGameResultResponseV2>> {
            const localVarAxiosArgs = await Class01APIV2ApiAxiosParamCreator(configuration).gameResult1(gameResultRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * Class01APIV2Api - factory interface
 * @export
 */
export const Class01APIV2ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 시즌 랭킹, 월간 랭킹 부분을 누적하여 저장하는 API. 하위 호환성을 위하여 V2로 분기함.
         * @summary 게임 결과 데이터 가져오는 API
         * @param {GameResultRequest} gameResultRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameResult1(gameResultRequest: GameResultRequest, options?: any): AxiosPromise<ResponseDTOGameResultResponseV2> {
            return Class01APIV2ApiFp(configuration).gameResult1(gameResultRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class01APIV2Api - object-oriented interface
 * @export
 * @class Class01APIV2Api
 * @extends {BaseAPI}
 */
export class Class01APIV2Api extends BaseAPI {
    /**
     * 시즌 랭킹, 월간 랭킹 부분을 누적하여 저장하는 API. 하위 호환성을 위하여 V2로 분기함.
     * @summary 게임 결과 데이터 가져오는 API
     * @param {GameResultRequest} gameResultRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class01APIV2Api
     */
    public gameResult1(gameResultRequest: GameResultRequest, options?: any) {
        return Class01APIV2ApiFp(this.configuration).gameResult1(gameResultRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * GameControllerApi - axios parameter creator
 * @export
 */
export const GameControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameResult: async (inlineObject1: InlineObject1, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject1' is not null or undefined
            if (inlineObject1 === null || inlineObject1 === undefined) {
                throw new RequiredError('inlineObject1','Required parameter inlineObject1 was null or undefined when calling gameResult.');
            }
            const localVarPath = `/game/result`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject1 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject1 !== undefined ? inlineObject1 : {}) : (inlineObject1 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightList: async (inlineObject: InlineObject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject' is not null or undefined
            if (inlineObject === null || inlineObject === undefined) {
                throw new RequiredError('inlineObject','Required parameter inlineObject was null or undefined when calling getHighlightList.');
            }
            const localVarPath = `/game/start`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject !== undefined ? inlineObject : {}) : (inlineObject || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAnswer: async (inlineObject2: InlineObject2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inlineObject2' is not null or undefined
            if (inlineObject2 === null || inlineObject2 === undefined) {
                throw new RequiredError('inlineObject2','Required parameter inlineObject2 was null or undefined when calling isAnswer.');
            }
            const localVarPath = `/game/answer`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject2 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject2 !== undefined ? inlineObject2 : {}) : (inlineObject2 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refine: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/game/refine`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GameControllerApi - functional programming interface
 * @export
 */
export const GameControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameResult(inlineObject1: InlineObject1, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOGameResultResponse>> {
            const localVarAxiosArgs = await GameControllerApiAxiosParamCreator(configuration).gameResult(inlineObject1, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHighlightList(inlineObject: InlineObject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOGameStartResponse>> {
            const localVarAxiosArgs = await GameControllerApiAxiosParamCreator(configuration).getHighlightList(inlineObject, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isAnswer(inlineObject2: InlineObject2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOBoolean>> {
            const localVarAxiosArgs = await GameControllerApiAxiosParamCreator(configuration).isAnswer(inlineObject2, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refine(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await GameControllerApiAxiosParamCreator(configuration).refine(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GameControllerApi - factory interface
 * @export
 */
export const GameControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {InlineObject1} inlineObject1 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameResult(inlineObject1: InlineObject1, options?: any): AxiosPromise<ResponseDTOGameResultResponse> {
            return GameControllerApiFp(configuration).gameResult(inlineObject1, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject} inlineObject 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightList(inlineObject: InlineObject, options?: any): AxiosPromise<ResponseDTOGameStartResponse> {
            return GameControllerApiFp(configuration).getHighlightList(inlineObject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject2} inlineObject2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAnswer(inlineObject2: InlineObject2, options?: any): AxiosPromise<ResponseDTOBoolean> {
            return GameControllerApiFp(configuration).isAnswer(inlineObject2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refine(options?: any): AxiosPromise<string> {
            return GameControllerApiFp(configuration).refine(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GameControllerApi - object-oriented interface
 * @export
 * @class GameControllerApi
 * @extends {BaseAPI}
 */
export class GameControllerApi extends BaseAPI {
    /**
     * 
     * @param {InlineObject1} inlineObject1 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public gameResult(inlineObject1: InlineObject1, options?: any) {
        return GameControllerApiFp(this.configuration).gameResult(inlineObject1, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject} inlineObject 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public getHighlightList(inlineObject: InlineObject, options?: any) {
        return GameControllerApiFp(this.configuration).getHighlightList(inlineObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject2} inlineObject2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public isAnswer(inlineObject2: InlineObject2, options?: any) {
        return GameControllerApiFp(this.configuration).isAnswer(inlineObject2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public refine(options?: any) {
        return GameControllerApiFp(this.configuration).refine(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * HealthCheckControllerApi - axios parameter creator
 * @export
 */
export const HealthCheckControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cache: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/cache`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck2: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/check`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/test`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthCheckControllerApi - functional programming interface
 * @export
 */
export const HealthCheckControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cache(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await HealthCheckControllerApiAxiosParamCreator(configuration).cache(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheck2(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await HealthCheckControllerApiAxiosParamCreator(configuration).healthCheck2(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async test(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await HealthCheckControllerApiAxiosParamCreator(configuration).test(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HealthCheckControllerApi - factory interface
 * @export
 */
export const HealthCheckControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cache(options?: any): AxiosPromise<number> {
            return HealthCheckControllerApiFp(configuration).cache(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck2(options?: any): AxiosPromise<boolean> {
            return HealthCheckControllerApiFp(configuration).healthCheck2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test(options?: any): AxiosPromise<boolean> {
            return HealthCheckControllerApiFp(configuration).test(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthCheckControllerApi - object-oriented interface
 * @export
 * @class HealthCheckControllerApi
 * @extends {BaseAPI}
 */
export class HealthCheckControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckControllerApi
     */
    public cache(options?: any) {
        return HealthCheckControllerApiFp(this.configuration).cache(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckControllerApi
     */
    public healthCheck2(options?: any) {
        return HealthCheckControllerApiFp(this.configuration).healthCheck2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckControllerApi
     */
    public test(options?: any) {
        return HealthCheckControllerApiFp(this.configuration).test(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * HeartControllerApi - axios parameter creator
 * @export
 */
export const HeartControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MusicUser} musicUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkMyHeart: async (musicUser: MusicUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'musicUser' is not null or undefined
            if (musicUser === null || musicUser === undefined) {
                throw new RequiredError('musicUser','Required parameter musicUser was null or undefined when calling checkMyHeart.');
            }
            const localVarPath = `/heart/check`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (musicUser !== undefined) {
                localVarQueryParameter['musicUser'] = musicUser;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MusicUser} [musicUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useHeart: async (musicUser?: MusicUser, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/heart/use`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof musicUser !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(musicUser !== undefined ? musicUser : {}) : (musicUser || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HeartControllerApi - functional programming interface
 * @export
 */
export const HeartControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MusicUser} musicUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkMyHeart(musicUser: MusicUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOHeartResponse>> {
            const localVarAxiosArgs = await HeartControllerApiAxiosParamCreator(configuration).checkMyHeart(musicUser, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {MusicUser} [musicUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async useHeart(musicUser?: MusicUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOHeartResponse>> {
            const localVarAxiosArgs = await HeartControllerApiAxiosParamCreator(configuration).useHeart(musicUser, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HeartControllerApi - factory interface
 * @export
 */
export const HeartControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {MusicUser} musicUser 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkMyHeart(musicUser: MusicUser, options?: any): AxiosPromise<ResponseDTOHeartResponse> {
            return HeartControllerApiFp(configuration).checkMyHeart(musicUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MusicUser} [musicUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useHeart(musicUser?: MusicUser, options?: any): AxiosPromise<ResponseDTOHeartResponse> {
            return HeartControllerApiFp(configuration).useHeart(musicUser, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HeartControllerApi - object-oriented interface
 * @export
 * @class HeartControllerApi
 * @extends {BaseAPI}
 */
export class HeartControllerApi extends BaseAPI {
    /**
     * 
     * @param {MusicUser} musicUser 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartControllerApi
     */
    public checkMyHeart(musicUser: MusicUser, options?: any) {
        return HeartControllerApiFp(this.configuration).checkMyHeart(musicUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MusicUser} [musicUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartControllerApi
     */
    public useHeart(musicUser?: MusicUser, options?: any) {
        return HeartControllerApiFp(this.configuration).useHeart(musicUser, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ItemControllerApi - axios parameter creator
 * @export
 */
export const ItemControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findItemAll: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/item/all`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 아이템 종류는 SKIP, CHARGE_ALL_HEART 있음. 
         * @summary 아이템 사용하는 컨트롤러
         * @param {ItemUseRequest} itemUseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useItem: async (itemUseRequest: ItemUseRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemUseRequest' is not null or undefined
            if (itemUseRequest === null || itemUseRequest === undefined) {
                throw new RequiredError('itemUseRequest','Required parameter itemUseRequest was null or undefined when calling useItem.');
            }
            const localVarPath = `/item/use`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof itemUseRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(itemUseRequest !== undefined ? itemUseRequest : {}) : (itemUseRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemControllerApi - functional programming interface
 * @export
 */
export const ItemControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findItemAll(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOListItem>> {
            const localVarAxiosArgs = await ItemControllerApiAxiosParamCreator(configuration).findItemAll(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 아이템 종류는 SKIP, CHARGE_ALL_HEART 있음. 
         * @summary 아이템 사용하는 컨트롤러
         * @param {ItemUseRequest} itemUseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async useItem(itemUseRequest: ItemUseRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTO>> {
            const localVarAxiosArgs = await ItemControllerApiAxiosParamCreator(configuration).useItem(itemUseRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ItemControllerApi - factory interface
 * @export
 */
export const ItemControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findItemAll(options?: any): AxiosPromise<ResponseDTOListItem> {
            return ItemControllerApiFp(configuration).findItemAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 아이템 종류는 SKIP, CHARGE_ALL_HEART 있음. 
         * @summary 아이템 사용하는 컨트롤러
         * @param {ItemUseRequest} itemUseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useItem(itemUseRequest: ItemUseRequest, options?: any): AxiosPromise<ResponseDTO> {
            return ItemControllerApiFp(configuration).useItem(itemUseRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemControllerApi - object-oriented interface
 * @export
 * @class ItemControllerApi
 * @extends {BaseAPI}
 */
export class ItemControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemControllerApi
     */
    public findItemAll(options?: any) {
        return ItemControllerApiFp(this.configuration).findItemAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 아이템 종류는 SKIP, CHARGE_ALL_HEART 있음. 
     * @summary 아이템 사용하는 컨트롤러
     * @param {ItemUseRequest} itemUseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemControllerApi
     */
    public useItem(itemUseRequest: ItemUseRequest, options?: any) {
        return ItemControllerApiFp(this.configuration).useItem(itemUseRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * LikeControllerApi - axios parameter creator
 * @export
 */
export const LikeControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LikeRequest} likeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dislike: async (likeRequest: LikeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'likeRequest' is not null or undefined
            if (likeRequest === null || likeRequest === undefined) {
                throw new RequiredError('likeRequest','Required parameter likeRequest was null or undefined when calling dislike.');
            }
            const localVarPath = `/dislike`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof likeRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(likeRequest !== undefined ? likeRequest : {}) : (likeRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LikeRequest} likeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        like: async (likeRequest: LikeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'likeRequest' is not null or undefined
            if (likeRequest === null || likeRequest === undefined) {
                throw new RequiredError('likeRequest','Required parameter likeRequest was null or undefined when calling like.');
            }
            const localVarPath = `/like`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof likeRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(likeRequest !== undefined ? likeRequest : {}) : (likeRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LikeControllerApi - functional programming interface
 * @export
 */
export const LikeControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LikeRequest} likeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dislike(likeRequest: LikeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOLikeResponse>> {
            const localVarAxiosArgs = await LikeControllerApiAxiosParamCreator(configuration).dislike(likeRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {LikeRequest} likeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async like(likeRequest: LikeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOLikeResponse>> {
            const localVarAxiosArgs = await LikeControllerApiAxiosParamCreator(configuration).like(likeRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LikeControllerApi - factory interface
 * @export
 */
export const LikeControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {LikeRequest} likeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dislike(likeRequest: LikeRequest, options?: any): AxiosPromise<ResponseDTOLikeResponse> {
            return LikeControllerApiFp(configuration).dislike(likeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LikeRequest} likeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        like(likeRequest: LikeRequest, options?: any): AxiosPromise<ResponseDTOLikeResponse> {
            return LikeControllerApiFp(configuration).like(likeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LikeControllerApi - object-oriented interface
 * @export
 * @class LikeControllerApi
 * @extends {BaseAPI}
 */
export class LikeControllerApi extends BaseAPI {
    /**
     * 
     * @param {LikeRequest} likeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeControllerApi
     */
    public dislike(likeRequest: LikeRequest, options?: any) {
        return LikeControllerApiFp(this.configuration).dislike(likeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LikeRequest} likeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeControllerApi
     */
    public like(likeRequest: LikeRequest, options?: any) {
        return LikeControllerApiFp(this.configuration).like(likeRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * LikeHistoryControllerApi - axios parameter creator
 * @export
 */
export const LikeHistoryControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} trackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikeHistory: async (trackId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackId' is not null or undefined
            if (trackId === null || trackId === undefined) {
                throw new RequiredError('trackId','Required parameter trackId was null or undefined when calling getLikeHistory.');
            }
            const localVarPath = `/history/like/song/{trackId}`
                .replace(`{${"trackId"}}`, encodeURIComponent(String(trackId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHistory: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/history/like/user`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LikeHistoryControllerApi - functional programming interface
 * @export
 */
export const LikeHistoryControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} trackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLikeHistory(trackId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOListUserLikeHistoryResponse>> {
            const localVarAxiosArgs = await LikeHistoryControllerApiAxiosParamCreator(configuration).getLikeHistory(trackId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserHistory(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOListLikeHistoryResponse>> {
            const localVarAxiosArgs = await LikeHistoryControllerApiAxiosParamCreator(configuration).getUserHistory(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LikeHistoryControllerApi - factory interface
 * @export
 */
export const LikeHistoryControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {number} trackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikeHistory(trackId: number, options?: any): AxiosPromise<ResponseDTOListUserLikeHistoryResponse> {
            return LikeHistoryControllerApiFp(configuration).getLikeHistory(trackId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHistory(options?: any): AxiosPromise<ResponseDTOListLikeHistoryResponse> {
            return LikeHistoryControllerApiFp(configuration).getUserHistory(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LikeHistoryControllerApi - object-oriented interface
 * @export
 * @class LikeHistoryControllerApi
 * @extends {BaseAPI}
 */
export class LikeHistoryControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} trackId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeHistoryControllerApi
     */
    public getLikeHistory(trackId: number, options?: any) {
        return LikeHistoryControllerApiFp(this.configuration).getLikeHistory(trackId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeHistoryControllerApi
     */
    public getUserHistory(options?: any) {
        return LikeHistoryControllerApiFp(this.configuration).getUserHistory(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * MusicUserControllerApi - axios parameter creator
 * @export
 */
export const MusicUserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {NicknameChangeRequest} nicknameChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInfoChange: async (nicknameChangeRequest: NicknameChangeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nicknameChangeRequest' is not null or undefined
            if (nicknameChangeRequest === null || nicknameChangeRequest === undefined) {
                throw new RequiredError('nicknameChangeRequest','Required parameter nicknameChangeRequest was null or undefined when calling myInfoChange.');
            }
            const localVarPath = `/user/profile/nickname`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof nicknameChangeRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(nicknameChangeRequest !== undefined ? nicknameChangeRequest : {}) : (nicknameChangeRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject3} [inlineObject3] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInfoChange1: async (inlineObject3?: InlineObject3, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/profile/dp`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof inlineObject3 !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(inlineObject3 !== undefined ? inlineObject3 : {}) : (inlineObject3 || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/login/refresh`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secedeSelf: async (body: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling secedeSelf.');
            }
            const localVarPath = `/user/delete`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserLoginRequest} userLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signIn: async (userLoginRequest: UserLoginRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userLoginRequest' is not null or undefined
            if (userLoginRequest === null || userLoginRequest === undefined) {
                throw new RequiredError('userLoginRequest','Required parameter userLoginRequest was null or undefined when calling signIn.');
            }
            const localVarPath = `/user/login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userLoginRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userLoginRequest !== undefined ? userLoginRequest : {}) : (userLoginRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UserSignUpRequest} userSignUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp: async (userSignUpRequest: UserSignUpRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userSignUpRequest' is not null or undefined
            if (userSignUpRequest === null || userSignUpRequest === undefined) {
                throw new RequiredError('userSignUpRequest','Required parameter userSignUpRequest was null or undefined when calling signUp.');
            }
            const localVarPath = `/user/signup`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userSignUpRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userSignUpRequest !== undefined ? userSignUpRequest : {}) : (userSignUpRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MusicUserControllerApi - functional programming interface
 * @export
 */
export const MusicUserControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {NicknameChangeRequest} nicknameChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async myInfoChange(nicknameChangeRequest: NicknameChangeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOBoolean>> {
            const localVarAxiosArgs = await MusicUserControllerApiAxiosParamCreator(configuration).myInfoChange(nicknameChangeRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {InlineObject3} [inlineObject3] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async myInfoChange1(inlineObject3?: InlineObject3, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOString>> {
            const localVarAxiosArgs = await MusicUserControllerApiAxiosParamCreator(configuration).myInfoChange1(inlineObject3, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOString>> {
            const localVarAxiosArgs = await MusicUserControllerApiAxiosParamCreator(configuration).refreshToken(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secedeSelf(body: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOResponseStatusType>> {
            const localVarAxiosArgs = await MusicUserControllerApiAxiosParamCreator(configuration).secedeSelf(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UserLoginRequest} userLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signIn(userLoginRequest: UserLoginRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOLoggedInMusicUser>> {
            const localVarAxiosArgs = await MusicUserControllerApiAxiosParamCreator(configuration).signIn(userLoginRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {UserSignUpRequest} userSignUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signUp(userSignUpRequest: UserSignUpRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTO>> {
            const localVarAxiosArgs = await MusicUserControllerApiAxiosParamCreator(configuration).signUp(userSignUpRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MusicUserControllerApi - factory interface
 * @export
 */
export const MusicUserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {NicknameChangeRequest} nicknameChangeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInfoChange(nicknameChangeRequest: NicknameChangeRequest, options?: any): AxiosPromise<ResponseDTOBoolean> {
            return MusicUserControllerApiFp(configuration).myInfoChange(nicknameChangeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject3} [inlineObject3] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInfoChange1(inlineObject3?: InlineObject3, options?: any): AxiosPromise<ResponseDTOString> {
            return MusicUserControllerApiFp(configuration).myInfoChange1(inlineObject3, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(options?: any): AxiosPromise<ResponseDTOString> {
            return MusicUserControllerApiFp(configuration).refreshToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secedeSelf(body: string, options?: any): AxiosPromise<ResponseDTOResponseStatusType> {
            return MusicUserControllerApiFp(configuration).secedeSelf(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserLoginRequest} userLoginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signIn(userLoginRequest: UserLoginRequest, options?: any): AxiosPromise<ResponseDTOLoggedInMusicUser> {
            return MusicUserControllerApiFp(configuration).signIn(userLoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UserSignUpRequest} userSignUpRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUp(userSignUpRequest: UserSignUpRequest, options?: any): AxiosPromise<ResponseDTO> {
            return MusicUserControllerApiFp(configuration).signUp(userSignUpRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MusicUserControllerApi - object-oriented interface
 * @export
 * @class MusicUserControllerApi
 * @extends {BaseAPI}
 */
export class MusicUserControllerApi extends BaseAPI {
    /**
     * 
     * @param {NicknameChangeRequest} nicknameChangeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public myInfoChange(nicknameChangeRequest: NicknameChangeRequest, options?: any) {
        return MusicUserControllerApiFp(this.configuration).myInfoChange(nicknameChangeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject3} [inlineObject3] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public myInfoChange1(inlineObject3?: InlineObject3, options?: any) {
        return MusicUserControllerApiFp(this.configuration).myInfoChange1(inlineObject3, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public refreshToken(options?: any) {
        return MusicUserControllerApiFp(this.configuration).refreshToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public secedeSelf(body: string, options?: any) {
        return MusicUserControllerApiFp(this.configuration).secedeSelf(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserLoginRequest} userLoginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public signIn(userLoginRequest: UserLoginRequest, options?: any) {
        return MusicUserControllerApiFp(this.configuration).signIn(userLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UserSignUpRequest} userSignUpRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public signUp(userSignUpRequest: UserSignUpRequest, options?: any) {
        return MusicUserControllerApiFp(this.configuration).signUp(userSignUpRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * RankingControllerApi - axios parameter creator
 * @export
 */
export const RankingControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rank/list`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoOfMonths: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rank/month`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoOfSeason: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rank/season`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RankingControllerApi - functional programming interface
 * @export
 */
export const RankingControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRankingInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTORankViewModel>> {
            const localVarAxiosArgs = await RankingControllerApiAxiosParamCreator(configuration).getRankingInfo(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRankingInfoOfMonths(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTORankViewModel>> {
            const localVarAxiosArgs = await RankingControllerApiAxiosParamCreator(configuration).getRankingInfoOfMonths(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRankingInfoOfSeason(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOSeasonRankingView>> {
            const localVarAxiosArgs = await RankingControllerApiAxiosParamCreator(configuration).getRankingInfoOfSeason(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RankingControllerApi - factory interface
 * @export
 */
export const RankingControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfo(options?: any): AxiosPromise<ResponseDTORankViewModel> {
            return RankingControllerApiFp(configuration).getRankingInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoOfMonths(options?: any): AxiosPromise<ResponseDTORankViewModel> {
            return RankingControllerApiFp(configuration).getRankingInfoOfMonths(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoOfSeason(options?: any): AxiosPromise<ResponseDTOSeasonRankingView> {
            return RankingControllerApiFp(configuration).getRankingInfoOfSeason(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RankingControllerApi - object-oriented interface
 * @export
 * @class RankingControllerApi
 * @extends {BaseAPI}
 */
export class RankingControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankingControllerApi
     */
    public getRankingInfo(options?: any) {
        return RankingControllerApiFp(this.configuration).getRankingInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankingControllerApi
     */
    public getRankingInfoOfMonths(options?: any) {
        return RankingControllerApiFp(this.configuration).getRankingInfoOfMonths(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankingControllerApi
     */
    public getRankingInfoOfSeason(options?: any) {
        return RankingControllerApiFp(this.configuration).getRankingInfoOfSeason(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * RewardControllerApi - axios parameter creator
 * @export
 */
export const RewardControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 유저가 하트 리워드기 필요할 경우 호출하는 API type 광고 시청 : \'ad_movie\', 노래 추천 : \'suggest_music\'
         * @summary 리워드 API
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewardForWatchingAd: async (type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling rewardForWatchingAd.');
            }
            const localVarPath = `/reward/types/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RewardControllerApi - functional programming interface
 * @export
 */
export const RewardControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 유저가 하트 리워드기 필요할 경우 호출하는 API type 광고 시청 : \'ad_movie\', 노래 추천 : \'suggest_music\'
         * @summary 리워드 API
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewardForWatchingAd(type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOReward>> {
            const localVarAxiosArgs = await RewardControllerApiAxiosParamCreator(configuration).rewardForWatchingAd(type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RewardControllerApi - factory interface
 * @export
 */
export const RewardControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 유저가 하트 리워드기 필요할 경우 호출하는 API type 광고 시청 : \'ad_movie\', 노래 추천 : \'suggest_music\'
         * @summary 리워드 API
         * @param {string} type 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewardForWatchingAd(type: string, options?: any): AxiosPromise<ResponseDTOReward> {
            return RewardControllerApiFp(configuration).rewardForWatchingAd(type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RewardControllerApi - object-oriented interface
 * @export
 * @class RewardControllerApi
 * @extends {BaseAPI}
 */
export class RewardControllerApi extends BaseAPI {
    /**
     * 유저가 하트 리워드기 필요할 경우 호출하는 API type 광고 시청 : \'ad_movie\', 노래 추천 : \'suggest_music\'
     * @summary 리워드 API
     * @param {string} type 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardControllerApi
     */
    public rewardForWatchingAd(type: string, options?: any) {
        return RewardControllerApiFp(this.configuration).rewardForWatchingAd(type, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SingerControllerApi - axios parameter creator
 * @export
 */
export const SingerControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRegisteredSingerName: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/singer/registered`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSingerName: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/singer/all`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} singerName 
         * @param {number} page 
         * @param {number} size 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSongsBySingerName: async (singerName: string, page: number, size: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'singerName' is not null or undefined
            if (singerName === null || singerName === undefined) {
                throw new RequiredError('singerName','Required parameter singerName was null or undefined when calling getAllSongsBySingerName.');
            }
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getAllSongsBySingerName.');
            }
            // verify required parameter 'size' is not null or undefined
            if (size === null || size === undefined) {
                throw new RequiredError('size','Required parameter size was null or undefined when calling getAllSongsBySingerName.');
            }
            const localVarPath = `/singer/songs`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (singerName !== undefined) {
                localVarQueryParameter['singerName'] = singerName;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllStandardSingerList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/singer/standard-list`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 각 trackId에 해당하는 progressive url을 내려준다.
         * @summary progressive url 반환해주는 API
         * @param {string} u 
         * @param {Array<number>} trackIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgressiveUrl: async (u: string, trackIds: Array<number>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'u' is not null or undefined
            if (u === null || u === undefined) {
                throw new RequiredError('u','Required parameter u was null or undefined when calling getProgressiveUrl.');
            }
            // verify required parameter 'trackIds' is not null or undefined
            if (trackIds === null || trackIds === undefined) {
                throw new RequiredError('trackIds','Required parameter trackIds was null or undefined when calling getProgressiveUrl.');
            }
            const localVarPath = `/singer/names/{name}/songs/progressive-url`
                .replace(`{${"가수 이름"}}`, encodeURIComponent(String(u)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (trackIds) {
                localVarQueryParameter['trackIds'] = trackIds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackListBySingerName: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getTrackListBySingerName.');
            }
            const localVarPath = `/singer/names/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SingerControllerApi - functional programming interface
 * @export
 */
export const SingerControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRegisteredSingerName(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOListSinger>> {
            const localVarAxiosArgs = await SingerControllerApiAxiosParamCreator(configuration).getAllRegisteredSingerName(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSingerName(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOSetString>> {
            const localVarAxiosArgs = await SingerControllerApiAxiosParamCreator(configuration).getAllSingerName(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} singerName 
         * @param {number} page 
         * @param {number} size 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSongsBySingerName(singerName: string, page: number, size: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOPageSongResponse>> {
            const localVarAxiosArgs = await SingerControllerApiAxiosParamCreator(configuration).getAllSongsBySingerName(singerName, page, size, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllStandardSingerList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOListSinger>> {
            const localVarAxiosArgs = await SingerControllerApiAxiosParamCreator(configuration).getAllStandardSingerList(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 각 trackId에 해당하는 progressive url을 내려준다.
         * @summary progressive url 반환해주는 API
         * @param {string} u 
         * @param {Array<number>} trackIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgressiveUrl(u: string, trackIds: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseBodyWrapperListString>> {
            const localVarAxiosArgs = await SingerControllerApiAxiosParamCreator(configuration).getProgressiveUrl(u, trackIds, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrackListBySingerName(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Track>>> {
            const localVarAxiosArgs = await SingerControllerApiAxiosParamCreator(configuration).getTrackListBySingerName(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SingerControllerApi - factory interface
 * @export
 */
export const SingerControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRegisteredSingerName(options?: any): AxiosPromise<ResponseDTOListSinger> {
            return SingerControllerApiFp(configuration).getAllRegisteredSingerName(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSingerName(options?: any): AxiosPromise<ResponseDTOSetString> {
            return SingerControllerApiFp(configuration).getAllSingerName(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} singerName 
         * @param {number} page 
         * @param {number} size 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSongsBySingerName(singerName: string, page: number, size: number, options?: any): AxiosPromise<ResponseDTOPageSongResponse> {
            return SingerControllerApiFp(configuration).getAllSongsBySingerName(singerName, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllStandardSingerList(options?: any): AxiosPromise<ResponseDTOListSinger> {
            return SingerControllerApiFp(configuration).getAllStandardSingerList(options).then((request) => request(axios, basePath));
        },
        /**
         * 각 trackId에 해당하는 progressive url을 내려준다.
         * @summary progressive url 반환해주는 API
         * @param {string} u 
         * @param {Array<number>} trackIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgressiveUrl(u: string, trackIds: Array<number>, options?: any): AxiosPromise<ResponseBodyWrapperListString> {
            return SingerControllerApiFp(configuration).getProgressiveUrl(u, trackIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackListBySingerName(name: string, options?: any): AxiosPromise<Array<Track>> {
            return SingerControllerApiFp(configuration).getTrackListBySingerName(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SingerControllerApi - object-oriented interface
 * @export
 * @class SingerControllerApi
 * @extends {BaseAPI}
 */
export class SingerControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingerControllerApi
     */
    public getAllRegisteredSingerName(options?: any) {
        return SingerControllerApiFp(this.configuration).getAllRegisteredSingerName(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingerControllerApi
     */
    public getAllSingerName(options?: any) {
        return SingerControllerApiFp(this.configuration).getAllSingerName(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} singerName 
     * @param {number} page 
     * @param {number} size 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingerControllerApi
     */
    public getAllSongsBySingerName(singerName: string, page: number, size: number, options?: any) {
        return SingerControllerApiFp(this.configuration).getAllSongsBySingerName(singerName, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingerControllerApi
     */
    public getAllStandardSingerList(options?: any) {
        return SingerControllerApiFp(this.configuration).getAllStandardSingerList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 각 trackId에 해당하는 progressive url을 내려준다.
     * @summary progressive url 반환해주는 API
     * @param {string} u 
     * @param {Array<number>} trackIds 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingerControllerApi
     */
    public getProgressiveUrl(u: string, trackIds: Array<number>, options?: any) {
        return SingerControllerApiFp(this.configuration).getProgressiveUrl(u, trackIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingerControllerApi
     */
    public getTrackListBySingerName(name: string, options?: any) {
        return SingerControllerApiFp(this.configuration).getTrackListBySingerName(name, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SongControllerApi - axios parameter creator
 * @export
 */
export const SongControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SongRegisterRequest} songRegisterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewSong: async (songRegisterRequest: SongRegisterRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'songRegisterRequest' is not null or undefined
            if (songRegisterRequest === null || songRegisterRequest === undefined) {
                throw new RequiredError('songRegisterRequest','Required parameter songRegisterRequest was null or undefined when calling addNewSong.');
            }
            const localVarPath = `/song/new`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof songRegisterRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(songRegisterRequest !== undefined ? songRegisterRequest : {}) : (songRegisterRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} trackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSong: async (trackId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackId' is not null or undefined
            if (trackId === null || trackId === undefined) {
                throw new RequiredError('trackId','Required parameter trackId was null or undefined when calling getSong.');
            }
            const localVarPath = `/song/{trackId}`
                .replace(`{${"trackId"}}`, encodeURIComponent(String(trackId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongControllerApi - functional programming interface
 * @export
 */
export const SongControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SongRegisterRequest} songRegisterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNewSong(songRegisterRequest: SongRegisterRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOSong>> {
            const localVarAxiosArgs = await SongControllerApiAxiosParamCreator(configuration).addNewSong(songRegisterRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} trackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSong(trackId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOSong>> {
            const localVarAxiosArgs = await SongControllerApiAxiosParamCreator(configuration).getSong(trackId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SongControllerApi - factory interface
 * @export
 */
export const SongControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {SongRegisterRequest} songRegisterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewSong(songRegisterRequest: SongRegisterRequest, options?: any): AxiosPromise<ResponseDTOSong> {
            return SongControllerApiFp(configuration).addNewSong(songRegisterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} trackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSong(trackId: number, options?: any): AxiosPromise<ResponseDTOSong> {
            return SongControllerApiFp(configuration).getSong(trackId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongControllerApi - object-oriented interface
 * @export
 * @class SongControllerApi
 * @extends {BaseAPI}
 */
export class SongControllerApi extends BaseAPI {
    /**
     * 
     * @param {SongRegisterRequest} songRegisterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongControllerApi
     */
    public addNewSong(songRegisterRequest: SongRegisterRequest, options?: any) {
        return SongControllerApiFp(this.configuration).addNewSong(songRegisterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} trackId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongControllerApi
     */
    public getSong(trackId: number, options?: any) {
        return SongControllerApiFp(this.configuration).getSong(trackId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SongHighlightControllerApi - axios parameter creator
 * @export
 */
export const SongHighlightControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SongHighlightAddRequest} songHighlightAddRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSongHighlight: async (songHighlightAddRequest: SongHighlightAddRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'songHighlightAddRequest' is not null or undefined
            if (songHighlightAddRequest === null || songHighlightAddRequest === undefined) {
                throw new RequiredError('songHighlightAddRequest','Required parameter songHighlightAddRequest was null or undefined when calling addSongHighlight.');
            }
            const localVarPath = `/highlight/new`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof songHighlightAddRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(songHighlightAddRequest !== undefined ? songHighlightAddRequest : {}) : (songHighlightAddRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} trackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeHighlight: async (trackId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackId' is not null or undefined
            if (trackId === null || trackId === undefined) {
                throw new RequiredError('trackId','Required parameter trackId was null or undefined when calling makeHighlight.');
            }
            const localVarPath = `/highlight/{trackId}`
                .replace(`{${"trackId"}}`, encodeURIComponent(String(trackId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongHighlightControllerApi - functional programming interface
 * @export
 */
export const SongHighlightControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SongHighlightAddRequest} songHighlightAddRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSongHighlight(songHighlightAddRequest: SongHighlightAddRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOSong>> {
            const localVarAxiosArgs = await SongHighlightControllerApiAxiosParamCreator(configuration).addSongHighlight(songHighlightAddRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} trackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async makeHighlight(trackId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOSong>> {
            const localVarAxiosArgs = await SongHighlightControllerApiAxiosParamCreator(configuration).makeHighlight(trackId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SongHighlightControllerApi - factory interface
 * @export
 */
export const SongHighlightControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {SongHighlightAddRequest} songHighlightAddRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSongHighlight(songHighlightAddRequest: SongHighlightAddRequest, options?: any): AxiosPromise<ResponseDTOSong> {
            return SongHighlightControllerApiFp(configuration).addSongHighlight(songHighlightAddRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} trackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeHighlight(trackId: number, options?: any): AxiosPromise<ResponseDTOSong> {
            return SongHighlightControllerApiFp(configuration).makeHighlight(trackId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongHighlightControllerApi - object-oriented interface
 * @export
 * @class SongHighlightControllerApi
 * @extends {BaseAPI}
 */
export class SongHighlightControllerApi extends BaseAPI {
    /**
     * 
     * @param {SongHighlightAddRequest} songHighlightAddRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongHighlightControllerApi
     */
    public addSongHighlight(songHighlightAddRequest: SongHighlightAddRequest, options?: any) {
        return SongHighlightControllerApiFp(this.configuration).addSongHighlight(songHighlightAddRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} trackId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongHighlightControllerApi
     */
    public makeHighlight(trackId: number, options?: any) {
        return SongHighlightControllerApiFp(this.configuration).makeHighlight(trackId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * VersioningControllerApi - axios parameter creator
 * @export
 */
export const VersioningControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} os 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isNeedForceUpdate: async (os: string, version: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'os' is not null or undefined
            if (os === null || os === undefined) {
                throw new RequiredError('os','Required parameter os was null or undefined when calling isNeedForceUpdate.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling isNeedForceUpdate.');
            }
            const localVarPath = `/versioning/os/{os}/version/{version}`
                .replace(`{${"os"}}`, encodeURIComponent(String(os)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersioningControllerApi - functional programming interface
 * @export
 */
export const VersioningControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} os 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isNeedForceUpdate(os: string, version: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOBoolean>> {
            const localVarAxiosArgs = await VersioningControllerApiAxiosParamCreator(configuration).isNeedForceUpdate(os, version, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VersioningControllerApi - factory interface
 * @export
 */
export const VersioningControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} os 
         * @param {string} version 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isNeedForceUpdate(os: string, version: string, options?: any): AxiosPromise<ResponseDTOBoolean> {
            return VersioningControllerApiFp(configuration).isNeedForceUpdate(os, version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersioningControllerApi - object-oriented interface
 * @export
 * @class VersioningControllerApi
 * @extends {BaseAPI}
 */
export class VersioningControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} os 
     * @param {string} version 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersioningControllerApi
     */
    public isNeedForceUpdate(os: string, version: string, options?: any) {
        return VersioningControllerApiFp(this.configuration).isNeedForceUpdate(os, version, options).then((request) => request(this.axios, this.basePath));
    }

}


