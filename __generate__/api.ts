/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Api Documentation
 * Api Documentation
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://34.84.5.51:8888".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration?: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name!: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface GameAnswer
 */
export interface GameAnswer {
    /**
     * 
     * @type {string}
     * @memberof GameAnswer
     */
    answer?: string;
    /**
     * 
     * @type {number}
     * @memberof GameAnswer
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface GamePlayHighlightDTO
 */
export interface GamePlayHighlightDTO {
    /**
     * 
     * @type {string}
     * @memberof GamePlayHighlightDTO
     */
    artworkUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof GamePlayHighlightDTO
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof GamePlayHighlightDTO
     */
    millisecond?: number;
    /**
     * 
     * @type {string}
     * @memberof GamePlayHighlightDTO
     */
    singer?: string;
    /**
     * 
     * @type {string}
     * @memberof GamePlayHighlightDTO
     */
    title?: string;
    /**
     * 
     * @type {number}
     * @memberof GamePlayHighlightDTO
     */
    trackId?: number;
}

/**
 * 
 * @export
 * @interface GameResultRequest
 */
export interface GameResultRequest {
    /**
     * 
     * @type {Array<GameAnswer>}
     * @memberof GameResultRequest
     */
    gameAnswerList?: Array<GameAnswer>;
    /**
     * 
     * @type {string}
     * @memberof GameResultRequest
     */
    playToken?: string;
}

/**
 * 
 * @export
 * @interface GameResultResponse
 */
export interface GameResultResponse {
    /**
     * 
     * @type {number}
     * @memberof GameResultResponse
     */
    gainPointOfThisGame?: number;
    /**
     * 
     * @type {number}
     * @memberof GameResultResponse
     */
    heartCount?: number;
    /**
     * 
     * @type {number}
     * @memberof GameResultResponse
     */
    totalPoint?: number;
}

/**
 * 
 * @export
 * @interface GameStartRequest
 */
export interface GameStartRequest {
    /**
     * 
     * @type {number}
     * @memberof GameStartRequest
     */
    numOfHighlightPerGame?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof GameStartRequest
     */
    singerList?: Array<string>;
}

/**
 * 
 * @export
 * @interface GameStartResponse
 */
export interface GameStartResponse {
    /**
     * 
     * @type {Array<GamePlayHighlightDTO>}
     * @memberof GameStartResponse
     */
    playHighlightList?: Array<GamePlayHighlightDTO>;
    /**
     * 
     * @type {string}
     * @memberof GameStartResponse
     */
    playToken?: string;
}

/**
 * 
 * @export
 * @interface HeartResponse
 */
export interface HeartResponse {
    /**
     * 
     * @type {number}
     * @memberof HeartResponse
     */
    heartCount?: number;
    /**
     * 
     * @type {number}
     * @memberof HeartResponse
     */
    leftTime?: number;
}

/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    itemType?: Item.ItemTypeEnum;
}

/**
 * @export
 * @namespace Item
 */
export namespace Item {
    /**
     * @export
     * @enum {string}
     */
    export enum ItemTypeEnum {
        SKIP = <any> 'SKIP',
        CHARGEALLHEART = <any> 'CHARGE_ALL_HEART'
    }
}

/**
 * 
 * @export
 * @interface Like
 */
export interface Like {
    /**
     * 
     * @type {number}
     * @memberof Like
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof Like
     */
    id?: number;
    /**
     * 
     * @type {Song}
     * @memberof Like
     */
    song?: Song;
}

/**
 * 
 * @export
 * @interface LikeHistoryResponse
 */
export interface LikeHistoryResponse {
    /**
     * 
     * @type {string}
     * @memberof LikeHistoryResponse
     */
    artworkUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof LikeHistoryResponse
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof LikeHistoryResponse
     */
    singer?: string;
    /**
     * 
     * @type {string}
     * @memberof LikeHistoryResponse
     */
    title?: string;
    /**
     * 
     * @type {number}
     * @memberof LikeHistoryResponse
     */
    trackId?: number;
}

/**
 * 
 * @export
 * @interface LikeRequest
 */
export interface LikeRequest {
    /**
     * 
     * @type {string}
     * @memberof LikeRequest
     */
    singerName?: string;
    /**
     * 
     * @type {string}
     * @memberof LikeRequest
     */
    songUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof LikeRequest
     */
    trackId?: number;
}

/**
 * 
 * @export
 * @interface LikeResponse
 */
export interface LikeResponse {
    /**
     * 
     * @type {number}
     * @memberof LikeResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof LikeResponse
     */
    trackId?: number;
}

/**
 * 
 * @export
 * @interface LoggedInMusicUser
 */
export interface LoggedInMusicUser {
    /**
     * 
     * @type {number}
     * @memberof LoggedInMusicUser
     */
    accessTime?: number;
    /**
     * 
     * @type {string}
     * @memberof LoggedInMusicUser
     */
    nickname?: string;
    /**
     * 
     * @type {string}
     * @memberof LoggedInMusicUser
     */
    profileDp?: string;
    /**
     * 
     * @type {string}
     * @memberof LoggedInMusicUser
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface ModelAndView
 */
export interface ModelAndView {
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    empty?: boolean;
    /**
     * 
     * @type {any}
     * @memberof ModelAndView
     */
    model?: any;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ModelAndView
     */
    modelMap?: { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof ModelAndView
     */
    reference?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    status?: ModelAndView.StatusEnum;
    /**
     * 
     * @type {View}
     * @memberof ModelAndView
     */
    view?: View;
    /**
     * 
     * @type {string}
     * @memberof ModelAndView
     */
    viewName?: string;
}

/**
 * @export
 * @namespace ModelAndView
 */
export namespace ModelAndView {
    /**
     * @export
     * @enum {string}
     */
    export enum StatusEnum {
        _100CONTINUE = <any> '100 CONTINUE',
        _101SWITCHINGPROTOCOLS = <any> '101 SWITCHING_PROTOCOLS',
        _102PROCESSING = <any> '102 PROCESSING',
        _103CHECKPOINT = <any> '103 CHECKPOINT',
        _200OK = <any> '200 OK',
        _201CREATED = <any> '201 CREATED',
        _202ACCEPTED = <any> '202 ACCEPTED',
        _203NONAUTHORITATIVEINFORMATION = <any> '203 NON_AUTHORITATIVE_INFORMATION',
        _204NOCONTENT = <any> '204 NO_CONTENT',
        _205RESETCONTENT = <any> '205 RESET_CONTENT',
        _206PARTIALCONTENT = <any> '206 PARTIAL_CONTENT',
        _207MULTISTATUS = <any> '207 MULTI_STATUS',
        _208ALREADYREPORTED = <any> '208 ALREADY_REPORTED',
        _226IMUSED = <any> '226 IM_USED',
        _300MULTIPLECHOICES = <any> '300 MULTIPLE_CHOICES',
        _301MOVEDPERMANENTLY = <any> '301 MOVED_PERMANENTLY',
        _302FOUND = <any> '302 FOUND',
        _302MOVEDTEMPORARILY = <any> '302 MOVED_TEMPORARILY',
        _303SEEOTHER = <any> '303 SEE_OTHER',
        _304NOTMODIFIED = <any> '304 NOT_MODIFIED',
        _305USEPROXY = <any> '305 USE_PROXY',
        _307TEMPORARYREDIRECT = <any> '307 TEMPORARY_REDIRECT',
        _308PERMANENTREDIRECT = <any> '308 PERMANENT_REDIRECT',
        _400BADREQUEST = <any> '400 BAD_REQUEST',
        _401UNAUTHORIZED = <any> '401 UNAUTHORIZED',
        _402PAYMENTREQUIRED = <any> '402 PAYMENT_REQUIRED',
        _403FORBIDDEN = <any> '403 FORBIDDEN',
        _404NOTFOUND = <any> '404 NOT_FOUND',
        _405METHODNOTALLOWED = <any> '405 METHOD_NOT_ALLOWED',
        _406NOTACCEPTABLE = <any> '406 NOT_ACCEPTABLE',
        _407PROXYAUTHENTICATIONREQUIRED = <any> '407 PROXY_AUTHENTICATION_REQUIRED',
        _408REQUESTTIMEOUT = <any> '408 REQUEST_TIMEOUT',
        _409CONFLICT = <any> '409 CONFLICT',
        _410GONE = <any> '410 GONE',
        _411LENGTHREQUIRED = <any> '411 LENGTH_REQUIRED',
        _412PRECONDITIONFAILED = <any> '412 PRECONDITION_FAILED',
        _413PAYLOADTOOLARGE = <any> '413 PAYLOAD_TOO_LARGE',
        _413REQUESTENTITYTOOLARGE = <any> '413 REQUEST_ENTITY_TOO_LARGE',
        _414URITOOLONG = <any> '414 URI_TOO_LONG',
        _414REQUESTURITOOLONG = <any> '414 REQUEST_URI_TOO_LONG',
        _415UNSUPPORTEDMEDIATYPE = <any> '415 UNSUPPORTED_MEDIA_TYPE',
        _416REQUESTEDRANGENOTSATISFIABLE = <any> '416 REQUESTED_RANGE_NOT_SATISFIABLE',
        _417EXPECTATIONFAILED = <any> '417 EXPECTATION_FAILED',
        _418IAMATEAPOT = <any> '418 I_AM_A_TEAPOT',
        _419INSUFFICIENTSPACEONRESOURCE = <any> '419 INSUFFICIENT_SPACE_ON_RESOURCE',
        _420METHODFAILURE = <any> '420 METHOD_FAILURE',
        _421DESTINATIONLOCKED = <any> '421 DESTINATION_LOCKED',
        _422UNPROCESSABLEENTITY = <any> '422 UNPROCESSABLE_ENTITY',
        _423LOCKED = <any> '423 LOCKED',
        _424FAILEDDEPENDENCY = <any> '424 FAILED_DEPENDENCY',
        _425TOOEARLY = <any> '425 TOO_EARLY',
        _426UPGRADEREQUIRED = <any> '426 UPGRADE_REQUIRED',
        _428PRECONDITIONREQUIRED = <any> '428 PRECONDITION_REQUIRED',
        _429TOOMANYREQUESTS = <any> '429 TOO_MANY_REQUESTS',
        _431REQUESTHEADERFIELDSTOOLARGE = <any> '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
        _451UNAVAILABLEFORLEGALREASONS = <any> '451 UNAVAILABLE_FOR_LEGAL_REASONS',
        _500INTERNALSERVERERROR = <any> '500 INTERNAL_SERVER_ERROR',
        _501NOTIMPLEMENTED = <any> '501 NOT_IMPLEMENTED',
        _502BADGATEWAY = <any> '502 BAD_GATEWAY',
        _503SERVICEUNAVAILABLE = <any> '503 SERVICE_UNAVAILABLE',
        _504GATEWAYTIMEOUT = <any> '504 GATEWAY_TIMEOUT',
        _505HTTPVERSIONNOTSUPPORTED = <any> '505 HTTP_VERSION_NOT_SUPPORTED',
        _506VARIANTALSONEGOTIATES = <any> '506 VARIANT_ALSO_NEGOTIATES',
        _507INSUFFICIENTSTORAGE = <any> '507 INSUFFICIENT_STORAGE',
        _508LOOPDETECTED = <any> '508 LOOP_DETECTED',
        _509BANDWIDTHLIMITEXCEEDED = <any> '509 BANDWIDTH_LIMIT_EXCEEDED',
        _510NOTEXTENDED = <any> '510 NOT_EXTENDED',
        _511NETWORKAUTHENTICATIONREQUIRED = <any> '511 NETWORK_AUTHENTICATION_REQUIRED'
    }
}

/**
 * 
 * @export
 * @interface MusicUser
 */
export interface MusicUser {
    /**
     * 
     * @type {number}
     * @memberof MusicUser
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof MusicUser
     */
    nickname?: string;
    /**
     * 
     * @type {string}
     * @memberof MusicUser
     */
    profileDisplayPhotoFileName?: string;
    /**
     * 
     * @type {string}
     * @memberof MusicUser
     */
    socialType?: string;
}

/**
 * 
 * @export
 * @interface NicknameChangeRequest
 */
export interface NicknameChangeRequest {
    /**
     * 
     * @type {string}
     * @memberof NicknameChangeRequest
     */
    newNickname?: string;
}

/**
 * 
 * @export
 * @interface RankView
 */
export interface RankView {
    /**
     * 
     * @type {string}
     * @memberof RankView
     */
    nickname?: string;
    /**
     * 
     * @type {number}
     * @memberof RankView
     */
    point?: number;
    /**
     * 
     * @type {number}
     * @memberof RankView
     */
    rankDiff?: number;
}

/**
 * 
 * @export
 * @interface RankViewModel
 */
export interface RankViewModel {
    /**
     * 
     * @type {Array<RankView>}
     * @memberof RankViewModel
     */
    rankViewList?: Array<RankView>;
    /**
     * 
     * @type {number}
     * @memberof RankViewModel
     */
    time?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTO
 */
export interface ResponseDTO {
    /**
     * 
     * @type {any}
     * @memberof ResponseDTO
     */
    body?: any;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTO
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOGameResultResponse
 */
export interface ResponseDTOGameResultResponse {
    /**
     * 
     * @type {GameResultResponse}
     * @memberof ResponseDTOGameResultResponse
     */
    body?: GameResultResponse;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOGameResultResponse
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOGameStartResponse
 */
export interface ResponseDTOGameStartResponse {
    /**
     * 
     * @type {GameStartResponse}
     * @memberof ResponseDTOGameStartResponse
     */
    body?: GameStartResponse;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOGameStartResponse
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOHeartResponse
 */
export interface ResponseDTOHeartResponse {
    /**
     * 
     * @type {HeartResponse}
     * @memberof ResponseDTOHeartResponse
     */
    body?: HeartResponse;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOHeartResponse
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOLikeResponse
 */
export interface ResponseDTOLikeResponse {
    /**
     * 
     * @type {LikeResponse}
     * @memberof ResponseDTOLikeResponse
     */
    body?: LikeResponse;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOLikeResponse
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOListItem
 */
export interface ResponseDTOListItem {
    /**
     * 
     * @type {Array<Item>}
     * @memberof ResponseDTOListItem
     */
    body?: Array<Item>;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOListItem
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOListLikeHistoryResponse
 */
export interface ResponseDTOListLikeHistoryResponse {
    /**
     * 
     * @type {Array<LikeHistoryResponse>}
     * @memberof ResponseDTOListLikeHistoryResponse
     */
    body?: Array<LikeHistoryResponse>;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOListLikeHistoryResponse
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOListUserLikeHistoryResponse
 */
export interface ResponseDTOListUserLikeHistoryResponse {
    /**
     * 
     * @type {Array<UserLikeHistoryResponse>}
     * @memberof ResponseDTOListUserLikeHistoryResponse
     */
    body?: Array<UserLikeHistoryResponse>;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOListUserLikeHistoryResponse
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOListstring
 */
export interface ResponseDTOListstring {
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseDTOListstring
     */
    body?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOListstring
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOLoggedInMusicUser
 */
export interface ResponseDTOLoggedInMusicUser {
    /**
     * 
     * @type {LoggedInMusicUser}
     * @memberof ResponseDTOLoggedInMusicUser
     */
    body?: LoggedInMusicUser;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOLoggedInMusicUser
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTORankViewModel
 */
export interface ResponseDTORankViewModel {
    /**
     * 
     * @type {RankViewModel}
     * @memberof ResponseDTORankViewModel
     */
    body?: RankViewModel;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTORankViewModel
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOReward
 */
export interface ResponseDTOReward {
    /**
     * 
     * @type {Reward}
     * @memberof ResponseDTOReward
     */
    body?: Reward;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOReward
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOSong
 */
export interface ResponseDTOSong {
    /**
     * 
     * @type {Song}
     * @memberof ResponseDTOSong
     */
    body?: Song;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOSong
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOboolean
 */
export interface ResponseDTOboolean {
    /**
     * 
     * @type {boolean}
     * @memberof ResponseDTOboolean
     */
    body?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOboolean
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOstring
 */
export interface ResponseDTOstring {
    /**
     * 
     * @type {string}
     * @memberof ResponseDTOstring
     */
    body?: string;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOstring
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface Reward
 */
export interface Reward {
    /**
     * 
     * @type {number}
     * @memberof Reward
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Reward
     */
    rewardType?: string;
}

/**
 * 
 * @export
 * @interface Song
 */
export interface Song {
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    artworkUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Song
     */
    exported?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Song
     */
    id?: number;
    /**
     * 
     * @type {Like}
     * @memberof Song
     */
    like?: Like;
    /**
     * 
     * @type {MusicUser}
     * @memberof Song
     */
    musicUser?: MusicUser;
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    singer?: string;
    /**
     * 
     * @type {Array<SongHighlight>}
     * @memberof Song
     */
    songHighlight?: Array<SongHighlight>;
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    title?: string;
    /**
     * 
     * @type {number}
     * @memberof Song
     */
    trackId?: number;
    /**
     * 
     * @type {string}
     * @memberof Song
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface SongHighlight
 */
export interface SongHighlight {
    /**
     * 
     * @type {boolean}
     * @memberof SongHighlight
     */
    elected?: boolean;
    /**
     * 
     * @type {number}
     * @memberof SongHighlight
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof SongHighlight
     */
    millisecond?: number;
    /**
     * 
     * @type {Song}
     * @memberof SongHighlight
     */
    song?: Song;
}

/**
 * 
 * @export
 * @interface SongHighlightAddRequest
 */
export interface SongHighlightAddRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof SongHighlightAddRequest
     */
    highlightSeconds?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof SongHighlightAddRequest
     */
    songId?: number;
}

/**
 * 
 * @export
 * @interface SongRegisterRequest
 */
export interface SongRegisterRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof SongRegisterRequest
     */
    highlightSeconds?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof SongRegisterRequest
     */
    singerName?: string;
    /**
     * 
     * @type {string}
     * @memberof SongRegisterRequest
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface UserLikeHistoryResponse
 */
export interface UserLikeHistoryResponse {
    /**
     * 
     * @type {string}
     * @memberof UserLikeHistoryResponse
     */
    accessId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLikeHistoryResponse
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLikeHistoryResponse
     */
    nickname?: string;
}

/**
 * 
 * @export
 * @interface UserLoginRequest
 */
export interface UserLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof UserLoginRequest
     */
    accessId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginRequest
     */
    accessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginRequest
     */
    refreshToken?: string;
}

/**
 * 
 * @export
 * @interface UserSignUpRequest
 */
export interface UserSignUpRequest {
    /**
     * 
     * @type {string}
     * @memberof UserSignUpRequest
     */
    accessId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSignUpRequest
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSignUpRequest
     */
    invitedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSignUpRequest
     */
    nickname?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSignUpRequest
     */
    socialType?: string;
}

/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {string}
     * @memberof View
     */
    contentType?: string;
}


/**
 * BasicErrorControllerApi - fetch parameter creator
 * @export
 */
export const BasicErrorControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'HEAD' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'OPTIONS' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options: any = {}): FetchArgs {
            const localVarPath = `/error`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BasicErrorControllerApi - functional programming interface
 * @export
 */
export const BasicErrorControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingDELETE(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingHEAD(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingOPTIONS(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingPATCH(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingPOST(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAndView> {
            const localVarFetchArgs = BasicErrorControllerApiFetchParamCreator(configuration).errorHtmlUsingPUT(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BasicErrorControllerApi - factory interface
 * @export
 */
export const BasicErrorControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingDELETE(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingDELETE(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingGET(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingHEAD(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingHEAD(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingOPTIONS(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingOPTIONS(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPATCH(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingPATCH(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPOST(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingPOST(options)(fetch, basePath);
        },
        /**
         * 
         * @summary errorHtml
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        errorHtmlUsingPUT(options?: any) {
            return BasicErrorControllerApiFp(configuration).errorHtmlUsingPUT(options)(fetch, basePath);
        },
    };
};

/**
 * BasicErrorControllerApi - object-oriented interface
 * @export
 * @class BasicErrorControllerApi
 * @extends {BaseAPI}
 */
export class BasicErrorControllerApi extends BaseAPI {
    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingDELETE(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingDELETE(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingGET(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingHEAD(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingHEAD(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingOPTIONS(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingOPTIONS(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPATCH(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPATCH(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPOST(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPOST(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary errorHtml
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasicErrorControllerApi
     */
    public errorHtmlUsingPUT(options?: any) {
        return BasicErrorControllerApiFp(this.configuration).errorHtmlUsingPUT(options)(this.fetch, this.basePath);
    }

}

/**
 * GameControllerApi - fetch parameter creator
 * @export
 */
export const GameControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary gameResult
         * @param {GameResultRequest} resultRequest resultRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameResultUsingPOST(resultRequest: GameResultRequest, options: any = {}): FetchArgs {
            // verify required parameter 'resultRequest' is not null or undefined
            if (resultRequest === null || resultRequest === undefined) {
                throw new RequiredError('resultRequest','Required parameter resultRequest was null or undefined when calling gameResultUsingPOST.');
            }
            const localVarPath = `/game/result`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GameResultRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(resultRequest || {}) : (resultRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getHighlightList
         * @param {GameStartRequest} gameRequest gameRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightListUsingPOST(gameRequest: GameStartRequest, options: any = {}): FetchArgs {
            // verify required parameter 'gameRequest' is not null or undefined
            if (gameRequest === null || gameRequest === undefined) {
                throw new RequiredError('gameRequest','Required parameter gameRequest was null or undefined when calling getHighlightListUsingPOST.');
            }
            const localVarPath = `/game/start`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GameStartRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(gameRequest || {}) : (gameRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GameControllerApi - functional programming interface
 * @export
 */
export const GameControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary gameResult
         * @param {GameResultRequest} resultRequest resultRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameResultUsingPOST(resultRequest: GameResultRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOGameResultResponse> {
            const localVarFetchArgs = GameControllerApiFetchParamCreator(configuration).gameResultUsingPOST(resultRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getHighlightList
         * @param {GameStartRequest} gameRequest gameRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightListUsingPOST(gameRequest: GameStartRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOGameStartResponse> {
            const localVarFetchArgs = GameControllerApiFetchParamCreator(configuration).getHighlightListUsingPOST(gameRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GameControllerApi - factory interface
 * @export
 */
export const GameControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary gameResult
         * @param {GameResultRequest} resultRequest resultRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameResultUsingPOST(resultRequest: GameResultRequest, options?: any) {
            return GameControllerApiFp(configuration).gameResultUsingPOST(resultRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getHighlightList
         * @param {GameStartRequest} gameRequest gameRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightListUsingPOST(gameRequest: GameStartRequest, options?: any) {
            return GameControllerApiFp(configuration).getHighlightListUsingPOST(gameRequest, options)(fetch, basePath);
        },
    };
};

/**
 * GameControllerApi - object-oriented interface
 * @export
 * @class GameControllerApi
 * @extends {BaseAPI}
 */
export class GameControllerApi extends BaseAPI {
    /**
     * 
     * @summary gameResult
     * @param {GameResultRequest} resultRequest resultRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public gameResultUsingPOST(resultRequest: GameResultRequest, options?: any) {
        return GameControllerApiFp(this.configuration).gameResultUsingPOST(resultRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getHighlightList
     * @param {GameStartRequest} gameRequest gameRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public getHighlightListUsingPOST(gameRequest: GameStartRequest, options?: any) {
        return GameControllerApiFp(this.configuration).getHighlightListUsingPOST(gameRequest, options)(this.fetch, this.basePath);
    }

}

/**
 * HealthCheckControllerApi - fetch parameter creator
 * @export
 */
export const HealthCheckControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary healthCheck2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck2UsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/health/check`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/health/test`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthCheckControllerApi - functional programming interface
 * @export
 */
export const HealthCheckControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary healthCheck2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck2UsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = HealthCheckControllerApiFetchParamCreator(configuration).healthCheck2UsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = HealthCheckControllerApiFetchParamCreator(configuration).testUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HealthCheckControllerApi - factory interface
 * @export
 */
export const HealthCheckControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary healthCheck2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck2UsingGET(options?: any) {
            return HealthCheckControllerApiFp(configuration).healthCheck2UsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testUsingGET(options?: any) {
            return HealthCheckControllerApiFp(configuration).testUsingGET(options)(fetch, basePath);
        },
    };
};

/**
 * HealthCheckControllerApi - object-oriented interface
 * @export
 * @class HealthCheckControllerApi
 * @extends {BaseAPI}
 */
export class HealthCheckControllerApi extends BaseAPI {
    /**
     * 
     * @summary healthCheck2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckControllerApi
     */
    public healthCheck2UsingGET(options?: any) {
        return HealthCheckControllerApiFp(this.configuration).healthCheck2UsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckControllerApi
     */
    public testUsingGET(options?: any) {
        return HealthCheckControllerApiFp(this.configuration).testUsingGET(options)(this.fetch, this.basePath);
    }

}

/**
 * HeartControllerApi - fetch parameter creator
 * @export
 */
export const HeartControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary checkMyHeart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkMyHeartUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/heart/check`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary useHeart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useHeartUsingPUT(options: any = {}): FetchArgs {
            const localVarPath = `/heart/use`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HeartControllerApi - functional programming interface
 * @export
 */
export const HeartControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary checkMyHeart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkMyHeartUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOHeartResponse> {
            const localVarFetchArgs = HeartControllerApiFetchParamCreator(configuration).checkMyHeartUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary useHeart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useHeartUsingPUT(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOHeartResponse> {
            const localVarFetchArgs = HeartControllerApiFetchParamCreator(configuration).useHeartUsingPUT(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HeartControllerApi - factory interface
 * @export
 */
export const HeartControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary checkMyHeart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkMyHeartUsingGET(options?: any) {
            return HeartControllerApiFp(configuration).checkMyHeartUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary useHeart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useHeartUsingPUT(options?: any) {
            return HeartControllerApiFp(configuration).useHeartUsingPUT(options)(fetch, basePath);
        },
    };
};

/**
 * HeartControllerApi - object-oriented interface
 * @export
 * @class HeartControllerApi
 * @extends {BaseAPI}
 */
export class HeartControllerApi extends BaseAPI {
    /**
     * 
     * @summary checkMyHeart
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartControllerApi
     */
    public checkMyHeartUsingGET(options?: any) {
        return HeartControllerApiFp(this.configuration).checkMyHeartUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary useHeart
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartControllerApi
     */
    public useHeartUsingPUT(options?: any) {
        return HeartControllerApiFp(this.configuration).useHeartUsingPUT(options)(this.fetch, this.basePath);
    }

}

/**
 * ItemControllerApi - fetch parameter creator
 * @export
 */
export const ItemControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary findItemAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findItemAllUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/item/all`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *   SKIP, CHARGE_ALL_HEART . 
         * @summary   
         * @param {string} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useItemUsingPUT(type: string, options: any = {}): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling useItemUsingPUT.');
            }
            const localVarPath = `/item/use/types/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemControllerApi - functional programming interface
 * @export
 */
export const ItemControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary findItemAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findItemAllUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOListItem> {
            const localVarFetchArgs = ItemControllerApiFetchParamCreator(configuration).findItemAllUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         *   SKIP, CHARGE_ALL_HEART . 
         * @summary   
         * @param {string} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useItemUsingPUT(type: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTO> {
            const localVarFetchArgs = ItemControllerApiFetchParamCreator(configuration).useItemUsingPUT(type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ItemControllerApi - factory interface
 * @export
 */
export const ItemControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary findItemAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findItemAllUsingGET(options?: any) {
            return ItemControllerApiFp(configuration).findItemAllUsingGET(options)(fetch, basePath);
        },
        /**
         *   SKIP, CHARGE_ALL_HEART . 
         * @summary   
         * @param {string} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useItemUsingPUT(type: string, options?: any) {
            return ItemControllerApiFp(configuration).useItemUsingPUT(type, options)(fetch, basePath);
        },
    };
};

/**
 * ItemControllerApi - object-oriented interface
 * @export
 * @class ItemControllerApi
 * @extends {BaseAPI}
 */
export class ItemControllerApi extends BaseAPI {
    /**
     * 
     * @summary findItemAll
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemControllerApi
     */
    public findItemAllUsingGET(options?: any) {
        return ItemControllerApiFp(this.configuration).findItemAllUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     *   SKIP, CHARGE_ALL_HEART . 
     * @summary   
     * @param {string} type type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemControllerApi
     */
    public useItemUsingPUT(type: string, options?: any) {
        return ItemControllerApiFp(this.configuration).useItemUsingPUT(type, options)(this.fetch, this.basePath);
    }

}

/**
 * LikeControllerApi - fetch parameter creator
 * @export
 */
export const LikeControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary dislike
         * @param {LikeRequest} likeRequest likeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dislikeUsingPOST(likeRequest: LikeRequest, options: any = {}): FetchArgs {
            // verify required parameter 'likeRequest' is not null or undefined
            if (likeRequest === null || likeRequest === undefined) {
                throw new RequiredError('likeRequest','Required parameter likeRequest was null or undefined when calling dislikeUsingPOST.');
            }
            const localVarPath = `/dislike`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LikeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(likeRequest || {}) : (likeRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary like
         * @param {LikeRequest} likeRequest likeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeUsingPOST(likeRequest: LikeRequest, options: any = {}): FetchArgs {
            // verify required parameter 'likeRequest' is not null or undefined
            if (likeRequest === null || likeRequest === undefined) {
                throw new RequiredError('likeRequest','Required parameter likeRequest was null or undefined when calling likeUsingPOST.');
            }
            const localVarPath = `/like`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LikeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(likeRequest || {}) : (likeRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LikeControllerApi - functional programming interface
 * @export
 */
export const LikeControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary dislike
         * @param {LikeRequest} likeRequest likeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dislikeUsingPOST(likeRequest: LikeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOLikeResponse> {
            const localVarFetchArgs = LikeControllerApiFetchParamCreator(configuration).dislikeUsingPOST(likeRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary like
         * @param {LikeRequest} likeRequest likeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeUsingPOST(likeRequest: LikeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOLikeResponse> {
            const localVarFetchArgs = LikeControllerApiFetchParamCreator(configuration).likeUsingPOST(likeRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LikeControllerApi - factory interface
 * @export
 */
export const LikeControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary dislike
         * @param {LikeRequest} likeRequest likeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dislikeUsingPOST(likeRequest: LikeRequest, options?: any) {
            return LikeControllerApiFp(configuration).dislikeUsingPOST(likeRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary like
         * @param {LikeRequest} likeRequest likeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeUsingPOST(likeRequest: LikeRequest, options?: any) {
            return LikeControllerApiFp(configuration).likeUsingPOST(likeRequest, options)(fetch, basePath);
        },
    };
};

/**
 * LikeControllerApi - object-oriented interface
 * @export
 * @class LikeControllerApi
 * @extends {BaseAPI}
 */
export class LikeControllerApi extends BaseAPI {
    /**
     * 
     * @summary dislike
     * @param {LikeRequest} likeRequest likeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeControllerApi
     */
    public dislikeUsingPOST(likeRequest: LikeRequest, options?: any) {
        return LikeControllerApiFp(this.configuration).dislikeUsingPOST(likeRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary like
     * @param {LikeRequest} likeRequest likeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeControllerApi
     */
    public likeUsingPOST(likeRequest: LikeRequest, options?: any) {
        return LikeControllerApiFp(this.configuration).likeUsingPOST(likeRequest, options)(this.fetch, this.basePath);
    }

}

/**
 * LikeHistoryControllerApi - fetch parameter creator
 * @export
 */
export const LikeHistoryControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getLikeHistory
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikeHistoryUsingGET(trackId: number, options: any = {}): FetchArgs {
            // verify required parameter 'trackId' is not null or undefined
            if (trackId === null || trackId === undefined) {
                throw new RequiredError('trackId','Required parameter trackId was null or undefined when calling getLikeHistoryUsingGET.');
            }
            const localVarPath = `/history/like/song/{trackId}`
                .replace(`{${"trackId"}}`, encodeURIComponent(String(trackId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserHistory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHistoryUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/history/like/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LikeHistoryControllerApi - functional programming interface
 * @export
 */
export const LikeHistoryControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getLikeHistory
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikeHistoryUsingGET(trackId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOListUserLikeHistoryResponse> {
            const localVarFetchArgs = LikeHistoryControllerApiFetchParamCreator(configuration).getLikeHistoryUsingGET(trackId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserHistory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHistoryUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOListLikeHistoryResponse> {
            const localVarFetchArgs = LikeHistoryControllerApiFetchParamCreator(configuration).getUserHistoryUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LikeHistoryControllerApi - factory interface
 * @export
 */
export const LikeHistoryControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getLikeHistory
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikeHistoryUsingGET(trackId: number, options?: any) {
            return LikeHistoryControllerApiFp(configuration).getLikeHistoryUsingGET(trackId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserHistory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHistoryUsingGET(options?: any) {
            return LikeHistoryControllerApiFp(configuration).getUserHistoryUsingGET(options)(fetch, basePath);
        },
    };
};

/**
 * LikeHistoryControllerApi - object-oriented interface
 * @export
 * @class LikeHistoryControllerApi
 * @extends {BaseAPI}
 */
export class LikeHistoryControllerApi extends BaseAPI {
    /**
     * 
     * @summary getLikeHistory
     * @param {number} trackId trackId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeHistoryControllerApi
     */
    public getLikeHistoryUsingGET(trackId: number, options?: any) {
        return LikeHistoryControllerApiFp(this.configuration).getLikeHistoryUsingGET(trackId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserHistory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeHistoryControllerApi
     */
    public getUserHistoryUsingGET(options?: any) {
        return LikeHistoryControllerApiFp(this.configuration).getUserHistoryUsingGET(options)(this.fetch, this.basePath);
    }

}

/**
 * MusicUserControllerApi - fetch parameter creator
 * @export
 */
export const MusicUserControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary myInfoChange
         * @param {any} profileImage profileImage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInfoChangeUsingPOST(profileImage: any, options: any = {}): FetchArgs {
            // verify required parameter 'profileImage' is not null or undefined
            if (profileImage === null || profileImage === undefined) {
                throw new RequiredError('profileImage','Required parameter profileImage was null or undefined when calling myInfoChangeUsingPOST.');
            }
            const localVarPath = `/user/profile/dp`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (profileImage !== undefined) {
                localVarFormParams.set('profileImage', profileImage as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary myInfoChange
         * @param {NicknameChangeRequest} nicknameChangeRequest nicknameChangeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInfoChangeUsingPUT(nicknameChangeRequest: NicknameChangeRequest, options: any = {}): FetchArgs {
            // verify required parameter 'nicknameChangeRequest' is not null or undefined
            if (nicknameChangeRequest === null || nicknameChangeRequest === undefined) {
                throw new RequiredError('nicknameChangeRequest','Required parameter nicknameChangeRequest was null or undefined when calling myInfoChangeUsingPUT.');
            }
            const localVarPath = `/user/profile/nickname`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NicknameChangeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(nicknameChangeRequest || {}) : (nicknameChangeRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary refreshToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenUsingPOST(options: any = {}): FetchArgs {
            const localVarPath = `/user/login/refresh`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary secedeSelf
         * @param {string} password password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secedeSelfUsingDELETE(password: string, options: any = {}): FetchArgs {
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling secedeSelfUsingDELETE.');
            }
            const localVarPath = `/user/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(password || {}) : (password || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary signIn
         * @param {UserLoginRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInUsingPOST(request: UserLoginRequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling signInUsingPOST.');
            }
            const localVarPath = `/user/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserLoginRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary signUp
         * @param {UserSignUpRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpUsingPOST(request: UserSignUpRequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling signUpUsingPOST.');
            }
            const localVarPath = `/user/signup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserSignUpRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MusicUserControllerApi - functional programming interface
 * @export
 */
export const MusicUserControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary myInfoChange
         * @param {any} profileImage profileImage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInfoChangeUsingPOST(profileImage: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOstring> {
            const localVarFetchArgs = MusicUserControllerApiFetchParamCreator(configuration).myInfoChangeUsingPOST(profileImage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary myInfoChange
         * @param {NicknameChangeRequest} nicknameChangeRequest nicknameChangeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInfoChangeUsingPUT(nicknameChangeRequest: NicknameChangeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOboolean> {
            const localVarFetchArgs = MusicUserControllerApiFetchParamCreator(configuration).myInfoChangeUsingPUT(nicknameChangeRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary refreshToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenUsingPOST(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOstring> {
            const localVarFetchArgs = MusicUserControllerApiFetchParamCreator(configuration).refreshTokenUsingPOST(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary secedeSelf
         * @param {string} password password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secedeSelfUsingDELETE(password: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOstring> {
            const localVarFetchArgs = MusicUserControllerApiFetchParamCreator(configuration).secedeSelfUsingDELETE(password, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary signIn
         * @param {UserLoginRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInUsingPOST(request: UserLoginRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOLoggedInMusicUser> {
            const localVarFetchArgs = MusicUserControllerApiFetchParamCreator(configuration).signInUsingPOST(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary signUp
         * @param {UserSignUpRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpUsingPOST(request: UserSignUpRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTO> {
            const localVarFetchArgs = MusicUserControllerApiFetchParamCreator(configuration).signUpUsingPOST(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MusicUserControllerApi - factory interface
 * @export
 */
export const MusicUserControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary myInfoChange
         * @param {any} profileImage profileImage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInfoChangeUsingPOST(profileImage: any, options?: any) {
            return MusicUserControllerApiFp(configuration).myInfoChangeUsingPOST(profileImage, options)(fetch, basePath);
        },
        /**
         * 
         * @summary myInfoChange
         * @param {NicknameChangeRequest} nicknameChangeRequest nicknameChangeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInfoChangeUsingPUT(nicknameChangeRequest: NicknameChangeRequest, options?: any) {
            return MusicUserControllerApiFp(configuration).myInfoChangeUsingPUT(nicknameChangeRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary refreshToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenUsingPOST(options?: any) {
            return MusicUserControllerApiFp(configuration).refreshTokenUsingPOST(options)(fetch, basePath);
        },
        /**
         * 
         * @summary secedeSelf
         * @param {string} password password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secedeSelfUsingDELETE(password: string, options?: any) {
            return MusicUserControllerApiFp(configuration).secedeSelfUsingDELETE(password, options)(fetch, basePath);
        },
        /**
         * 
         * @summary signIn
         * @param {UserLoginRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInUsingPOST(request: UserLoginRequest, options?: any) {
            return MusicUserControllerApiFp(configuration).signInUsingPOST(request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary signUp
         * @param {UserSignUpRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpUsingPOST(request: UserSignUpRequest, options?: any) {
            return MusicUserControllerApiFp(configuration).signUpUsingPOST(request, options)(fetch, basePath);
        },
    };
};

/**
 * MusicUserControllerApi - object-oriented interface
 * @export
 * @class MusicUserControllerApi
 * @extends {BaseAPI}
 */
export class MusicUserControllerApi extends BaseAPI {
    /**
     * 
     * @summary myInfoChange
     * @param {any} profileImage profileImage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public myInfoChangeUsingPOST(profileImage: any, options?: any) {
        return MusicUserControllerApiFp(this.configuration).myInfoChangeUsingPOST(profileImage, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary myInfoChange
     * @param {NicknameChangeRequest} nicknameChangeRequest nicknameChangeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public myInfoChangeUsingPUT(nicknameChangeRequest: NicknameChangeRequest, options?: any) {
        return MusicUserControllerApiFp(this.configuration).myInfoChangeUsingPUT(nicknameChangeRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary refreshToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public refreshTokenUsingPOST(options?: any) {
        return MusicUserControllerApiFp(this.configuration).refreshTokenUsingPOST(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary secedeSelf
     * @param {string} password password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public secedeSelfUsingDELETE(password: string, options?: any) {
        return MusicUserControllerApiFp(this.configuration).secedeSelfUsingDELETE(password, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary signIn
     * @param {UserLoginRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public signInUsingPOST(request: UserLoginRequest, options?: any) {
        return MusicUserControllerApiFp(this.configuration).signInUsingPOST(request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary signUp
     * @param {UserSignUpRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public signUpUsingPOST(request: UserSignUpRequest, options?: any) {
        return MusicUserControllerApiFp(this.configuration).signUpUsingPOST(request, options)(this.fetch, this.basePath);
    }

}

/**
 * RankingControllerApi - fetch parameter creator
 * @export
 */
export const RankingControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getRankingInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/rank/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RankingControllerApi - functional programming interface
 * @export
 */
export const RankingControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getRankingInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTORankViewModel> {
            const localVarFetchArgs = RankingControllerApiFetchParamCreator(configuration).getRankingInfoUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RankingControllerApi - factory interface
 * @export
 */
export const RankingControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getRankingInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoUsingGET(options?: any) {
            return RankingControllerApiFp(configuration).getRankingInfoUsingGET(options)(fetch, basePath);
        },
    };
};

/**
 * RankingControllerApi - object-oriented interface
 * @export
 * @class RankingControllerApi
 * @extends {BaseAPI}
 */
export class RankingControllerApi extends BaseAPI {
    /**
     * 
     * @summary getRankingInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankingControllerApi
     */
    public getRankingInfoUsingGET(options?: any) {
        return RankingControllerApiFp(this.configuration).getRankingInfoUsingGET(options)(this.fetch, this.basePath);
    }

}

/**
 * RewardControllerApi - fetch parameter creator
 * @export
 */
export const RewardControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * type   : 'ad_movie',   : 'suggest_music'
         * @summary rewardHeart
         * @param {string} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewardForWatchingAdUsingPOST(type: string, options: any = {}): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling rewardForWatchingAdUsingPOST.');
            }
            const localVarPath = `/reward/types/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RewardControllerApi - functional programming interface
 * @export
 */
export const RewardControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * type   : 'ad_movie',   : 'suggest_music'
         * @summary rewardHeart
         * @param {string} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewardForWatchingAdUsingPOST(type: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOReward> {
            const localVarFetchArgs = RewardControllerApiFetchParamCreator(configuration).rewardForWatchingAdUsingPOST(type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RewardControllerApi - factory interface
 * @export
 */
export const RewardControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * type   : 'ad_movie',   : 'suggest_music'
         * @summary rewardHeart
         * @param {string} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewardForWatchingAdUsingPOST(type: string, options?: any) {
            return RewardControllerApiFp(configuration).rewardForWatchingAdUsingPOST(type, options)(fetch, basePath);
        },
    };
};

/**
 * RewardControllerApi - object-oriented interface
 * @export
 * @class RewardControllerApi
 * @extends {BaseAPI}
 */
export class RewardControllerApi extends BaseAPI {
    /**
     * type   : 'ad_movie',   : 'suggest_music'
     * @summary rewardHeart
     * @param {string} type type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardControllerApi
     */
    public rewardForWatchingAdUsingPOST(type: string, options?: any) {
        return RewardControllerApiFp(this.configuration).rewardForWatchingAdUsingPOST(type, options)(this.fetch, this.basePath);
    }

}

/**
 * SingerControllerApi - fetch parameter creator
 * @export
 */
export const SingerControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAllRegisteredSingerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRegisteredSingerNameUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/singer/registered`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllSingerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSingerNameUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/singer/all`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SingerControllerApi - functional programming interface
 * @export
 */
export const SingerControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAllRegisteredSingerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRegisteredSingerNameUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOListstring> {
            const localVarFetchArgs = SingerControllerApiFetchParamCreator(configuration).getAllRegisteredSingerNameUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAllSingerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSingerNameUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOListstring> {
            const localVarFetchArgs = SingerControllerApiFetchParamCreator(configuration).getAllSingerNameUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SingerControllerApi - factory interface
 * @export
 */
export const SingerControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getAllRegisteredSingerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRegisteredSingerNameUsingGET(options?: any) {
            return SingerControllerApiFp(configuration).getAllRegisteredSingerNameUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAllSingerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSingerNameUsingGET(options?: any) {
            return SingerControllerApiFp(configuration).getAllSingerNameUsingGET(options)(fetch, basePath);
        },
    };
};

/**
 * SingerControllerApi - object-oriented interface
 * @export
 * @class SingerControllerApi
 * @extends {BaseAPI}
 */
export class SingerControllerApi extends BaseAPI {
    /**
     * 
     * @summary getAllRegisteredSingerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingerControllerApi
     */
    public getAllRegisteredSingerNameUsingGET(options?: any) {
        return SingerControllerApiFp(this.configuration).getAllRegisteredSingerNameUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAllSingerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingerControllerApi
     */
    public getAllSingerNameUsingGET(options?: any) {
        return SingerControllerApiFp(this.configuration).getAllSingerNameUsingGET(options)(this.fetch, this.basePath);
    }

}

/**
 * SongControllerApi - fetch parameter creator
 * @export
 */
export const SongControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addNewSong
         * @param {SongRegisterRequest} registerRequest registerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewSongUsingPOST(registerRequest: SongRegisterRequest, options: any = {}): FetchArgs {
            // verify required parameter 'registerRequest' is not null or undefined
            if (registerRequest === null || registerRequest === undefined) {
                throw new RequiredError('registerRequest','Required parameter registerRequest was null or undefined when calling addNewSongUsingPOST.');
            }
            const localVarPath = `/song/new`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SongRegisterRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(registerRequest || {}) : (registerRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getSong
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSongUsingGET(trackId: number, options: any = {}): FetchArgs {
            // verify required parameter 'trackId' is not null or undefined
            if (trackId === null || trackId === undefined) {
                throw new RequiredError('trackId','Required parameter trackId was null or undefined when calling getSongUsingGET.');
            }
            const localVarPath = `/song/{trackId}`
                .replace(`{${"trackId"}}`, encodeURIComponent(String(trackId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongControllerApi - functional programming interface
 * @export
 */
export const SongControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addNewSong
         * @param {SongRegisterRequest} registerRequest registerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewSongUsingPOST(registerRequest: SongRegisterRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOSong> {
            const localVarFetchArgs = SongControllerApiFetchParamCreator(configuration).addNewSongUsingPOST(registerRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getSong
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSongUsingGET(trackId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOSong> {
            const localVarFetchArgs = SongControllerApiFetchParamCreator(configuration).getSongUsingGET(trackId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SongControllerApi - factory interface
 * @export
 */
export const SongControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary addNewSong
         * @param {SongRegisterRequest} registerRequest registerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewSongUsingPOST(registerRequest: SongRegisterRequest, options?: any) {
            return SongControllerApiFp(configuration).addNewSongUsingPOST(registerRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getSong
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSongUsingGET(trackId: number, options?: any) {
            return SongControllerApiFp(configuration).getSongUsingGET(trackId, options)(fetch, basePath);
        },
    };
};

/**
 * SongControllerApi - object-oriented interface
 * @export
 * @class SongControllerApi
 * @extends {BaseAPI}
 */
export class SongControllerApi extends BaseAPI {
    /**
     * 
     * @summary addNewSong
     * @param {SongRegisterRequest} registerRequest registerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongControllerApi
     */
    public addNewSongUsingPOST(registerRequest: SongRegisterRequest, options?: any) {
        return SongControllerApiFp(this.configuration).addNewSongUsingPOST(registerRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getSong
     * @param {number} trackId trackId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongControllerApi
     */
    public getSongUsingGET(trackId: number, options?: any) {
        return SongControllerApiFp(this.configuration).getSongUsingGET(trackId, options)(this.fetch, this.basePath);
    }

}

/**
 * SongHighlightControllerApi - fetch parameter creator
 * @export
 */
export const SongHighlightControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addSongHighlight
         * @param {SongHighlightAddRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSongHighlightUsingPOST(request: SongHighlightAddRequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling addSongHighlightUsingPOST.');
            }
            const localVarPath = `/highlight/new`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SongHighlightAddRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary makeHighlight
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeHighlightUsingPOST(trackId: number, options: any = {}): FetchArgs {
            // verify required parameter 'trackId' is not null or undefined
            if (trackId === null || trackId === undefined) {
                throw new RequiredError('trackId','Required parameter trackId was null or undefined when calling makeHighlightUsingPOST.');
            }
            const localVarPath = `/highlight/{trackId}`
                .replace(`{${"trackId"}}`, encodeURIComponent(String(trackId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongHighlightControllerApi - functional programming interface
 * @export
 */
export const SongHighlightControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addSongHighlight
         * @param {SongHighlightAddRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSongHighlightUsingPOST(request: SongHighlightAddRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOSong> {
            const localVarFetchArgs = SongHighlightControllerApiFetchParamCreator(configuration).addSongHighlightUsingPOST(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary makeHighlight
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeHighlightUsingPOST(trackId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOSong> {
            const localVarFetchArgs = SongHighlightControllerApiFetchParamCreator(configuration).makeHighlightUsingPOST(trackId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SongHighlightControllerApi - factory interface
 * @export
 */
export const SongHighlightControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary addSongHighlight
         * @param {SongHighlightAddRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSongHighlightUsingPOST(request: SongHighlightAddRequest, options?: any) {
            return SongHighlightControllerApiFp(configuration).addSongHighlightUsingPOST(request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary makeHighlight
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeHighlightUsingPOST(trackId: number, options?: any) {
            return SongHighlightControllerApiFp(configuration).makeHighlightUsingPOST(trackId, options)(fetch, basePath);
        },
    };
};

/**
 * SongHighlightControllerApi - object-oriented interface
 * @export
 * @class SongHighlightControllerApi
 * @extends {BaseAPI}
 */
export class SongHighlightControllerApi extends BaseAPI {
    /**
     * 
     * @summary addSongHighlight
     * @param {SongHighlightAddRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongHighlightControllerApi
     */
    public addSongHighlightUsingPOST(request: SongHighlightAddRequest, options?: any) {
        return SongHighlightControllerApiFp(this.configuration).addSongHighlightUsingPOST(request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary makeHighlight
     * @param {number} trackId trackId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongHighlightControllerApi
     */
    public makeHighlightUsingPOST(trackId: number, options?: any) {
        return SongHighlightControllerApiFp(this.configuration).makeHighlightUsingPOST(trackId, options)(this.fetch, this.basePath);
    }

}

