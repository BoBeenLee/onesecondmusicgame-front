/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * 알쏭달쏭 API
 * 알쏠달쏭 API 명세
 *
 * OpenAPI spec version: 0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.alsongdalsong.com".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AbstractScore
 */
export interface AbstractScore {
    /**
     * 
     * @type {number}
     * @memberof AbstractScore
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof AbstractScore
     */
    point?: number;
}

/**
 * 
 * @export
 * @interface AdminRequest
 */
export interface AdminRequest {
    /**
     * 
     * @type {string}
     * @memberof AdminRequest
     */
    setting?: AdminRequest.SettingEnum;
    /**
     * 
     * @type {number}
     * @memberof AdminRequest
     */
    value?: number;
}

/**
 * @export
 * @namespace AdminRequest
 */
export namespace AdminRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum SettingEnum {
        REWARDCOOLDOWNWATCHMOVIEDURATIONMINS = <any> 'REWARD_COOLDOWN_WATCH_MOVIE_DURATION_MINS',
        POINTOFONEGAME = <any> 'POINT_OF_ONE_GAME',
        MAXNUMOFSINGERPERGAME = <any> 'MAX_NUM_OF_SINGER_PER_GAME',
        DEFAULTMAXHEARTCOUNT = <any> 'DEFAULT_MAX_HEART_COUNT'
    }
}

/**
 * 
 * @export
 * @interface AdminSetting
 */
export interface AdminSetting {
    /**
     * 
     * @type {number}
     * @memberof AdminSetting
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AdminSetting
     */
    setting?: AdminSetting.SettingEnum;
    /**
     * 
     * @type {number}
     * @memberof AdminSetting
     */
    value?: number;
}

/**
 * @export
 * @namespace AdminSetting
 */
export namespace AdminSetting {
    /**
     * @export
     * @enum {string}
     */
    export enum SettingEnum {
        REWARDCOOLDOWNWATCHMOVIEDURATIONMINS = <any> 'REWARD_COOLDOWN_WATCH_MOVIE_DURATION_MINS',
        POINTOFONEGAME = <any> 'POINT_OF_ONE_GAME',
        MAXNUMOFSINGERPERGAME = <any> 'MAX_NUM_OF_SINGER_PER_GAME',
        DEFAULTMAXHEARTCOUNT = <any> 'DEFAULT_MAX_HEART_COUNT'
    }
}

/**
 * 가수의 앨범 or 노래 커버 이미지 URL을 변경할 때 사용한다.
 * @export
 * @interface ArtworkUrlUpdateRequest
 */
export interface ArtworkUrlUpdateRequest {
    /**
     * 변경할 이미지 URL
     * @type {string}
     * @memberof ArtworkUrlUpdateRequest
     */
    artworkUrl?: string;
}

/**
 * 사용자가 1개의 문제를 풀었을 때 1개의 GameAnswer 객체를 제출해야 한다.
 * @export
 * @interface GameAnswer
 */
export interface GameAnswer {
    /**
     * 사용자가 입력한 정답.
     * @type {string}
     * @memberof GameAnswer
     */
    answer?: string;
    /**
     * (기억이 잘 안나지만) 문제에 해당하는 highlightId
     * @type {number}
     * @memberof GameAnswer
     */
    id?: number;
}

/**
 * 
 * @export
 * @interface GameAnswerCheckRequest
 */
export interface GameAnswerCheckRequest {
    /**
     * 
     * @type {string}
     * @memberof GameAnswerCheckRequest
     */
    answer?: string;
    /**
     * 
     * @type {string}
     * @memberof GameAnswerCheckRequest
     */
    playToken?: string;
    /**
     * 
     * @type {number}
     * @memberof GameAnswerCheckRequest
     */
    trackId?: number;
}

/**
 * 
 * @export
 * @interface GamePlayHighlightDTO
 */
export interface GamePlayHighlightDTO {
    /**
     * 
     * @type {string}
     * @memberof GamePlayHighlightDTO
     */
    artworkUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof GamePlayHighlightDTO
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof GamePlayHighlightDTO
     */
    millisecond?: number;
    /**
     * 
     * @type {string}
     * @memberof GamePlayHighlightDTO
     */
    singer?: string;
    /**
     * 
     * @type {string}
     * @memberof GamePlayHighlightDTO
     */
    title?: string;
    /**
     * 
     * @type {number}
     * @memberof GamePlayHighlightDTO
     */
    trackId?: number;
}

/**
 * 
 * @export
 * @interface GamePlayLogResponse
 */
export interface GamePlayLogResponse {
    /**
     * 
     * @type {string}
     * @memberof GamePlayLogResponse
     */
    createdAt?: string;
    /**
     * 
     * @type {number}
     * @memberof GamePlayLogResponse
     */
    gainPointOfThisGame?: number;
    /**
     * 
     * @type {string}
     * @memberof GamePlayLogResponse
     */
    gameLevelType?: string;
    /**
     * 
     * @type {Array<SongHighlightDTO>}
     * @memberof GamePlayLogResponse
     */
    songHighlightList?: Array<SongHighlightDTO>;
}

/**
 * 게임 종료 시 정답 유무를 채점하기 위하여 사용되는 정보
 * @export
 * @interface GameResultRequest
 */
export interface GameResultRequest {
    /**
     * 사용자가 입력한 정답 리스트
     * @type {Array<GameAnswer>}
     * @memberof GameResultRequest
     */
    gameAnswerList?: Array<GameAnswer>;
    /**
     * 게임 시작 시 발급받은 playToken
     * @type {string}
     * @memberof GameResultRequest
     */
    playToken?: string;
}

/**
 * 
 * @export
 * @interface GameResultResponse
 */
export interface GameResultResponse {
    /**
     * 
     * @type {number}
     * @memberof GameResultResponse
     */
    gainPointOfThisGame?: number;
    /**
     * 
     * @type {number}
     * @memberof GameResultResponse
     */
    heartCount?: number;
    /**
     * 
     * @type {number}
     * @memberof GameResultResponse
     */
    myRanking?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof GameResultResponse
     */
    resultComment?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof GameResultResponse
     */
    totalPoint?: number;
}

/**
 * 게임 결과
 * @export
 * @interface GameResultResponseV2
 */
export interface GameResultResponseV2 {
    /**
     * 이번판으로 휙득한 게임 점수.
     * @type {number}
     * @memberof GameResultResponseV2
     */
    gainPointOfThisGame?: number;
    /**
     * 남은 하트 갯수
     * @type {number}
     * @memberof GameResultResponseV2
     */
    heartCount?: number;
    /**
     * 게임 종료 후 결과 화면에 노출되는 2줄짜리 코멘트
     * @type {Array<string>}
     * @memberof GameResultResponseV2
     */
    resultComment?: Array<string>;
    /**
     * 각 시즌에 대한 랭킹/점수 포인트
     * @type {Array<ScoreViewModel>}
     * @memberof GameResultResponseV2
     */
    scoreViewModelList?: Array<ScoreViewModel>;
}

/**
 * 
 * @export
 * @interface GameStartRequest
 */
export interface GameStartRequest {
    /**
     * 
     * @type {number}
     * @memberof GameStartRequest
     */
    numOfHighlightPerGame?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof GameStartRequest
     */
    singerList?: Array<string>;
}

/**
 * 
 * @export
 * @interface GameStartResponse
 */
export interface GameStartResponse {
    /**
     * 
     * @type {Array<GamePlayHighlightDTO>}
     * @memberof GameStartResponse
     */
    playHighlightList?: Array<GamePlayHighlightDTO>;
    /**
     * 
     * @type {string}
     * @memberof GameStartResponse
     */
    playToken?: string;
}

/**
 * 
 * @export
 * @interface HeartResponse
 */
export interface HeartResponse {
    /**
     * 
     * @type {number}
     * @memberof HeartResponse
     */
    heartCount?: number;
    /**
     * 
     * @type {number}
     * @memberof HeartResponse
     */
    leftTime?: number;
}

/**
 * 
 * @export
 * @interface HighlightUpdateOrCreateRequest
 */
export interface HighlightUpdateOrCreateRequest {
    /**
     * 문제로 출제되고 있는 하이라이트인지 유무
     * @type {boolean}
     * @memberof HighlightUpdateOrCreateRequest
     */
    elected?: boolean;
    /**
     * 문제로 나오고 있는 시작 밀리세컨드( 시스템 로직 상 20초 이상만 저장이 가능함. )
     * @type {number}
     * @memberof HighlightUpdateOrCreateRequest
     */
    millisecond?: number;
}

/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    itemType?: Item.ItemTypeEnum;
}

/**
 * @export
 * @namespace Item
 */
export namespace Item {
    /**
     * @export
     * @enum {string}
     */
    export enum ItemTypeEnum {
        SKIP = <any> 'SKIP',
        CHARGEALLHEART = <any> 'CHARGE_ALL_HEART'
    }
}

/**
 * 
 * @export
 * @interface ItemCountInfo
 */
export interface ItemCountInfo {
    /**
     * 
     * @type {number}
     * @memberof ItemCountInfo
     */
    heartCount?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemCountInfo
     */
    skipCount?: number;
}

/**
 * 
 * @export
 * @interface ItemUpdateRequest
 */
export interface ItemUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof ItemUpdateRequest
     */
    heartCount?: number;
    /**
     * 
     * @type {string}
     * @memberof ItemUpdateRequest
     */
    nickname?: string;
    /**
     * 
     * @type {number}
     * @memberof ItemUpdateRequest
     */
    skipCount?: number;
}

/**
 * 
 * @export
 * @interface ItemUseRequest
 */
export interface ItemUseRequest {
    /**
     * 
     * @type {number}
     * @memberof ItemUseRequest
     */
    highlightId?: number;
    /**
     * 
     * @type {string}
     * @memberof ItemUseRequest
     */
    playToken?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemUseRequest
     */
    type?: string;
}

/**
 * 
 * @export
 * @interface Like
 */
export interface Like {
    /**
     * 
     * @type {number}
     * @memberof Like
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof Like
     */
    id?: number;
    /**
     * 
     * @type {Song}
     * @memberof Like
     */
    song?: Song;
}

/**
 * 
 * @export
 * @interface LikeHistoryResponse
 */
export interface LikeHistoryResponse {
    /**
     * 
     * @type {string}
     * @memberof LikeHistoryResponse
     */
    artworkUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof LikeHistoryResponse
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof LikeHistoryResponse
     */
    singer?: string;
    /**
     * 
     * @type {string}
     * @memberof LikeHistoryResponse
     */
    title?: string;
    /**
     * 
     * @type {number}
     * @memberof LikeHistoryResponse
     */
    trackId?: number;
}

/**
 * 
 * @export
 * @interface LikeRequest
 */
export interface LikeRequest {
    /**
     * 
     * @type {string}
     * @memberof LikeRequest
     */
    singerName?: string;
    /**
     * 
     * @type {string}
     * @memberof LikeRequest
     */
    songUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof LikeRequest
     */
    trackId?: number;
}

/**
 * 
 * @export
 * @interface LikeResponse
 */
export interface LikeResponse {
    /**
     * 
     * @type {number}
     * @memberof LikeResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof LikeResponse
     */
    trackId?: number;
}

/**
 * 
 * @export
 * @interface LoggedInMusicUser
 */
export interface LoggedInMusicUser {
    /**
     * 
     * @type {number}
     * @memberof LoggedInMusicUser
     */
    accessTime?: number;
    /**
     * 
     * @type {string}
     * @memberof LoggedInMusicUser
     */
    clientId?: string;
    /**
     * 
     * @type {string}
     * @memberof LoggedInMusicUser
     */
    nickname?: string;
    /**
     * 
     * @type {string}
     * @memberof LoggedInMusicUser
     */
    profileImageUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof LoggedInMusicUser
     */
    token?: string;
}

/**
 * 
 * @export
 * @interface MusicUser
 */
export interface MusicUser {
    /**
     * 
     * @type {number}
     * @memberof MusicUser
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof MusicUser
     */
    nickname?: string;
    /**
     * 
     * @type {string}
     * @memberof MusicUser
     */
    profileDisplayPhotoFileName?: string;
    /**
     * 
     * @type {string}
     * @memberof MusicUser
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof MusicUser
     */
    socialType?: string;
}

/**
 * 
 * @export
 * @interface NicknameChangeRequest
 */
export interface NicknameChangeRequest {
    /**
     * 
     * @type {string}
     * @memberof NicknameChangeRequest
     */
    newNickname?: string;
}

/**
 * 
 * @export
 * @interface PageSongResponse
 */
export interface PageSongResponse {
    /**
     * 
     * @type {Array<SongResponse>}
     * @memberof PageSongResponse
     */
    content?: Array<SongResponse>;
    /**
     * 
     * @type {boolean}
     * @memberof PageSongResponse
     */
    empty?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageSongResponse
     */
    first?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageSongResponse
     */
    last?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageSongResponse
     */
    number?: number;
    /**
     * 
     * @type {number}
     * @memberof PageSongResponse
     */
    numberOfElements?: number;
    /**
     * 
     * @type {Pageable}
     * @memberof PageSongResponse
     */
    pageable?: Pageable;
    /**
     * 
     * @type {number}
     * @memberof PageSongResponse
     */
    size?: number;
    /**
     * 
     * @type {Sort}
     * @memberof PageSongResponse
     */
    sort?: Sort;
    /**
     * 
     * @type {number}
     * @memberof PageSongResponse
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageSongResponse
     */
    totalPages?: number;
}

/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    pageNumber?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    pageSize?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Pageable
     */
    paged?: boolean;
    /**
     * 
     * @type {Sort}
     * @memberof Pageable
     */
    sort?: Sort;
    /**
     * 
     * @type {boolean}
     * @memberof Pageable
     */
    unpaged?: boolean;
}

/**
 * 
 * @export
 * @interface RankView
 */
export interface RankView {
    /**
     * 
     * @type {string}
     * @memberof RankView
     */
    nickname?: string;
    /**
     * 
     * @type {number}
     * @memberof RankView
     */
    point?: number;
    /**
     * 
     * @type {string}
     * @memberof RankView
     */
    profileImageUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof RankView
     */
    rankDiff?: number;
}

/**
 * 
 * @export
 * @interface RankViewModel
 */
export interface RankViewModel {
    /**
     * 
     * @type {Array<RankView>}
     * @memberof RankViewModel
     */
    rankViewList?: Array<RankView>;
    /**
     * 
     * @type {number}
     * @memberof RankViewModel
     */
    time?: number;
}

/**
 * 
 * @export
 * @interface ResponseBodyWrapperobject
 */
export interface ResponseBodyWrapperobject {
    /**
     * 응답 실패 사유
     * @type {string}
     * @memberof ResponseBodyWrapperobject
     */
    errorMsg?: string;
    /**
     * 응답 성공 시 응답 클래스
     * @type {any}
     * @memberof ResponseBodyWrapperobject
     */
    result?: any;
}

/**
 * 
 * @export
 * @interface ResponseDTO
 */
export interface ResponseDTO {
    /**
     * 
     * @type {any}
     * @memberof ResponseDTO
     */
    body?: any;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTO
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOGameResultResponse
 */
export interface ResponseDTOGameResultResponse {
    /**
     * 
     * @type {GameResultResponse}
     * @memberof ResponseDTOGameResultResponse
     */
    body?: GameResultResponse;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOGameResultResponse
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOGameResultResponseV2
 */
export interface ResponseDTOGameResultResponseV2 {
    /**
     * 
     * @type {GameResultResponseV2}
     * @memberof ResponseDTOGameResultResponseV2
     */
    body?: GameResultResponseV2;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOGameResultResponseV2
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOGameStartResponse
 */
export interface ResponseDTOGameStartResponse {
    /**
     * 
     * @type {GameStartResponse}
     * @memberof ResponseDTOGameStartResponse
     */
    body?: GameStartResponse;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOGameStartResponse
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOHeartResponse
 */
export interface ResponseDTOHeartResponse {
    /**
     * 
     * @type {HeartResponse}
     * @memberof ResponseDTOHeartResponse
     */
    body?: HeartResponse;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOHeartResponse
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOLikeResponse
 */
export interface ResponseDTOLikeResponse {
    /**
     * 
     * @type {LikeResponse}
     * @memberof ResponseDTOLikeResponse
     */
    body?: LikeResponse;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOLikeResponse
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOListItem
 */
export interface ResponseDTOListItem {
    /**
     * 
     * @type {Array<Item>}
     * @memberof ResponseDTOListItem
     */
    body?: Array<Item>;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOListItem
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOListLikeHistoryResponse
 */
export interface ResponseDTOListLikeHistoryResponse {
    /**
     * 
     * @type {Array<LikeHistoryResponse>}
     * @memberof ResponseDTOListLikeHistoryResponse
     */
    body?: Array<LikeHistoryResponse>;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOListLikeHistoryResponse
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOListSinger
 */
export interface ResponseDTOListSinger {
    /**
     * 
     * @type {Array<Singer>}
     * @memberof ResponseDTOListSinger
     */
    body?: Array<Singer>;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOListSinger
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOListUserLikeHistoryResponse
 */
export interface ResponseDTOListUserLikeHistoryResponse {
    /**
     * 
     * @type {Array<UserLikeHistoryResponse>}
     * @memberof ResponseDTOListUserLikeHistoryResponse
     */
    body?: Array<UserLikeHistoryResponse>;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOListUserLikeHistoryResponse
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOListstring
 */
export interface ResponseDTOListstring {
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseDTOListstring
     */
    body?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOListstring
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOLoggedInMusicUser
 */
export interface ResponseDTOLoggedInMusicUser {
    /**
     * 
     * @type {LoggedInMusicUser}
     * @memberof ResponseDTOLoggedInMusicUser
     */
    body?: LoggedInMusicUser;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOLoggedInMusicUser
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOPageSongResponse
 */
export interface ResponseDTOPageSongResponse {
    /**
     * 
     * @type {PageSongResponse}
     * @memberof ResponseDTOPageSongResponse
     */
    body?: PageSongResponse;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOPageSongResponse
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTORankViewModel
 */
export interface ResponseDTORankViewModel {
    /**
     * 
     * @type {RankViewModel}
     * @memberof ResponseDTORankViewModel
     */
    body?: RankViewModel;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTORankViewModel
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOReward
 */
export interface ResponseDTOReward {
    /**
     * 
     * @type {Reward}
     * @memberof ResponseDTOReward
     */
    body?: Reward;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOReward
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOSetstring
 */
export interface ResponseDTOSetstring {
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseDTOSetstring
     */
    body?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOSetstring
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOSong
 */
export interface ResponseDTOSong {
    /**
     * 
     * @type {Song}
     * @memberof ResponseDTOSong
     */
    body?: Song;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOSong
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOboolean
 */
export interface ResponseDTOboolean {
    /**
     * 
     * @type {boolean}
     * @memberof ResponseDTOboolean
     */
    body?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOboolean
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface ResponseDTOstring
 */
export interface ResponseDTOstring {
    /**
     * 
     * @type {string}
     * @memberof ResponseDTOstring
     */
    body?: string;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOstring
     */
    status?: number;
}

/**
 * 
 * @export
 * @interface RestrctionRequest
 */
export interface RestrctionRequest {
    /**
     * 
     * @type {string}
     * @memberof RestrctionRequest
     */
    singer?: string;
}

/**
 * 
 * @export
 * @interface Reward
 */
export interface Reward {
    /**
     * 
     * @type {number}
     * @memberof Reward
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Reward
     */
    rewardType?: string;
}

/**
 * 게임 결과 화면에 노출되는 스코어 관련 정보
 * @export
 * @interface ScoreViewModel
 */
export interface ScoreViewModel {
    /**
     * 스코어에 해당하는 랭킹.
     * @type {number}
     * @memberof ScoreViewModel
     */
    ranking?: number;
    /**
     * 스코어 정보
     * @type {AbstractScore}
     * @memberof ScoreViewModel
     */
    score?: AbstractScore;
    /**
     * 스코어에 해당하는 랭킹 타입.
     * @type {string}
     * @memberof ScoreViewModel
     */
    scoreType?: ScoreViewModel.ScoreTypeEnum;
}

/**
 * @export
 * @namespace ScoreViewModel
 */
export namespace ScoreViewModel {
    /**
     * @export
     * @enum {string}
     */
    export enum ScoreTypeEnum {
        SEASON = <any> 'SEASON',
        MONTHLY = <any> 'MONTHLY'
    }
}

/**
 * 가수 정보를 갖고 있는 오브젝트.
 * @export
 * @interface Singer
 */
export interface Singer {
    /**
     * 가수의 최근 앨범 이미지 URL
     * @type {string}
     * @memberof Singer
     */
    artworkUrl?: string;
    /**
     * 사용자들에게 얼마나 많은 좋아요를 받았는지 여부.
     * @type {number}
     * @memberof Singer
     */
    exportedCount?: number;
    /**
     * 해당 가수가 문제로 출제 될 수 있는 highlight를 갖고 있는지에 대한 여부.
     * @type {boolean}
     * @memberof Singer
     */
    hasHighlight?: boolean;
    /**
     * 가수 ID
     * @type {number}
     * @memberof Singer
     */
    id?: number;
    /**
     * 가수 이름
     * @type {string}
     * @memberof Singer
     */
    singerName?: string;
}

/**
 * Admin 에서 사용하는 가수 정보 오브젝트.
 * @export
 * @interface SingerInfoView
 */
export interface SingerInfoView {
    /**
     * 가수 정보
     * @type {Singer}
     * @memberof SingerInfoView
     */
    singer?: Singer;
    /**
     * 가수가 소지하고 있는 노래 리스트
     * @type {Array<Song>}
     * @memberof SingerInfoView
     */
    songList?: Array<Song>;
}

/**
 * 가수가 갖고있는 노래의 정보
 * @export
 * @interface Song
 */
export interface Song {
    /**
     * 노래 앨범 url
     * @type {string}
     * @memberof Song
     */
    artworkUrl?: string;
    /**
     * true : 사용자들에게 출제 되고 있는 문제임 / false : 사용자들에게 출제 되고 있지 않은 노래임.
     * @type {boolean}
     * @memberof Song
     */
    exported?: boolean;
    /**
     * 노래 ID
     * @type {number}
     * @memberof Song
     */
    id?: number;
    /**
     * 
     * @type {Like}
     * @memberof Song
     */
    like?: Like;
    /**
     * 
     * @type {MusicUser}
     * @memberof Song
     */
    musicUser?: MusicUser;
    /**
     * 노래의 정답. 사용자는 이 답을 입력 해야지만 정답 처리가 된다
     * @type {string}
     * @memberof Song
     */
    refinedTitle?: string;
    /**
     * 이 노래의 주인인 가수 정보.
     * @type {string}
     * @memberof Song
     */
    singer?: string;
    /**
     * 해당 노래가 갖고있는 Highlight들의 집합. 해당 highlight 정보를 이용하여 게임 플레이를 진행함.
     * @type {Array<SongHighlight>}
     * @memberof Song
     */
    songHighlight?: Array<SongHighlight>;
    /**
     * 사용자들에게 노출될 title
     * @type {string}
     * @memberof Song
     */
    title?: string;
    /**
     * 노래 trackId, 이 값은 SoundCloud의 노래의 trackId랑 같은 값임
     * @type {number}
     * @memberof Song
     */
    trackId?: number;
    /**
     * 노래 streaming url
     * @type {string}
     * @memberof Song
     */
    url?: string;
}

/**
 * 특정 Song에 등록된 Highlight들. 해당 객체의 정보를 바탕으로 문제가 출제된다.
 * @export
 * @interface SongHighlight
 */
export interface SongHighlight {
    /**
     * 해당 highlight가 출제되고 있는지에 대한 여부
     * @type {boolean}
     * @memberof SongHighlight
     */
    elected?: boolean;
    /**
     * songHighlight ID
     * @type {number}
     * @memberof SongHighlight
     */
    id?: number;
    /**
     * 사용자가 노래를 듣게 될 시작부분.
     * @type {number}
     * @memberof SongHighlight
     */
    millisecond?: number;
    /**
     * 
     * @type {Song}
     * @memberof SongHighlight
     */
    song?: Song;
}

/**
 * 
 * @export
 * @interface SongHighlightAddRequest
 */
export interface SongHighlightAddRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof SongHighlightAddRequest
     */
    highlightSeconds?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof SongHighlightAddRequest
     */
    songId?: number;
}

/**
 * 
 * @export
 * @interface SongHighlightDTO
 */
export interface SongHighlightDTO {
    /**
     * 
     * @type {number}
     * @memberof SongHighlightDTO
     */
    millisecond?: number;
    /**
     * 
     * @type {string}
     * @memberof SongHighlightDTO
     */
    singer?: string;
    /**
     * 
     * @type {string}
     * @memberof SongHighlightDTO
     */
    title?: string;
}

/**
 * 
 * @export
 * @interface SongRegisterRequest
 */
export interface SongRegisterRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof SongRegisterRequest
     */
    highlightSeconds?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof SongRegisterRequest
     */
    singerName?: string;
    /**
     * 
     * @type {string}
     * @memberof SongRegisterRequest
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface SongResponse
 */
export interface SongResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SongResponse
     */
    alreadyLike?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SongResponse
     */
    artworkUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof SongResponse
     */
    like?: number;
    /**
     * 
     * @type {string}
     * @memberof SongResponse
     */
    singer?: string;
    /**
     * 
     * @type {string}
     * @memberof SongResponse
     */
    title?: string;
    /**
     * 
     * @type {number}
     * @memberof SongResponse
     */
    trackId?: number;
    /**
     * 
     * @type {string}
     * @memberof SongResponse
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface SongUpdateRequest
 */
export interface SongUpdateRequest {
    /**
     * 노래 앨범 url
     * @type {string}
     * @memberof SongUpdateRequest
     */
    artworkUrl?: string;
    /**
     * 사용자들에게 문제로 출제 되고 있는지에 대한 유무
     * @type {boolean}
     * @memberof SongUpdateRequest
     */
    exported?: boolean;
    /**
     * 노래의 정답. 사용자는 이 답을 입력 해야지만 정답 처리가 된다
     * @type {string}
     * @memberof SongUpdateRequest
     */
    refineTitle?: string;
    /**
     * 노래 제목
     * @type {string}
     * @memberof SongUpdateRequest
     */
    title?: string;
    /**
     * 노래 streaming url
     * @type {string}
     * @memberof SongUpdateRequest
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    empty?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    sorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    unsorted?: boolean;
}

/**
 * 
 * @export
 * @interface Track
 */
export interface Track {
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    artworkUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof Track
     */
    commentCount?: number;
    /**
     * 
     * @type {number}
     * @memberof Track
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    singerName?: string;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    streamUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Track
     */
    streamable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    uri?: string;
}

/**
 * 
 * @export
 * @interface UserLikeHistoryResponse
 */
export interface UserLikeHistoryResponse {
    /**
     * 
     * @type {string}
     * @memberof UserLikeHistoryResponse
     */
    accessId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLikeHistoryResponse
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLikeHistoryResponse
     */
    nickname?: string;
}

/**
 * 
 * @export
 * @interface UserLoginRequest
 */
export interface UserLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof UserLoginRequest
     */
    accessId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginRequest
     */
    accessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginRequest
     */
    refreshToken?: string;
}

/**
 * 
 * @export
 * @interface UserSignUpRequest
 */
export interface UserSignUpRequest {
    /**
     * 
     * @type {string}
     * @memberof UserSignUpRequest
     */
    accessId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSignUpRequest
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSignUpRequest
     */
    invitedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSignUpRequest
     */
    nickname?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSignUpRequest
     */
    socialType?: string;
}


/**
 * APIApi - fetch parameter creator
 * @export
 */
export const APIApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 신규 Highlight 정보 생성
         * @summary 하이라이트 정보 생성
         * @param {HighlightUpdateOrCreateRequest} request 생성할 하이라이트 정보
         * @param {number} songId 생성할 하이라이트의 노래 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHighlightUsingPOST(request: HighlightUpdateOrCreateRequest, songId: number, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling createHighlightUsingPOST.');
            }
            // verify required parameter 'songId' is not null or undefined
            if (songId === null || songId === undefined) {
                throw new RequiredError('songId','Required parameter songId was null or undefined when calling createHighlightUsingPOST.');
            }
            const localVarPath = `/v2/admin/songs/{songId}/highlights`
                .replace(`{${"songId"}}`, encodeURIComponent(String(songId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"HighlightUpdateOrCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 가수 이름을 기반으로 가수 이름을 검색 합니다.
         * @summary 가수 정보 조회
         * @param {string} singerName 가수 이름
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingerInfoUsingGET(singerName: string, options: any = {}): FetchArgs {
            // verify required parameter 'singerName' is not null or undefined
            if (singerName === null || singerName === undefined) {
                throw new RequiredError('singerName','Required parameter singerName was null or undefined when calling getSingerInfoUsingGET.');
            }
            const localVarPath = `/v2/admin/singers/{singerName}`
                .replace(`{${"singerName"}}`, encodeURIComponent(String(singerName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 가수 앨범 이미지를 변경 합니다.
         * @summary 가수 앨범 이미지 변경
         * @param {ArtworkUrlUpdateRequest} request 변경할 앨범 이미지 URL
         * @param {string} singerName 가수 이름
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtworkUrlUsingPUT(request: ArtworkUrlUpdateRequest, singerName: string, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling updateArtworkUrlUsingPUT.');
            }
            // verify required parameter 'singerName' is not null or undefined
            if (singerName === null || singerName === undefined) {
                throw new RequiredError('singerName','Required parameter singerName was null or undefined when calling updateArtworkUrlUsingPUT.');
            }
            const localVarPath = `/v2/admin/singers/{singerName}/artworkUrl`
                .replace(`{${"singerName"}}`, encodeURIComponent(String(singerName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ArtworkUrlUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admin UI에 알맞게 highlightId 만을 이용하여 하이라이트 정보를 변경한다.
         * @summary 하이라이트 정보 변경
         * @param {number} highlightId 하이라이트 ID
         * @param {HighlightUpdateOrCreateRequest} request 변경할 하이라이트 정보
         * @param {number} songId 변경할 하이라이트의 노래 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHighlightUsingPUT(highlightId: number, request: HighlightUpdateOrCreateRequest, songId: number, options: any = {}): FetchArgs {
            // verify required parameter 'highlightId' is not null or undefined
            if (highlightId === null || highlightId === undefined) {
                throw new RequiredError('highlightId','Required parameter highlightId was null or undefined when calling updateHighlightUsingPUT.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling updateHighlightUsingPUT.');
            }
            // verify required parameter 'songId' is not null or undefined
            if (songId === null || songId === undefined) {
                throw new RequiredError('songId','Required parameter songId was null or undefined when calling updateHighlightUsingPUT.');
            }
            const localVarPath = `/v2/admin/songs/{songId}/highlights/{highlightId}`
                .replace(`{${"highlightId"}}`, encodeURIComponent(String(highlightId)))
                .replace(`{${"songId"}}`, encodeURIComponent(String(songId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"HighlightUpdateOrCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 가수의 정보를 변경한다.
         * @summary 가수 노래 정보 변경
         * @param {SongUpdateRequest} request 변경할 노래 정보
         * @param {number} songId 변경할 노래 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSongUsingPUT(request: SongUpdateRequest, songId: number, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling updateSongUsingPUT.');
            }
            // verify required parameter 'songId' is not null or undefined
            if (songId === null || songId === undefined) {
                throw new RequiredError('songId','Required parameter songId was null or undefined when calling updateSongUsingPUT.');
            }
            const localVarPath = `/v2/admin/songs/{songId}`
                .replace(`{${"songId"}}`, encodeURIComponent(String(songId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SongUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIApi - functional programming interface
 * @export
 */
export const APIApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 신규 Highlight 정보 생성
         * @summary 하이라이트 정보 생성
         * @param {HighlightUpdateOrCreateRequest} request 생성할 하이라이트 정보
         * @param {number} songId 생성할 하이라이트의 노래 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHighlightUsingPOST(request: HighlightUpdateOrCreateRequest, songId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SongHighlight> {
            const localVarFetchArgs = APIApiFetchParamCreator(configuration).createHighlightUsingPOST(request, songId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 가수 이름을 기반으로 가수 이름을 검색 합니다.
         * @summary 가수 정보 조회
         * @param {string} singerName 가수 이름
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingerInfoUsingGET(singerName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SingerInfoView> {
            const localVarFetchArgs = APIApiFetchParamCreator(configuration).getSingerInfoUsingGET(singerName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 가수 앨범 이미지를 변경 합니다.
         * @summary 가수 앨범 이미지 변경
         * @param {ArtworkUrlUpdateRequest} request 변경할 앨범 이미지 URL
         * @param {string} singerName 가수 이름
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtworkUrlUsingPUT(request: ArtworkUrlUpdateRequest, singerName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Singer> {
            const localVarFetchArgs = APIApiFetchParamCreator(configuration).updateArtworkUrlUsingPUT(request, singerName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Admin UI에 알맞게 highlightId 만을 이용하여 하이라이트 정보를 변경한다.
         * @summary 하이라이트 정보 변경
         * @param {number} highlightId 하이라이트 ID
         * @param {HighlightUpdateOrCreateRequest} request 변경할 하이라이트 정보
         * @param {number} songId 변경할 하이라이트의 노래 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHighlightUsingPUT(highlightId: number, request: HighlightUpdateOrCreateRequest, songId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SongHighlight> {
            const localVarFetchArgs = APIApiFetchParamCreator(configuration).updateHighlightUsingPUT(highlightId, request, songId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 가수의 정보를 변경한다.
         * @summary 가수 노래 정보 변경
         * @param {SongUpdateRequest} request 변경할 노래 정보
         * @param {number} songId 변경할 노래 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSongUsingPUT(request: SongUpdateRequest, songId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Song> {
            const localVarFetchArgs = APIApiFetchParamCreator(configuration).updateSongUsingPUT(request, songId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * APIApi - factory interface
 * @export
 */
export const APIApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 신규 Highlight 정보 생성
         * @summary 하이라이트 정보 생성
         * @param {HighlightUpdateOrCreateRequest} request 생성할 하이라이트 정보
         * @param {number} songId 생성할 하이라이트의 노래 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHighlightUsingPOST(request: HighlightUpdateOrCreateRequest, songId: number, options?: any) {
            return APIApiFp(configuration).createHighlightUsingPOST(request, songId, options)(fetch, basePath);
        },
        /**
         * 가수 이름을 기반으로 가수 이름을 검색 합니다.
         * @summary 가수 정보 조회
         * @param {string} singerName 가수 이름
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingerInfoUsingGET(singerName: string, options?: any) {
            return APIApiFp(configuration).getSingerInfoUsingGET(singerName, options)(fetch, basePath);
        },
        /**
         * 가수 앨범 이미지를 변경 합니다.
         * @summary 가수 앨범 이미지 변경
         * @param {ArtworkUrlUpdateRequest} request 변경할 앨범 이미지 URL
         * @param {string} singerName 가수 이름
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtworkUrlUsingPUT(request: ArtworkUrlUpdateRequest, singerName: string, options?: any) {
            return APIApiFp(configuration).updateArtworkUrlUsingPUT(request, singerName, options)(fetch, basePath);
        },
        /**
         * Admin UI에 알맞게 highlightId 만을 이용하여 하이라이트 정보를 변경한다.
         * @summary 하이라이트 정보 변경
         * @param {number} highlightId 하이라이트 ID
         * @param {HighlightUpdateOrCreateRequest} request 변경할 하이라이트 정보
         * @param {number} songId 변경할 하이라이트의 노래 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHighlightUsingPUT(highlightId: number, request: HighlightUpdateOrCreateRequest, songId: number, options?: any) {
            return APIApiFp(configuration).updateHighlightUsingPUT(highlightId, request, songId, options)(fetch, basePath);
        },
        /**
         * 가수의 정보를 변경한다.
         * @summary 가수 노래 정보 변경
         * @param {SongUpdateRequest} request 변경할 노래 정보
         * @param {number} songId 변경할 노래 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSongUsingPUT(request: SongUpdateRequest, songId: number, options?: any) {
            return APIApiFp(configuration).updateSongUsingPUT(request, songId, options)(fetch, basePath);
        },
    };
};

/**
 * APIApi - object-oriented interface
 * @export
 * @class APIApi
 * @extends {BaseAPI}
 */
export class APIApi extends BaseAPI {
    /**
     * 신규 Highlight 정보 생성
     * @summary 하이라이트 정보 생성
     * @param {HighlightUpdateOrCreateRequest} request 생성할 하이라이트 정보
     * @param {number} songId 생성할 하이라이트의 노래 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public createHighlightUsingPOST(request: HighlightUpdateOrCreateRequest, songId: number, options?: any) {
        return APIApiFp(this.configuration).createHighlightUsingPOST(request, songId, options)(this.fetch, this.basePath);
    }

    /**
     * 가수 이름을 기반으로 가수 이름을 검색 합니다.
     * @summary 가수 정보 조회
     * @param {string} singerName 가수 이름
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public getSingerInfoUsingGET(singerName: string, options?: any) {
        return APIApiFp(this.configuration).getSingerInfoUsingGET(singerName, options)(this.fetch, this.basePath);
    }

    /**
     * 가수 앨범 이미지를 변경 합니다.
     * @summary 가수 앨범 이미지 변경
     * @param {ArtworkUrlUpdateRequest} request 변경할 앨범 이미지 URL
     * @param {string} singerName 가수 이름
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public updateArtworkUrlUsingPUT(request: ArtworkUrlUpdateRequest, singerName: string, options?: any) {
        return APIApiFp(this.configuration).updateArtworkUrlUsingPUT(request, singerName, options)(this.fetch, this.basePath);
    }

    /**
     * Admin UI에 알맞게 highlightId 만을 이용하여 하이라이트 정보를 변경한다.
     * @summary 하이라이트 정보 변경
     * @param {number} highlightId 하이라이트 ID
     * @param {HighlightUpdateOrCreateRequest} request 변경할 하이라이트 정보
     * @param {number} songId 변경할 하이라이트의 노래 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public updateHighlightUsingPUT(highlightId: number, request: HighlightUpdateOrCreateRequest, songId: number, options?: any) {
        return APIApiFp(this.configuration).updateHighlightUsingPUT(highlightId, request, songId, options)(this.fetch, this.basePath);
    }

    /**
     * 가수의 정보를 변경한다.
     * @summary 가수 노래 정보 변경
     * @param {SongUpdateRequest} request 변경할 노래 정보
     * @param {number} songId 변경할 노래 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public updateSongUsingPUT(request: SongUpdateRequest, songId: number, options?: any) {
        return APIApiFp(this.configuration).updateSongUsingPUT(request, songId, options)(this.fetch, this.basePath);
    }

}

/**
 * AdminControllerApi - fetch parameter creator
 * @export
 */
export const AdminControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteRestriction
         * @param {number} restrictionId restrictionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRestrictionUsingDELETE(restrictionId: number, options: any = {}): FetchArgs {
            // verify required parameter 'restrictionId' is not null or undefined
            if (restrictionId === null || restrictionId === undefined) {
                throw new RequiredError('restrictionId','Required parameter restrictionId was null or undefined when calling deleteRestrictionUsingDELETE.');
            }
            const localVarPath = `/v1/admin/restrictions/{restrictionId}`
                .replace(`{${"restrictionId"}}`, encodeURIComponent(String(restrictionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete
         * @param {number} songId songId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsingDELETE(songId: number, options: any = {}): FetchArgs {
            // verify required parameter 'songId' is not null or undefined
            if (songId === null || songId === undefined) {
                throw new RequiredError('songId','Required parameter songId was null or undefined when calling deleteUsingDELETE.');
            }
            const localVarPath = `/v1/admin/songs/{songId}`
                .replace(`{${"songId"}}`, encodeURIComponent(String(songId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findByNickname
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByNicknameUsingGET(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling findByNicknameUsingGET.');
            }
            const localVarPath = `/v1/admin/user/findByNickname/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPlayLogsByNickname
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayLogsByNicknameUsingGET(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getPlayLogsByNicknameUsingGET.');
            }
            const localVarPath = `/v1/admin/log/names/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveAdminSetting
         * @param {AdminSetting} setting setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAdminSettingUsingPUT(setting: AdminSetting, options: any = {}): FetchArgs {
            // verify required parameter 'setting' is not null or undefined
            if (setting === null || setting === undefined) {
                throw new RequiredError('setting','Required parameter setting was null or undefined when calling saveAdminSettingUsingPUT.');
            }
            const localVarPath = `/v1/admin/setting`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AdminSetting" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(setting || {}) : (setting || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveAdminSetting
         * @param {AdminRequest} request request
         * @param {number} settingId settingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAdminSettingUsingPUT1(request: AdminRequest, settingId: number, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling saveAdminSettingUsingPUT1.');
            }
            // verify required parameter 'settingId' is not null or undefined
            if (settingId === null || settingId === undefined) {
                throw new RequiredError('settingId','Required parameter settingId was null or undefined when calling saveAdminSettingUsingPUT1.');
            }
            const localVarPath = `/v1/admin/settings/{settingId}`
                .replace(`{${"settingId"}}`, encodeURIComponent(String(settingId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AdminRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary save
         * @param {RestrctionRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUsingPOST(request: RestrctionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling saveUsingPOST.');
            }
            const localVarPath = `/v1/admin/restriction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RestrctionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateExcludeWord
         * @param {string} excludeWord excludeWord
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExcludeWordUsingPOST(excludeWord: string, id: number, options: any = {}): FetchArgs {
            // verify required parameter 'excludeWord' is not null or undefined
            if (excludeWord === null || excludeWord === undefined) {
                throw new RequiredError('excludeWord','Required parameter excludeWord was null or undefined when calling updateExcludeWordUsingPOST.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateExcludeWordUsingPOST.');
            }
            const localVarPath = `/v1/admin/excludeWord/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(excludeWord || {}) : (excludeWord || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateExcludeWord
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExcludeWordUsingPUT(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateExcludeWordUsingPUT.');
            }
            const localVarPath = `/v1/admin/excludeWord/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateItemByNickname
         * @param {ItemUpdateRequest} itemUpdateRequest itemUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemByNicknameUsingPUT(itemUpdateRequest: ItemUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'itemUpdateRequest' is not null or undefined
            if (itemUpdateRequest === null || itemUpdateRequest === undefined) {
                throw new RequiredError('itemUpdateRequest','Required parameter itemUpdateRequest was null or undefined when calling updateItemByNicknameUsingPUT.');
            }
            const localVarPath = `/v1/admin/item/update`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ItemUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(itemUpdateRequest || {}) : (itemUpdateRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update
         * @param {Song} song song
         * @param {number} songId songId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsingPUT(song: Song, songId: number, options: any = {}): FetchArgs {
            // verify required parameter 'song' is not null or undefined
            if (song === null || song === undefined) {
                throw new RequiredError('song','Required parameter song was null or undefined when calling updateUsingPUT.');
            }
            // verify required parameter 'songId' is not null or undefined
            if (songId === null || songId === undefined) {
                throw new RequiredError('songId','Required parameter songId was null or undefined when calling updateUsingPUT.');
            }
            const localVarPath = `/v1/admin/songs/{songId}`
                .replace(`{${"songId"}}`, encodeURIComponent(String(songId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Song" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(song || {}) : (song || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminControllerApi - functional programming interface
 * @export
 */
export const AdminControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteRestriction
         * @param {number} restrictionId restrictionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRestrictionUsingDELETE(restrictionId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = AdminControllerApiFetchParamCreator(configuration).deleteRestrictionUsingDELETE(restrictionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary delete
         * @param {number} songId songId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsingDELETE(songId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = AdminControllerApiFetchParamCreator(configuration).deleteUsingDELETE(songId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary findByNickname
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByNicknameUsingGET(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemCountInfo> {
            const localVarFetchArgs = AdminControllerApiFetchParamCreator(configuration).findByNicknameUsingGET(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getPlayLogsByNickname
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayLogsByNicknameUsingGET(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GamePlayLogResponse>> {
            const localVarFetchArgs = AdminControllerApiFetchParamCreator(configuration).getPlayLogsByNicknameUsingGET(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveAdminSetting
         * @param {AdminSetting} setting setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAdminSettingUsingPUT(setting: AdminSetting, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTO> {
            const localVarFetchArgs = AdminControllerApiFetchParamCreator(configuration).saveAdminSettingUsingPUT(setting, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary saveAdminSetting
         * @param {AdminRequest} request request
         * @param {number} settingId settingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAdminSettingUsingPUT1(request: AdminRequest, settingId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = AdminControllerApiFetchParamCreator(configuration).saveAdminSettingUsingPUT1(request, settingId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary save
         * @param {RestrctionRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUsingPOST(request: RestrctionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = AdminControllerApiFetchParamCreator(configuration).saveUsingPOST(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updateExcludeWord
         * @param {string} excludeWord excludeWord
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExcludeWordUsingPOST(excludeWord: string, id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = AdminControllerApiFetchParamCreator(configuration).updateExcludeWordUsingPOST(excludeWord, id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updateExcludeWord
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExcludeWordUsingPUT(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = AdminControllerApiFetchParamCreator(configuration).updateExcludeWordUsingPUT(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary updateItemByNickname
         * @param {ItemUpdateRequest} itemUpdateRequest itemUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemByNicknameUsingPUT(itemUpdateRequest: ItemUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTO> {
            const localVarFetchArgs = AdminControllerApiFetchParamCreator(configuration).updateItemByNicknameUsingPUT(itemUpdateRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary update
         * @param {Song} song song
         * @param {number} songId songId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsingPUT(song: Song, songId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = AdminControllerApiFetchParamCreator(configuration).updateUsingPUT(song, songId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AdminControllerApi - factory interface
 * @export
 */
export const AdminControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary deleteRestriction
         * @param {number} restrictionId restrictionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRestrictionUsingDELETE(restrictionId: number, options?: any) {
            return AdminControllerApiFp(configuration).deleteRestrictionUsingDELETE(restrictionId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary delete
         * @param {number} songId songId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsingDELETE(songId: number, options?: any) {
            return AdminControllerApiFp(configuration).deleteUsingDELETE(songId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary findByNickname
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByNicknameUsingGET(name: string, options?: any) {
            return AdminControllerApiFp(configuration).findByNicknameUsingGET(name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getPlayLogsByNickname
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayLogsByNicknameUsingGET(name: string, options?: any) {
            return AdminControllerApiFp(configuration).getPlayLogsByNicknameUsingGET(name, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveAdminSetting
         * @param {AdminSetting} setting setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAdminSettingUsingPUT(setting: AdminSetting, options?: any) {
            return AdminControllerApiFp(configuration).saveAdminSettingUsingPUT(setting, options)(fetch, basePath);
        },
        /**
         * 
         * @summary saveAdminSetting
         * @param {AdminRequest} request request
         * @param {number} settingId settingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAdminSettingUsingPUT1(request: AdminRequest, settingId: number, options?: any) {
            return AdminControllerApiFp(configuration).saveAdminSettingUsingPUT1(request, settingId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary save
         * @param {RestrctionRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUsingPOST(request: RestrctionRequest, options?: any) {
            return AdminControllerApiFp(configuration).saveUsingPOST(request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary updateExcludeWord
         * @param {string} excludeWord excludeWord
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExcludeWordUsingPOST(excludeWord: string, id: number, options?: any) {
            return AdminControllerApiFp(configuration).updateExcludeWordUsingPOST(excludeWord, id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary updateExcludeWord
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExcludeWordUsingPUT(id: number, options?: any) {
            return AdminControllerApiFp(configuration).updateExcludeWordUsingPUT(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary updateItemByNickname
         * @param {ItemUpdateRequest} itemUpdateRequest itemUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemByNicknameUsingPUT(itemUpdateRequest: ItemUpdateRequest, options?: any) {
            return AdminControllerApiFp(configuration).updateItemByNicknameUsingPUT(itemUpdateRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary update
         * @param {Song} song song
         * @param {number} songId songId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsingPUT(song: Song, songId: number, options?: any) {
            return AdminControllerApiFp(configuration).updateUsingPUT(song, songId, options)(fetch, basePath);
        },
    };
};

/**
 * AdminControllerApi - object-oriented interface
 * @export
 * @class AdminControllerApi
 * @extends {BaseAPI}
 */
export class AdminControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteRestriction
     * @param {number} restrictionId restrictionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public deleteRestrictionUsingDELETE(restrictionId: number, options?: any) {
        return AdminControllerApiFp(this.configuration).deleteRestrictionUsingDELETE(restrictionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary delete
     * @param {number} songId songId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public deleteUsingDELETE(songId: number, options?: any) {
        return AdminControllerApiFp(this.configuration).deleteUsingDELETE(songId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary findByNickname
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public findByNicknameUsingGET(name: string, options?: any) {
        return AdminControllerApiFp(this.configuration).findByNicknameUsingGET(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getPlayLogsByNickname
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public getPlayLogsByNicknameUsingGET(name: string, options?: any) {
        return AdminControllerApiFp(this.configuration).getPlayLogsByNicknameUsingGET(name, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveAdminSetting
     * @param {AdminSetting} setting setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public saveAdminSettingUsingPUT(setting: AdminSetting, options?: any) {
        return AdminControllerApiFp(this.configuration).saveAdminSettingUsingPUT(setting, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary saveAdminSetting
     * @param {AdminRequest} request request
     * @param {number} settingId settingId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public saveAdminSettingUsingPUT1(request: AdminRequest, settingId: number, options?: any) {
        return AdminControllerApiFp(this.configuration).saveAdminSettingUsingPUT1(request, settingId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary save
     * @param {RestrctionRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public saveUsingPOST(request: RestrctionRequest, options?: any) {
        return AdminControllerApiFp(this.configuration).saveUsingPOST(request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updateExcludeWord
     * @param {string} excludeWord excludeWord
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public updateExcludeWordUsingPOST(excludeWord: string, id: number, options?: any) {
        return AdminControllerApiFp(this.configuration).updateExcludeWordUsingPOST(excludeWord, id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updateExcludeWord
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public updateExcludeWordUsingPUT(id: number, options?: any) {
        return AdminControllerApiFp(this.configuration).updateExcludeWordUsingPUT(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary updateItemByNickname
     * @param {ItemUpdateRequest} itemUpdateRequest itemUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public updateItemByNicknameUsingPUT(itemUpdateRequest: ItemUpdateRequest, options?: any) {
        return AdminControllerApiFp(this.configuration).updateItemByNicknameUsingPUT(itemUpdateRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary update
     * @param {Song} song song
     * @param {number} songId songId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public updateUsingPUT(song: Song, songId: number, options?: any) {
        return AdminControllerApiFp(this.configuration).updateUsingPUT(song, songId, options)(this.fetch, this.basePath);
    }

}

/**
 * AdminViewControllerApi - fetch parameter creator
 * @export
 */
export const AdminViewControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addItemToUser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItemToUserUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/admin/addItemToUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPlayLogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayLogsUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/admin/logView`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getRestriction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestrictionUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/admin/restrictions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/admin/settings`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/admin/main`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary refineWord
         * @param {string} [singerName] singerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refineWordUsingGET(singerName?: string, options: any = {}): FetchArgs {
            const localVarPath = `/admin/refine-word`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (singerName !== undefined) {
                localVarQueryParameter['singerName'] = singerName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary settingUpdate
         * @param {number} settingId settingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingUpdateUsingGET(settingId: number, options: any = {}): FetchArgs {
            // verify required parameter 'settingId' is not null or undefined
            if (settingId === null || settingId === undefined) {
                throw new RequiredError('settingId','Required parameter settingId was null or undefined when calling settingUpdateUsingGET.');
            }
            const localVarPath = `/admin/settings/{settingId}`
                .replace(`{${"settingId"}}`, encodeURIComponent(String(settingId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary songsUpdate
         * @param {number} songId songId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songsUpdateUsingGET(songId: number, options: any = {}): FetchArgs {
            // verify required parameter 'songId' is not null or undefined
            if (songId === null || songId === undefined) {
                throw new RequiredError('songId','Required parameter songId was null or undefined when calling songsUpdateUsingGET.');
            }
            const localVarPath = `/admin/songs/{songId}`
                .replace(`{${"songId"}}`, encodeURIComponent(String(songId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminViewControllerApi - functional programming interface
 * @export
 */
export const AdminViewControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addItemToUser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItemToUserUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = AdminViewControllerApiFetchParamCreator(configuration).addItemToUserUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getPlayLogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayLogsUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = AdminViewControllerApiFetchParamCreator(configuration).getPlayLogsUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getRestriction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestrictionUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = AdminViewControllerApiFetchParamCreator(configuration).getRestrictionUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = AdminViewControllerApiFetchParamCreator(configuration).getSettingUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = AdminViewControllerApiFetchParamCreator(configuration).mainUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary refineWord
         * @param {string} [singerName] singerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refineWordUsingGET(singerName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = AdminViewControllerApiFetchParamCreator(configuration).refineWordUsingGET(singerName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary settingUpdate
         * @param {number} settingId settingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingUpdateUsingGET(settingId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = AdminViewControllerApiFetchParamCreator(configuration).settingUpdateUsingGET(settingId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary songsUpdate
         * @param {number} songId songId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songsUpdateUsingGET(songId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = AdminViewControllerApiFetchParamCreator(configuration).songsUpdateUsingGET(songId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AdminViewControllerApi - factory interface
 * @export
 */
export const AdminViewControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary addItemToUser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItemToUserUsingGET(options?: any) {
            return AdminViewControllerApiFp(configuration).addItemToUserUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getPlayLogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayLogsUsingGET(options?: any) {
            return AdminViewControllerApiFp(configuration).getPlayLogsUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getRestriction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestrictionUsingGET(options?: any) {
            return AdminViewControllerApiFp(configuration).getRestrictionUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingUsingGET(options?: any) {
            return AdminViewControllerApiFp(configuration).getSettingUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainUsingGET(options?: any) {
            return AdminViewControllerApiFp(configuration).mainUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary refineWord
         * @param {string} [singerName] singerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refineWordUsingGET(singerName?: string, options?: any) {
            return AdminViewControllerApiFp(configuration).refineWordUsingGET(singerName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary settingUpdate
         * @param {number} settingId settingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingUpdateUsingGET(settingId: number, options?: any) {
            return AdminViewControllerApiFp(configuration).settingUpdateUsingGET(settingId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary songsUpdate
         * @param {number} songId songId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songsUpdateUsingGET(songId: number, options?: any) {
            return AdminViewControllerApiFp(configuration).songsUpdateUsingGET(songId, options)(fetch, basePath);
        },
    };
};

/**
 * AdminViewControllerApi - object-oriented interface
 * @export
 * @class AdminViewControllerApi
 * @extends {BaseAPI}
 */
export class AdminViewControllerApi extends BaseAPI {
    /**
     * 
     * @summary addItemToUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminViewControllerApi
     */
    public addItemToUserUsingGET(options?: any) {
        return AdminViewControllerApiFp(this.configuration).addItemToUserUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getPlayLogs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminViewControllerApi
     */
    public getPlayLogsUsingGET(options?: any) {
        return AdminViewControllerApiFp(this.configuration).getPlayLogsUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getRestriction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminViewControllerApi
     */
    public getRestrictionUsingGET(options?: any) {
        return AdminViewControllerApiFp(this.configuration).getRestrictionUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getSetting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminViewControllerApi
     */
    public getSettingUsingGET(options?: any) {
        return AdminViewControllerApiFp(this.configuration).getSettingUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary main
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminViewControllerApi
     */
    public mainUsingGET(options?: any) {
        return AdminViewControllerApiFp(this.configuration).mainUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary refineWord
     * @param {string} [singerName] singerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminViewControllerApi
     */
    public refineWordUsingGET(singerName?: string, options?: any) {
        return AdminViewControllerApiFp(this.configuration).refineWordUsingGET(singerName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary settingUpdate
     * @param {number} settingId settingId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminViewControllerApi
     */
    public settingUpdateUsingGET(settingId: number, options?: any) {
        return AdminViewControllerApiFp(this.configuration).settingUpdateUsingGET(settingId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary songsUpdate
     * @param {number} songId songId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminViewControllerApi
     */
    public songsUpdateUsingGET(songId: number, options?: any) {
        return AdminViewControllerApiFp(this.configuration).songsUpdateUsingGET(songId, options)(this.fetch, this.basePath);
    }

}

/**
 * AdvertiseKeywordControllerApi - fetch parameter creator
 * @export
 */
export const AdvertiseKeywordControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAdvertiseKeyword
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdvertiseKeywordUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/advertise/keywords`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdvertiseKeywordControllerApi - functional programming interface
 * @export
 */
export const AdvertiseKeywordControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAdvertiseKeyword
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdvertiseKeywordUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOListstring> {
            const localVarFetchArgs = AdvertiseKeywordControllerApiFetchParamCreator(configuration).getAdvertiseKeywordUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AdvertiseKeywordControllerApi - factory interface
 * @export
 */
export const AdvertiseKeywordControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getAdvertiseKeyword
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdvertiseKeywordUsingGET(options?: any) {
            return AdvertiseKeywordControllerApiFp(configuration).getAdvertiseKeywordUsingGET(options)(fetch, basePath);
        },
    };
};

/**
 * AdvertiseKeywordControllerApi - object-oriented interface
 * @export
 * @class AdvertiseKeywordControllerApi
 * @extends {BaseAPI}
 */
export class AdvertiseKeywordControllerApi extends BaseAPI {
    /**
     * 
     * @summary getAdvertiseKeyword
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvertiseKeywordControllerApi
     */
    public getAdvertiseKeywordUsingGET(options?: any) {
        return AdvertiseKeywordControllerApiFp(this.configuration).getAdvertiseKeywordUsingGET(options)(this.fetch, this.basePath);
    }

}

/**
 * Class01APIV2Api - fetch parameter creator
 * @export
 */
export const Class01APIV2ApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 시즌 랭킹, 월간 랭킹 부분을 누적하여 저장하는 API. 하위 호환성을 위하여 V2로 분기함.
         * @summary 게임 결과 데이터 가져오는 API
         * @param {GameResultRequest} resultRequest resultRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameResultUsingPOST1(resultRequest: GameResultRequest, options: any = {}): FetchArgs {
            // verify required parameter 'resultRequest' is not null or undefined
            if (resultRequest === null || resultRequest === undefined) {
                throw new RequiredError('resultRequest','Required parameter resultRequest was null or undefined when calling gameResultUsingPOST1.');
            }
            const localVarPath = `/v2/game/result`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GameResultRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(resultRequest || {}) : (resultRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class01APIV2Api - functional programming interface
 * @export
 */
export const Class01APIV2ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 시즌 랭킹, 월간 랭킹 부분을 누적하여 저장하는 API. 하위 호환성을 위하여 V2로 분기함.
         * @summary 게임 결과 데이터 가져오는 API
         * @param {GameResultRequest} resultRequest resultRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameResultUsingPOST1(resultRequest: GameResultRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GameResultResponseV2> {
            const localVarFetchArgs = Class01APIV2ApiFetchParamCreator(configuration).gameResultUsingPOST1(resultRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * Class01APIV2Api - factory interface
 * @export
 */
export const Class01APIV2ApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 시즌 랭킹, 월간 랭킹 부분을 누적하여 저장하는 API. 하위 호환성을 위하여 V2로 분기함.
         * @summary 게임 결과 데이터 가져오는 API
         * @param {GameResultRequest} resultRequest resultRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameResultUsingPOST1(resultRequest: GameResultRequest, options?: any) {
            return Class01APIV2ApiFp(configuration).gameResultUsingPOST1(resultRequest, options)(fetch, basePath);
        },
    };
};

/**
 * Class01APIV2Api - object-oriented interface
 * @export
 * @class Class01APIV2Api
 * @extends {BaseAPI}
 */
export class Class01APIV2Api extends BaseAPI {
    /**
     * 시즌 랭킹, 월간 랭킹 부분을 누적하여 저장하는 API. 하위 호환성을 위하여 V2로 분기함.
     * @summary 게임 결과 데이터 가져오는 API
     * @param {GameResultRequest} resultRequest resultRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class01APIV2Api
     */
    public gameResultUsingPOST1(resultRequest: GameResultRequest, options?: any) {
        return Class01APIV2ApiFp(this.configuration).gameResultUsingPOST1(resultRequest, options)(this.fetch, this.basePath);
    }

}

/**
 * GameControllerApi - fetch parameter creator
 * @export
 */
export const GameControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary gameResult
         * @param {GameResultRequest} resultRequest resultRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameResultUsingPOST(resultRequest: GameResultRequest, options: any = {}): FetchArgs {
            // verify required parameter 'resultRequest' is not null or undefined
            if (resultRequest === null || resultRequest === undefined) {
                throw new RequiredError('resultRequest','Required parameter resultRequest was null or undefined when calling gameResultUsingPOST.');
            }
            const localVarPath = `/game/result`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GameResultRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(resultRequest || {}) : (resultRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getHighlightList
         * @param {GameStartRequest} gameRequest gameRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightListUsingPOST(gameRequest: GameStartRequest, options: any = {}): FetchArgs {
            // verify required parameter 'gameRequest' is not null or undefined
            if (gameRequest === null || gameRequest === undefined) {
                throw new RequiredError('gameRequest','Required parameter gameRequest was null or undefined when calling getHighlightListUsingPOST.');
            }
            const localVarPath = `/game/start`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GameStartRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(gameRequest || {}) : (gameRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary isAnswer
         * @param {GameAnswerCheckRequest} answerCheckRequest answerCheckRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAnswerUsingPOST(answerCheckRequest: GameAnswerCheckRequest, options: any = {}): FetchArgs {
            // verify required parameter 'answerCheckRequest' is not null or undefined
            if (answerCheckRequest === null || answerCheckRequest === undefined) {
                throw new RequiredError('answerCheckRequest','Required parameter answerCheckRequest was null or undefined when calling isAnswerUsingPOST.');
            }
            const localVarPath = `/game/answer`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"GameAnswerCheckRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(answerCheckRequest || {}) : (answerCheckRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary refine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refineUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/game/refine`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GameControllerApi - functional programming interface
 * @export
 */
export const GameControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary gameResult
         * @param {GameResultRequest} resultRequest resultRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameResultUsingPOST(resultRequest: GameResultRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOGameResultResponse> {
            const localVarFetchArgs = GameControllerApiFetchParamCreator(configuration).gameResultUsingPOST(resultRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getHighlightList
         * @param {GameStartRequest} gameRequest gameRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightListUsingPOST(gameRequest: GameStartRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOGameStartResponse> {
            const localVarFetchArgs = GameControllerApiFetchParamCreator(configuration).getHighlightListUsingPOST(gameRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary isAnswer
         * @param {GameAnswerCheckRequest} answerCheckRequest answerCheckRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAnswerUsingPOST(answerCheckRequest: GameAnswerCheckRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOboolean> {
            const localVarFetchArgs = GameControllerApiFetchParamCreator(configuration).isAnswerUsingPOST(answerCheckRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary refine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refineUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = GameControllerApiFetchParamCreator(configuration).refineUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GameControllerApi - factory interface
 * @export
 */
export const GameControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary gameResult
         * @param {GameResultRequest} resultRequest resultRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameResultUsingPOST(resultRequest: GameResultRequest, options?: any) {
            return GameControllerApiFp(configuration).gameResultUsingPOST(resultRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getHighlightList
         * @param {GameStartRequest} gameRequest gameRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightListUsingPOST(gameRequest: GameStartRequest, options?: any) {
            return GameControllerApiFp(configuration).getHighlightListUsingPOST(gameRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary isAnswer
         * @param {GameAnswerCheckRequest} answerCheckRequest answerCheckRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAnswerUsingPOST(answerCheckRequest: GameAnswerCheckRequest, options?: any) {
            return GameControllerApiFp(configuration).isAnswerUsingPOST(answerCheckRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary refine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refineUsingGET(options?: any) {
            return GameControllerApiFp(configuration).refineUsingGET(options)(fetch, basePath);
        },
    };
};

/**
 * GameControllerApi - object-oriented interface
 * @export
 * @class GameControllerApi
 * @extends {BaseAPI}
 */
export class GameControllerApi extends BaseAPI {
    /**
     * 
     * @summary gameResult
     * @param {GameResultRequest} resultRequest resultRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public gameResultUsingPOST(resultRequest: GameResultRequest, options?: any) {
        return GameControllerApiFp(this.configuration).gameResultUsingPOST(resultRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getHighlightList
     * @param {GameStartRequest} gameRequest gameRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public getHighlightListUsingPOST(gameRequest: GameStartRequest, options?: any) {
        return GameControllerApiFp(this.configuration).getHighlightListUsingPOST(gameRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary isAnswer
     * @param {GameAnswerCheckRequest} answerCheckRequest answerCheckRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public isAnswerUsingPOST(answerCheckRequest: GameAnswerCheckRequest, options?: any) {
        return GameControllerApiFp(this.configuration).isAnswerUsingPOST(answerCheckRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary refine
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public refineUsingGET(options?: any) {
        return GameControllerApiFp(this.configuration).refineUsingGET(options)(this.fetch, this.basePath);
    }

}

/**
 * HealthCheckControllerApi - fetch parameter creator
 * @export
 */
export const HealthCheckControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cacheUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/health/cache`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary healthCheck2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck2UsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/health/check`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/health/test`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthCheckControllerApi - functional programming interface
 * @export
 */
export const HealthCheckControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cacheUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = HealthCheckControllerApiFetchParamCreator(configuration).cacheUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary healthCheck2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck2UsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = HealthCheckControllerApiFetchParamCreator(configuration).healthCheck2UsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = HealthCheckControllerApiFetchParamCreator(configuration).testUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HealthCheckControllerApi - factory interface
 * @export
 */
export const HealthCheckControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cacheUsingGET(options?: any) {
            return HealthCheckControllerApiFp(configuration).cacheUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary healthCheck2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck2UsingGET(options?: any) {
            return HealthCheckControllerApiFp(configuration).healthCheck2UsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testUsingGET(options?: any) {
            return HealthCheckControllerApiFp(configuration).testUsingGET(options)(fetch, basePath);
        },
    };
};

/**
 * HealthCheckControllerApi - object-oriented interface
 * @export
 * @class HealthCheckControllerApi
 * @extends {BaseAPI}
 */
export class HealthCheckControllerApi extends BaseAPI {
    /**
     * 
     * @summary cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckControllerApi
     */
    public cacheUsingGET(options?: any) {
        return HealthCheckControllerApiFp(this.configuration).cacheUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary healthCheck2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckControllerApi
     */
    public healthCheck2UsingGET(options?: any) {
        return HealthCheckControllerApiFp(this.configuration).healthCheck2UsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckControllerApi
     */
    public testUsingGET(options?: any) {
        return HealthCheckControllerApiFp(this.configuration).testUsingGET(options)(this.fetch, this.basePath);
    }

}

/**
 * HeartControllerApi - fetch parameter creator
 * @export
 */
export const HeartControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary checkMyHeart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkMyHeartUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/heart/check`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary useHeart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useHeartUsingPUT(options: any = {}): FetchArgs {
            const localVarPath = `/heart/use`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HeartControllerApi - functional programming interface
 * @export
 */
export const HeartControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary checkMyHeart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkMyHeartUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOHeartResponse> {
            const localVarFetchArgs = HeartControllerApiFetchParamCreator(configuration).checkMyHeartUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary useHeart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useHeartUsingPUT(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOHeartResponse> {
            const localVarFetchArgs = HeartControllerApiFetchParamCreator(configuration).useHeartUsingPUT(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HeartControllerApi - factory interface
 * @export
 */
export const HeartControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary checkMyHeart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkMyHeartUsingGET(options?: any) {
            return HeartControllerApiFp(configuration).checkMyHeartUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary useHeart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useHeartUsingPUT(options?: any) {
            return HeartControllerApiFp(configuration).useHeartUsingPUT(options)(fetch, basePath);
        },
    };
};

/**
 * HeartControllerApi - object-oriented interface
 * @export
 * @class HeartControllerApi
 * @extends {BaseAPI}
 */
export class HeartControllerApi extends BaseAPI {
    /**
     * 
     * @summary checkMyHeart
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartControllerApi
     */
    public checkMyHeartUsingGET(options?: any) {
        return HeartControllerApiFp(this.configuration).checkMyHeartUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary useHeart
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartControllerApi
     */
    public useHeartUsingPUT(options?: any) {
        return HeartControllerApiFp(this.configuration).useHeartUsingPUT(options)(this.fetch, this.basePath);
    }

}

/**
 * ItemControllerApi - fetch parameter creator
 * @export
 */
export const ItemControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary findItemAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findItemAllUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/item/all`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 아이템 종류는 SKIP, CHARGE_ALL_HEART 있음. 
         * @summary 아이템 사용하는 컨트롤러
         * @param {ItemUseRequest} itemUseRequest itemUseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useItemUsingPUT(itemUseRequest: ItemUseRequest, options: any = {}): FetchArgs {
            // verify required parameter 'itemUseRequest' is not null or undefined
            if (itemUseRequest === null || itemUseRequest === undefined) {
                throw new RequiredError('itemUseRequest','Required parameter itemUseRequest was null or undefined when calling useItemUsingPUT.');
            }
            const localVarPath = `/item/use`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ItemUseRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(itemUseRequest || {}) : (itemUseRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemControllerApi - functional programming interface
 * @export
 */
export const ItemControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary findItemAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findItemAllUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOListItem> {
            const localVarFetchArgs = ItemControllerApiFetchParamCreator(configuration).findItemAllUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 아이템 종류는 SKIP, CHARGE_ALL_HEART 있음. 
         * @summary 아이템 사용하는 컨트롤러
         * @param {ItemUseRequest} itemUseRequest itemUseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useItemUsingPUT(itemUseRequest: ItemUseRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTO> {
            const localVarFetchArgs = ItemControllerApiFetchParamCreator(configuration).useItemUsingPUT(itemUseRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ItemControllerApi - factory interface
 * @export
 */
export const ItemControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary findItemAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findItemAllUsingGET(options?: any) {
            return ItemControllerApiFp(configuration).findItemAllUsingGET(options)(fetch, basePath);
        },
        /**
         * 아이템 종류는 SKIP, CHARGE_ALL_HEART 있음. 
         * @summary 아이템 사용하는 컨트롤러
         * @param {ItemUseRequest} itemUseRequest itemUseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useItemUsingPUT(itemUseRequest: ItemUseRequest, options?: any) {
            return ItemControllerApiFp(configuration).useItemUsingPUT(itemUseRequest, options)(fetch, basePath);
        },
    };
};

/**
 * ItemControllerApi - object-oriented interface
 * @export
 * @class ItemControllerApi
 * @extends {BaseAPI}
 */
export class ItemControllerApi extends BaseAPI {
    /**
     * 
     * @summary findItemAll
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemControllerApi
     */
    public findItemAllUsingGET(options?: any) {
        return ItemControllerApiFp(this.configuration).findItemAllUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 아이템 종류는 SKIP, CHARGE_ALL_HEART 있음. 
     * @summary 아이템 사용하는 컨트롤러
     * @param {ItemUseRequest} itemUseRequest itemUseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemControllerApi
     */
    public useItemUsingPUT(itemUseRequest: ItemUseRequest, options?: any) {
        return ItemControllerApiFp(this.configuration).useItemUsingPUT(itemUseRequest, options)(this.fetch, this.basePath);
    }

}

/**
 * LikeControllerApi - fetch parameter creator
 * @export
 */
export const LikeControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary dislike
         * @param {LikeRequest} likeRequest likeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dislikeUsingPOST(likeRequest: LikeRequest, options: any = {}): FetchArgs {
            // verify required parameter 'likeRequest' is not null or undefined
            if (likeRequest === null || likeRequest === undefined) {
                throw new RequiredError('likeRequest','Required parameter likeRequest was null or undefined when calling dislikeUsingPOST.');
            }
            const localVarPath = `/dislike`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LikeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(likeRequest || {}) : (likeRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary like
         * @param {LikeRequest} likeRequest likeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeUsingPOST(likeRequest: LikeRequest, options: any = {}): FetchArgs {
            // verify required parameter 'likeRequest' is not null or undefined
            if (likeRequest === null || likeRequest === undefined) {
                throw new RequiredError('likeRequest','Required parameter likeRequest was null or undefined when calling likeUsingPOST.');
            }
            const localVarPath = `/like`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LikeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(likeRequest || {}) : (likeRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LikeControllerApi - functional programming interface
 * @export
 */
export const LikeControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary dislike
         * @param {LikeRequest} likeRequest likeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dislikeUsingPOST(likeRequest: LikeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOLikeResponse> {
            const localVarFetchArgs = LikeControllerApiFetchParamCreator(configuration).dislikeUsingPOST(likeRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary like
         * @param {LikeRequest} likeRequest likeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeUsingPOST(likeRequest: LikeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOLikeResponse> {
            const localVarFetchArgs = LikeControllerApiFetchParamCreator(configuration).likeUsingPOST(likeRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LikeControllerApi - factory interface
 * @export
 */
export const LikeControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary dislike
         * @param {LikeRequest} likeRequest likeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dislikeUsingPOST(likeRequest: LikeRequest, options?: any) {
            return LikeControllerApiFp(configuration).dislikeUsingPOST(likeRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary like
         * @param {LikeRequest} likeRequest likeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeUsingPOST(likeRequest: LikeRequest, options?: any) {
            return LikeControllerApiFp(configuration).likeUsingPOST(likeRequest, options)(fetch, basePath);
        },
    };
};

/**
 * LikeControllerApi - object-oriented interface
 * @export
 * @class LikeControllerApi
 * @extends {BaseAPI}
 */
export class LikeControllerApi extends BaseAPI {
    /**
     * 
     * @summary dislike
     * @param {LikeRequest} likeRequest likeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeControllerApi
     */
    public dislikeUsingPOST(likeRequest: LikeRequest, options?: any) {
        return LikeControllerApiFp(this.configuration).dislikeUsingPOST(likeRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary like
     * @param {LikeRequest} likeRequest likeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeControllerApi
     */
    public likeUsingPOST(likeRequest: LikeRequest, options?: any) {
        return LikeControllerApiFp(this.configuration).likeUsingPOST(likeRequest, options)(this.fetch, this.basePath);
    }

}

/**
 * LikeHistoryControllerApi - fetch parameter creator
 * @export
 */
export const LikeHistoryControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getLikeHistory
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikeHistoryUsingGET(trackId: number, options: any = {}): FetchArgs {
            // verify required parameter 'trackId' is not null or undefined
            if (trackId === null || trackId === undefined) {
                throw new RequiredError('trackId','Required parameter trackId was null or undefined when calling getLikeHistoryUsingGET.');
            }
            const localVarPath = `/history/like/song/{trackId}`
                .replace(`{${"trackId"}}`, encodeURIComponent(String(trackId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserHistory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHistoryUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/history/like/user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LikeHistoryControllerApi - functional programming interface
 * @export
 */
export const LikeHistoryControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getLikeHistory
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikeHistoryUsingGET(trackId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOListUserLikeHistoryResponse> {
            const localVarFetchArgs = LikeHistoryControllerApiFetchParamCreator(configuration).getLikeHistoryUsingGET(trackId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getUserHistory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHistoryUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOListLikeHistoryResponse> {
            const localVarFetchArgs = LikeHistoryControllerApiFetchParamCreator(configuration).getUserHistoryUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LikeHistoryControllerApi - factory interface
 * @export
 */
export const LikeHistoryControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getLikeHistory
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikeHistoryUsingGET(trackId: number, options?: any) {
            return LikeHistoryControllerApiFp(configuration).getLikeHistoryUsingGET(trackId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getUserHistory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHistoryUsingGET(options?: any) {
            return LikeHistoryControllerApiFp(configuration).getUserHistoryUsingGET(options)(fetch, basePath);
        },
    };
};

/**
 * LikeHistoryControllerApi - object-oriented interface
 * @export
 * @class LikeHistoryControllerApi
 * @extends {BaseAPI}
 */
export class LikeHistoryControllerApi extends BaseAPI {
    /**
     * 
     * @summary getLikeHistory
     * @param {number} trackId trackId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeHistoryControllerApi
     */
    public getLikeHistoryUsingGET(trackId: number, options?: any) {
        return LikeHistoryControllerApiFp(this.configuration).getLikeHistoryUsingGET(trackId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getUserHistory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeHistoryControllerApi
     */
    public getUserHistoryUsingGET(options?: any) {
        return LikeHistoryControllerApiFp(this.configuration).getUserHistoryUsingGET(options)(this.fetch, this.basePath);
    }

}

/**
 * MusicUserControllerApi - fetch parameter creator
 * @export
 */
export const MusicUserControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary myInfoChange
         * @param {any} profileImage profileImage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInfoChangeUsingPOST(profileImage: any, options: any = {}): FetchArgs {
            // verify required parameter 'profileImage' is not null or undefined
            if (profileImage === null || profileImage === undefined) {
                throw new RequiredError('profileImage','Required parameter profileImage was null or undefined when calling myInfoChangeUsingPOST.');
            }
            const localVarPath = `/user/profile/dp`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (profileImage !== undefined) {
                localVarFormParams.set('profileImage', profileImage as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary myInfoChange
         * @param {NicknameChangeRequest} nicknameChangeRequest nicknameChangeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInfoChangeUsingPUT(nicknameChangeRequest: NicknameChangeRequest, options: any = {}): FetchArgs {
            // verify required parameter 'nicknameChangeRequest' is not null or undefined
            if (nicknameChangeRequest === null || nicknameChangeRequest === undefined) {
                throw new RequiredError('nicknameChangeRequest','Required parameter nicknameChangeRequest was null or undefined when calling myInfoChangeUsingPUT.');
            }
            const localVarPath = `/user/profile/nickname`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NicknameChangeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(nicknameChangeRequest || {}) : (nicknameChangeRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary refreshToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenUsingPOST(options: any = {}): FetchArgs {
            const localVarPath = `/user/login/refresh`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary secedeSelf
         * @param {string} password password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secedeSelfUsingDELETE(password: string, options: any = {}): FetchArgs {
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling secedeSelfUsingDELETE.');
            }
            const localVarPath = `/user/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(password || {}) : (password || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary signIn
         * @param {UserLoginRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInUsingPOST(request: UserLoginRequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling signInUsingPOST.');
            }
            const localVarPath = `/user/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserLoginRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary signUp
         * @param {UserSignUpRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpUsingPOST(request: UserSignUpRequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling signUpUsingPOST.');
            }
            const localVarPath = `/user/signup`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserSignUpRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MusicUserControllerApi - functional programming interface
 * @export
 */
export const MusicUserControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary myInfoChange
         * @param {any} profileImage profileImage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInfoChangeUsingPOST(profileImage: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOstring> {
            const localVarFetchArgs = MusicUserControllerApiFetchParamCreator(configuration).myInfoChangeUsingPOST(profileImage, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary myInfoChange
         * @param {NicknameChangeRequest} nicknameChangeRequest nicknameChangeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInfoChangeUsingPUT(nicknameChangeRequest: NicknameChangeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOboolean> {
            const localVarFetchArgs = MusicUserControllerApiFetchParamCreator(configuration).myInfoChangeUsingPUT(nicknameChangeRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary refreshToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenUsingPOST(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOstring> {
            const localVarFetchArgs = MusicUserControllerApiFetchParamCreator(configuration).refreshTokenUsingPOST(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary secedeSelf
         * @param {string} password password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secedeSelfUsingDELETE(password: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOstring> {
            const localVarFetchArgs = MusicUserControllerApiFetchParamCreator(configuration).secedeSelfUsingDELETE(password, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary signIn
         * @param {UserLoginRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInUsingPOST(request: UserLoginRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOLoggedInMusicUser> {
            const localVarFetchArgs = MusicUserControllerApiFetchParamCreator(configuration).signInUsingPOST(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary signUp
         * @param {UserSignUpRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpUsingPOST(request: UserSignUpRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTO> {
            const localVarFetchArgs = MusicUserControllerApiFetchParamCreator(configuration).signUpUsingPOST(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MusicUserControllerApi - factory interface
 * @export
 */
export const MusicUserControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary myInfoChange
         * @param {any} profileImage profileImage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInfoChangeUsingPOST(profileImage: any, options?: any) {
            return MusicUserControllerApiFp(configuration).myInfoChangeUsingPOST(profileImage, options)(fetch, basePath);
        },
        /**
         * 
         * @summary myInfoChange
         * @param {NicknameChangeRequest} nicknameChangeRequest nicknameChangeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInfoChangeUsingPUT(nicknameChangeRequest: NicknameChangeRequest, options?: any) {
            return MusicUserControllerApiFp(configuration).myInfoChangeUsingPUT(nicknameChangeRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary refreshToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenUsingPOST(options?: any) {
            return MusicUserControllerApiFp(configuration).refreshTokenUsingPOST(options)(fetch, basePath);
        },
        /**
         * 
         * @summary secedeSelf
         * @param {string} password password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secedeSelfUsingDELETE(password: string, options?: any) {
            return MusicUserControllerApiFp(configuration).secedeSelfUsingDELETE(password, options)(fetch, basePath);
        },
        /**
         * 
         * @summary signIn
         * @param {UserLoginRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInUsingPOST(request: UserLoginRequest, options?: any) {
            return MusicUserControllerApiFp(configuration).signInUsingPOST(request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary signUp
         * @param {UserSignUpRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpUsingPOST(request: UserSignUpRequest, options?: any) {
            return MusicUserControllerApiFp(configuration).signUpUsingPOST(request, options)(fetch, basePath);
        },
    };
};

/**
 * MusicUserControllerApi - object-oriented interface
 * @export
 * @class MusicUserControllerApi
 * @extends {BaseAPI}
 */
export class MusicUserControllerApi extends BaseAPI {
    /**
     * 
     * @summary myInfoChange
     * @param {any} profileImage profileImage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public myInfoChangeUsingPOST(profileImage: any, options?: any) {
        return MusicUserControllerApiFp(this.configuration).myInfoChangeUsingPOST(profileImage, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary myInfoChange
     * @param {NicknameChangeRequest} nicknameChangeRequest nicknameChangeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public myInfoChangeUsingPUT(nicknameChangeRequest: NicknameChangeRequest, options?: any) {
        return MusicUserControllerApiFp(this.configuration).myInfoChangeUsingPUT(nicknameChangeRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary refreshToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public refreshTokenUsingPOST(options?: any) {
        return MusicUserControllerApiFp(this.configuration).refreshTokenUsingPOST(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary secedeSelf
     * @param {string} password password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public secedeSelfUsingDELETE(password: string, options?: any) {
        return MusicUserControllerApiFp(this.configuration).secedeSelfUsingDELETE(password, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary signIn
     * @param {UserLoginRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public signInUsingPOST(request: UserLoginRequest, options?: any) {
        return MusicUserControllerApiFp(this.configuration).signInUsingPOST(request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary signUp
     * @param {UserSignUpRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public signUpUsingPOST(request: UserSignUpRequest, options?: any) {
        return MusicUserControllerApiFp(this.configuration).signUpUsingPOST(request, options)(this.fetch, this.basePath);
    }

}

/**
 * RankingControllerApi - fetch parameter creator
 * @export
 */
export const RankingControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getRankingInfoOfMonths
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoOfMonthsUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/rank/month`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getRankingInfoOfSeason
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoOfSeasonUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/rank/season`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getRankingInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/rank/list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RankingControllerApi - functional programming interface
 * @export
 */
export const RankingControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getRankingInfoOfMonths
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoOfMonthsUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTORankViewModel> {
            const localVarFetchArgs = RankingControllerApiFetchParamCreator(configuration).getRankingInfoOfMonthsUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getRankingInfoOfSeason
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoOfSeasonUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTORankViewModel> {
            const localVarFetchArgs = RankingControllerApiFetchParamCreator(configuration).getRankingInfoOfSeasonUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getRankingInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTORankViewModel> {
            const localVarFetchArgs = RankingControllerApiFetchParamCreator(configuration).getRankingInfoUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RankingControllerApi - factory interface
 * @export
 */
export const RankingControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getRankingInfoOfMonths
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoOfMonthsUsingGET(options?: any) {
            return RankingControllerApiFp(configuration).getRankingInfoOfMonthsUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getRankingInfoOfSeason
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoOfSeasonUsingGET(options?: any) {
            return RankingControllerApiFp(configuration).getRankingInfoOfSeasonUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getRankingInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoUsingGET(options?: any) {
            return RankingControllerApiFp(configuration).getRankingInfoUsingGET(options)(fetch, basePath);
        },
    };
};

/**
 * RankingControllerApi - object-oriented interface
 * @export
 * @class RankingControllerApi
 * @extends {BaseAPI}
 */
export class RankingControllerApi extends BaseAPI {
    /**
     * 
     * @summary getRankingInfoOfMonths
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankingControllerApi
     */
    public getRankingInfoOfMonthsUsingGET(options?: any) {
        return RankingControllerApiFp(this.configuration).getRankingInfoOfMonthsUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getRankingInfoOfSeason
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankingControllerApi
     */
    public getRankingInfoOfSeasonUsingGET(options?: any) {
        return RankingControllerApiFp(this.configuration).getRankingInfoOfSeasonUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getRankingInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankingControllerApi
     */
    public getRankingInfoUsingGET(options?: any) {
        return RankingControllerApiFp(this.configuration).getRankingInfoUsingGET(options)(this.fetch, this.basePath);
    }

}

/**
 * RewardControllerApi - fetch parameter creator
 * @export
 */
export const RewardControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * type 광고 시청 : 'ad_movie', 노래 추천 : 'suggest_music'
         * @summary rewardHeart
         * @param {string} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewardForWatchingAdUsingPOST(type: string, options: any = {}): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling rewardForWatchingAdUsingPOST.');
            }
            const localVarPath = `/reward/types/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RewardControllerApi - functional programming interface
 * @export
 */
export const RewardControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * type 광고 시청 : 'ad_movie', 노래 추천 : 'suggest_music'
         * @summary rewardHeart
         * @param {string} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewardForWatchingAdUsingPOST(type: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOReward> {
            const localVarFetchArgs = RewardControllerApiFetchParamCreator(configuration).rewardForWatchingAdUsingPOST(type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RewardControllerApi - factory interface
 * @export
 */
export const RewardControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * type 광고 시청 : 'ad_movie', 노래 추천 : 'suggest_music'
         * @summary rewardHeart
         * @param {string} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewardForWatchingAdUsingPOST(type: string, options?: any) {
            return RewardControllerApiFp(configuration).rewardForWatchingAdUsingPOST(type, options)(fetch, basePath);
        },
    };
};

/**
 * RewardControllerApi - object-oriented interface
 * @export
 * @class RewardControllerApi
 * @extends {BaseAPI}
 */
export class RewardControllerApi extends BaseAPI {
    /**
     * type 광고 시청 : 'ad_movie', 노래 추천 : 'suggest_music'
     * @summary rewardHeart
     * @param {string} type type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardControllerApi
     */
    public rewardForWatchingAdUsingPOST(type: string, options?: any) {
        return RewardControllerApiFp(this.configuration).rewardForWatchingAdUsingPOST(type, options)(this.fetch, this.basePath);
    }

}

/**
 * SingerControllerApi - fetch parameter creator
 * @export
 */
export const SingerControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAllRegisteredSingerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRegisteredSingerNameUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/singer/registered`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllSingerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSingerNameUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/singer/all`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllSongsBySingerName
         * @param {number} page page
         * @param {string} singerName singerName
         * @param {number} size size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSongsBySingerNameUsingGET(page: number, singerName: string, size: number, options: any = {}): FetchArgs {
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getAllSongsBySingerNameUsingGET.');
            }
            // verify required parameter 'singerName' is not null or undefined
            if (singerName === null || singerName === undefined) {
                throw new RequiredError('singerName','Required parameter singerName was null or undefined when calling getAllSongsBySingerNameUsingGET.');
            }
            // verify required parameter 'size' is not null or undefined
            if (size === null || size === undefined) {
                throw new RequiredError('size','Required parameter size was null or undefined when calling getAllSongsBySingerNameUsingGET.');
            }
            const localVarPath = `/singer/songs`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (singerName !== undefined) {
                localVarQueryParameter['singerName'] = singerName;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllStandardSingerList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllStandardSingerListUsingGET(options: any = {}): FetchArgs {
            const localVarPath = `/singer/standard-list`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTrackListBySingerName
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackListBySingerNameUsingGET(name: string, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getTrackListBySingerNameUsingGET.');
            }
            const localVarPath = `/singer/names/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SingerControllerApi - functional programming interface
 * @export
 */
export const SingerControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAllRegisteredSingerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRegisteredSingerNameUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOListSinger> {
            const localVarFetchArgs = SingerControllerApiFetchParamCreator(configuration).getAllRegisteredSingerNameUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAllSingerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSingerNameUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOSetstring> {
            const localVarFetchArgs = SingerControllerApiFetchParamCreator(configuration).getAllSingerNameUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAllSongsBySingerName
         * @param {number} page page
         * @param {string} singerName singerName
         * @param {number} size size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSongsBySingerNameUsingGET(page: number, singerName: string, size: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOPageSongResponse> {
            const localVarFetchArgs = SingerControllerApiFetchParamCreator(configuration).getAllSongsBySingerNameUsingGET(page, singerName, size, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getAllStandardSingerList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllStandardSingerListUsingGET(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOListSinger> {
            const localVarFetchArgs = SingerControllerApiFetchParamCreator(configuration).getAllStandardSingerListUsingGET(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getTrackListBySingerName
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackListBySingerNameUsingGET(name: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Track>> {
            const localVarFetchArgs = SingerControllerApiFetchParamCreator(configuration).getTrackListBySingerNameUsingGET(name, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SingerControllerApi - factory interface
 * @export
 */
export const SingerControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary getAllRegisteredSingerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRegisteredSingerNameUsingGET(options?: any) {
            return SingerControllerApiFp(configuration).getAllRegisteredSingerNameUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAllSingerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSingerNameUsingGET(options?: any) {
            return SingerControllerApiFp(configuration).getAllSingerNameUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAllSongsBySingerName
         * @param {number} page page
         * @param {string} singerName singerName
         * @param {number} size size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSongsBySingerNameUsingGET(page: number, singerName: string, size: number, options?: any) {
            return SingerControllerApiFp(configuration).getAllSongsBySingerNameUsingGET(page, singerName, size, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getAllStandardSingerList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllStandardSingerListUsingGET(options?: any) {
            return SingerControllerApiFp(configuration).getAllStandardSingerListUsingGET(options)(fetch, basePath);
        },
        /**
         * 
         * @summary getTrackListBySingerName
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackListBySingerNameUsingGET(name: string, options?: any) {
            return SingerControllerApiFp(configuration).getTrackListBySingerNameUsingGET(name, options)(fetch, basePath);
        },
    };
};

/**
 * SingerControllerApi - object-oriented interface
 * @export
 * @class SingerControllerApi
 * @extends {BaseAPI}
 */
export class SingerControllerApi extends BaseAPI {
    /**
     * 
     * @summary getAllRegisteredSingerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingerControllerApi
     */
    public getAllRegisteredSingerNameUsingGET(options?: any) {
        return SingerControllerApiFp(this.configuration).getAllRegisteredSingerNameUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAllSingerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingerControllerApi
     */
    public getAllSingerNameUsingGET(options?: any) {
        return SingerControllerApiFp(this.configuration).getAllSingerNameUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAllSongsBySingerName
     * @param {number} page page
     * @param {string} singerName singerName
     * @param {number} size size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingerControllerApi
     */
    public getAllSongsBySingerNameUsingGET(page: number, singerName: string, size: number, options?: any) {
        return SingerControllerApiFp(this.configuration).getAllSongsBySingerNameUsingGET(page, singerName, size, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getAllStandardSingerList
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingerControllerApi
     */
    public getAllStandardSingerListUsingGET(options?: any) {
        return SingerControllerApiFp(this.configuration).getAllStandardSingerListUsingGET(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getTrackListBySingerName
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingerControllerApi
     */
    public getTrackListBySingerNameUsingGET(name: string, options?: any) {
        return SingerControllerApiFp(this.configuration).getTrackListBySingerNameUsingGET(name, options)(this.fetch, this.basePath);
    }

}

/**
 * SongControllerApi - fetch parameter creator
 * @export
 */
export const SongControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addNewSong
         * @param {SongRegisterRequest} registerRequest registerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewSongUsingPOST(registerRequest: SongRegisterRequest, options: any = {}): FetchArgs {
            // verify required parameter 'registerRequest' is not null or undefined
            if (registerRequest === null || registerRequest === undefined) {
                throw new RequiredError('registerRequest','Required parameter registerRequest was null or undefined when calling addNewSongUsingPOST.');
            }
            const localVarPath = `/song/new`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SongRegisterRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(registerRequest || {}) : (registerRequest || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getSong
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSongUsingGET(trackId: number, options: any = {}): FetchArgs {
            // verify required parameter 'trackId' is not null or undefined
            if (trackId === null || trackId === undefined) {
                throw new RequiredError('trackId','Required parameter trackId was null or undefined when calling getSongUsingGET.');
            }
            const localVarPath = `/song/{trackId}`
                .replace(`{${"trackId"}}`, encodeURIComponent(String(trackId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongControllerApi - functional programming interface
 * @export
 */
export const SongControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addNewSong
         * @param {SongRegisterRequest} registerRequest registerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewSongUsingPOST(registerRequest: SongRegisterRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOSong> {
            const localVarFetchArgs = SongControllerApiFetchParamCreator(configuration).addNewSongUsingPOST(registerRequest, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary getSong
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSongUsingGET(trackId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOSong> {
            const localVarFetchArgs = SongControllerApiFetchParamCreator(configuration).getSongUsingGET(trackId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SongControllerApi - factory interface
 * @export
 */
export const SongControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary addNewSong
         * @param {SongRegisterRequest} registerRequest registerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewSongUsingPOST(registerRequest: SongRegisterRequest, options?: any) {
            return SongControllerApiFp(configuration).addNewSongUsingPOST(registerRequest, options)(fetch, basePath);
        },
        /**
         * 
         * @summary getSong
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSongUsingGET(trackId: number, options?: any) {
            return SongControllerApiFp(configuration).getSongUsingGET(trackId, options)(fetch, basePath);
        },
    };
};

/**
 * SongControllerApi - object-oriented interface
 * @export
 * @class SongControllerApi
 * @extends {BaseAPI}
 */
export class SongControllerApi extends BaseAPI {
    /**
     * 
     * @summary addNewSong
     * @param {SongRegisterRequest} registerRequest registerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongControllerApi
     */
    public addNewSongUsingPOST(registerRequest: SongRegisterRequest, options?: any) {
        return SongControllerApiFp(this.configuration).addNewSongUsingPOST(registerRequest, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary getSong
     * @param {number} trackId trackId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongControllerApi
     */
    public getSongUsingGET(trackId: number, options?: any) {
        return SongControllerApiFp(this.configuration).getSongUsingGET(trackId, options)(this.fetch, this.basePath);
    }

}

/**
 * SongHighlightControllerApi - fetch parameter creator
 * @export
 */
export const SongHighlightControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addSongHighlight
         * @param {SongHighlightAddRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSongHighlightUsingPOST(request: SongHighlightAddRequest, options: any = {}): FetchArgs {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling addSongHighlightUsingPOST.');
            }
            const localVarPath = `/highlight/new`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SongHighlightAddRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary makeHighlight
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeHighlightUsingPOST(trackId: number, options: any = {}): FetchArgs {
            // verify required parameter 'trackId' is not null or undefined
            if (trackId === null || trackId === undefined) {
                throw new RequiredError('trackId','Required parameter trackId was null or undefined when calling makeHighlightUsingPOST.');
            }
            const localVarPath = `/highlight/{trackId}`
                .replace(`{${"trackId"}}`, encodeURIComponent(String(trackId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongHighlightControllerApi - functional programming interface
 * @export
 */
export const SongHighlightControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addSongHighlight
         * @param {SongHighlightAddRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSongHighlightUsingPOST(request: SongHighlightAddRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOSong> {
            const localVarFetchArgs = SongHighlightControllerApiFetchParamCreator(configuration).addSongHighlightUsingPOST(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary makeHighlight
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeHighlightUsingPOST(trackId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOSong> {
            const localVarFetchArgs = SongHighlightControllerApiFetchParamCreator(configuration).makeHighlightUsingPOST(trackId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SongHighlightControllerApi - factory interface
 * @export
 */
export const SongHighlightControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary addSongHighlight
         * @param {SongHighlightAddRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSongHighlightUsingPOST(request: SongHighlightAddRequest, options?: any) {
            return SongHighlightControllerApiFp(configuration).addSongHighlightUsingPOST(request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary makeHighlight
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeHighlightUsingPOST(trackId: number, options?: any) {
            return SongHighlightControllerApiFp(configuration).makeHighlightUsingPOST(trackId, options)(fetch, basePath);
        },
    };
};

/**
 * SongHighlightControllerApi - object-oriented interface
 * @export
 * @class SongHighlightControllerApi
 * @extends {BaseAPI}
 */
export class SongHighlightControllerApi extends BaseAPI {
    /**
     * 
     * @summary addSongHighlight
     * @param {SongHighlightAddRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongHighlightControllerApi
     */
    public addSongHighlightUsingPOST(request: SongHighlightAddRequest, options?: any) {
        return SongHighlightControllerApiFp(this.configuration).addSongHighlightUsingPOST(request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary makeHighlight
     * @param {number} trackId trackId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongHighlightControllerApi
     */
    public makeHighlightUsingPOST(trackId: number, options?: any) {
        return SongHighlightControllerApiFp(this.configuration).makeHighlightUsingPOST(trackId, options)(this.fetch, this.basePath);
    }

}

/**
 * VersioningControllerApi - fetch parameter creator
 * @export
 */
export const VersioningControllerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary isNeedForceUpdate
         * @param {string} os os
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isNeedForceUpdateUsingGET(os: string, version: string, options: any = {}): FetchArgs {
            // verify required parameter 'os' is not null or undefined
            if (os === null || os === undefined) {
                throw new RequiredError('os','Required parameter os was null or undefined when calling isNeedForceUpdateUsingGET.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling isNeedForceUpdateUsingGET.');
            }
            const localVarPath = `/versioning/os/{os}/version/{version}`
                .replace(`{${"os"}}`, encodeURIComponent(String(os)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersioningControllerApi - functional programming interface
 * @export
 */
export const VersioningControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary isNeedForceUpdate
         * @param {string} os os
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isNeedForceUpdateUsingGET(os: string, version: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseDTOboolean> {
            const localVarFetchArgs = VersioningControllerApiFetchParamCreator(configuration).isNeedForceUpdateUsingGET(os, version, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VersioningControllerApi - factory interface
 * @export
 */
export const VersioningControllerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary isNeedForceUpdate
         * @param {string} os os
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isNeedForceUpdateUsingGET(os: string, version: string, options?: any) {
            return VersioningControllerApiFp(configuration).isNeedForceUpdateUsingGET(os, version, options)(fetch, basePath);
        },
    };
};

/**
 * VersioningControllerApi - object-oriented interface
 * @export
 * @class VersioningControllerApi
 * @extends {BaseAPI}
 */
export class VersioningControllerApi extends BaseAPI {
    /**
     * 
     * @summary isNeedForceUpdate
     * @param {string} os os
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersioningControllerApi
     */
    public isNeedForceUpdateUsingGET(os: string, version: string, options?: any) {
        return VersioningControllerApiFp(this.configuration).isNeedForceUpdateUsingGET(os, version, options)(this.fetch, this.basePath);
    }

}

