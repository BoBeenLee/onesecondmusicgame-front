// tslint:disable
/**
 * 알쏭달쏭 API
 * 알쏠달쏭 API 명세
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AbstractScore
 */
export interface AbstractScore {
    /**
     * 
     * @type {number}
     * @memberof AbstractScore
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof AbstractScore
     */
    point?: number;
}
/**
 * 
 * @export
 * @interface AdminRequest
 */
export interface AdminRequest {
    /**
     * 
     * @type {string}
     * @memberof AdminRequest
     */
    setting?: AdminRequestSettingEnum;
    /**
     * 
     * @type {number}
     * @memberof AdminRequest
     */
    value?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum AdminRequestSettingEnum {
    REWARDCOOLDOWNWATCHMOVIEDURATIONMINS = 'REWARD_COOLDOWN_WATCH_MOVIE_DURATION_MINS',
    POINTOFONEGAME = 'POINT_OF_ONE_GAME',
    MAXNUMOFSINGERPERGAME = 'MAX_NUM_OF_SINGER_PER_GAME',
    DEFAULTMAXHEARTCOUNT = 'DEFAULT_MAX_HEART_COUNT'
}

/**
 * 
 * @export
 * @interface AdminSetting
 */
export interface AdminSetting {
    /**
     * 
     * @type {number}
     * @memberof AdminSetting
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof AdminSetting
     */
    setting?: AdminSettingSettingEnum;
    /**
     * 
     * @type {number}
     * @memberof AdminSetting
     */
    value?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum AdminSettingSettingEnum {
    REWARDCOOLDOWNWATCHMOVIEDURATIONMINS = 'REWARD_COOLDOWN_WATCH_MOVIE_DURATION_MINS',
    POINTOFONEGAME = 'POINT_OF_ONE_GAME',
    MAXNUMOFSINGERPERGAME = 'MAX_NUM_OF_SINGER_PER_GAME',
    DEFAULTMAXHEARTCOUNT = 'DEFAULT_MAX_HEART_COUNT'
}

/**
 * 가수의 앨범 or 노래 커버 이미지 URL을 변경할 때 사용한다.
 * @export
 * @interface ArtworkUrlUpdateRequest
 */
export interface ArtworkUrlUpdateRequest {
    /**
     * 변경할 이미지 URL
     * @type {string}
     * @memberof ArtworkUrlUpdateRequest
     */
    artworkUrl?: string;
}
/**
 * 사용자가 1개의 문제를 풀었을 때 1개의 GameAnswer 객체를 제출해야 한다.
 * @export
 * @interface GameAnswer
 */
export interface GameAnswer {
    /**
     * 사용자가 입력한 정답.
     * @type {string}
     * @memberof GameAnswer
     */
    answer?: string;
    /**
     * (기억이 잘 안나지만) 문제에 해당하는 highlightId
     * @type {number}
     * @memberof GameAnswer
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface GameAnswerCheckRequest
 */
export interface GameAnswerCheckRequest {
    /**
     * 
     * @type {string}
     * @memberof GameAnswerCheckRequest
     */
    answer?: string;
    /**
     * 
     * @type {string}
     * @memberof GameAnswerCheckRequest
     */
    playToken?: string;
    /**
     * 
     * @type {number}
     * @memberof GameAnswerCheckRequest
     */
    trackId?: number;
}
/**
 * 
 * @export
 * @interface GamePlayHighlightDTO
 */
export interface GamePlayHighlightDTO {
    /**
     * 
     * @type {string}
     * @memberof GamePlayHighlightDTO
     */
    artworkUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof GamePlayHighlightDTO
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof GamePlayHighlightDTO
     */
    millisecond?: number;
    /**
     * 
     * @type {string}
     * @memberof GamePlayHighlightDTO
     */
    progressiveUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof GamePlayHighlightDTO
     */
    singer?: string;
    /**
     * 
     * @type {string}
     * @memberof GamePlayHighlightDTO
     */
    title?: string;
    /**
     * 
     * @type {number}
     * @memberof GamePlayHighlightDTO
     */
    trackId?: number;
}
/**
 * 
 * @export
 * @interface GamePlayLogResponse
 */
export interface GamePlayLogResponse {
    /**
     * 
     * @type {string}
     * @memberof GamePlayLogResponse
     */
    createdAt?: string;
    /**
     * 
     * @type {number}
     * @memberof GamePlayLogResponse
     */
    gainPointOfThisGame?: number;
    /**
     * 
     * @type {string}
     * @memberof GamePlayLogResponse
     */
    gameLevelType?: string;
    /**
     * 
     * @type {Array<SongHighlightDTO>}
     * @memberof GamePlayLogResponse
     */
    songHighlightList?: Array<SongHighlightDTO>;
}
/**
 * 게임 종료 시 정답 유무를 채점하기 위하여 사용되는 정보
 * @export
 * @interface GameResultRequest
 */
export interface GameResultRequest {
    /**
     * 사용자가 입력한 정답 리스트
     * @type {Array<GameAnswer>}
     * @memberof GameResultRequest
     */
    gameAnswerList?: Array<GameAnswer>;
    /**
     * 게임 시작 시 발급받은 playToken
     * @type {string}
     * @memberof GameResultRequest
     */
    playToken?: string;
}
/**
 * 
 * @export
 * @interface GameResultResponse
 */
export interface GameResultResponse {
    /**
     * 
     * @type {number}
     * @memberof GameResultResponse
     */
    gainPointOfThisGame?: number;
    /**
     * 
     * @type {number}
     * @memberof GameResultResponse
     */
    heartCount?: number;
    /**
     * 
     * @type {number}
     * @memberof GameResultResponse
     */
    myRanking?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof GameResultResponse
     */
    resultComment?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof GameResultResponse
     */
    totalPoint?: number;
}
/**
 * 게임 결과
 * @export
 * @interface GameResultResponseV2
 */
export interface GameResultResponseV2 {
    /**
     * 이번판으로 휙득한 게임 점수.
     * @type {number}
     * @memberof GameResultResponseV2
     */
    gainPointOfThisGame?: number;
    /**
     * 남은 하트 갯수
     * @type {number}
     * @memberof GameResultResponseV2
     */
    heartCount?: number;
    /**
     * 게임 종료 후 결과 화면에 노출되는 2줄짜리 코멘트
     * @type {Array<string>}
     * @memberof GameResultResponseV2
     */
    resultComment?: Array<string>;
    /**
     * 각 시즌에 대한 랭킹/점수 포인트
     * @type {Array<ScoreViewModel>}
     * @memberof GameResultResponseV2
     */
    scoreViewModelList?: Array<ScoreViewModel>;
}
/**
 * 
 * @export
 * @interface GameStartRequest
 */
export interface GameStartRequest {
    /**
     * 
     * @type {number}
     * @memberof GameStartRequest
     */
    numOfHighlightPerGame?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof GameStartRequest
     */
    singerList?: Array<string>;
}
/**
 * 
 * @export
 * @interface GameStartResponse
 */
export interface GameStartResponse {
    /**
     * 
     * @type {Array<GamePlayHighlightDTO>}
     * @memberof GameStartResponse
     */
    playHighlightList?: Array<GamePlayHighlightDTO>;
    /**
     * 
     * @type {string}
     * @memberof GameStartResponse
     */
    playToken?: string;
}
/**
 * 
 * @export
 * @interface HeartResponse
 */
export interface HeartResponse {
    /**
     * 
     * @type {number}
     * @memberof HeartResponse
     */
    heartCount?: number;
    /**
     * 
     * @type {number}
     * @memberof HeartResponse
     */
    leftTime?: number;
}
/**
 * 
 * @export
 * @interface HighlightUpdateOrCreateRequest
 */
export interface HighlightUpdateOrCreateRequest {
    /**
     * 문제로 출제되고 있는 하이라이트인지 유무
     * @type {boolean}
     * @memberof HighlightUpdateOrCreateRequest
     */
    elected?: boolean;
    /**
     * 문제로 나오고 있는 시작 밀리세컨드( 시스템 로직 상 20초 이상만 저장이 가능함. )
     * @type {number}
     * @memberof HighlightUpdateOrCreateRequest
     */
    millisecond?: number;
}
/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    itemType?: ItemItemTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ItemItemTypeEnum {
    SKIP = 'SKIP',
    CHARGEALLHEART = 'CHARGE_ALL_HEART'
}

/**
 * 
 * @export
 * @interface ItemCountInfo
 */
export interface ItemCountInfo {
    /**
     * 
     * @type {number}
     * @memberof ItemCountInfo
     */
    heartCount?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemCountInfo
     */
    skipCount?: number;
}
/**
 * 
 * @export
 * @interface ItemUpdateRequest
 */
export interface ItemUpdateRequest {
    /**
     * 
     * @type {number}
     * @memberof ItemUpdateRequest
     */
    heartCount?: number;
    /**
     * 
     * @type {string}
     * @memberof ItemUpdateRequest
     */
    nickname?: string;
    /**
     * 
     * @type {number}
     * @memberof ItemUpdateRequest
     */
    skipCount?: number;
}
/**
 * 
 * @export
 * @interface ItemUseRequest
 */
export interface ItemUseRequest {
    /**
     * 
     * @type {number}
     * @memberof ItemUseRequest
     */
    highlightId?: number;
    /**
     * 
     * @type {string}
     * @memberof ItemUseRequest
     */
    playToken?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemUseRequest
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface Like
 */
export interface Like {
    /**
     * 
     * @type {number}
     * @memberof Like
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof Like
     */
    id?: number;
    /**
     * 
     * @type {Song}
     * @memberof Like
     */
    song?: Song;
}
/**
 * 
 * @export
 * @interface LikeHistoryResponse
 */
export interface LikeHistoryResponse {
    /**
     * 
     * @type {string}
     * @memberof LikeHistoryResponse
     */
    artworkUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof LikeHistoryResponse
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof LikeHistoryResponse
     */
    singer?: string;
    /**
     * 
     * @type {string}
     * @memberof LikeHistoryResponse
     */
    title?: string;
    /**
     * 
     * @type {number}
     * @memberof LikeHistoryResponse
     */
    trackId?: number;
}
/**
 * 
 * @export
 * @interface LikeRequest
 */
export interface LikeRequest {
    /**
     * 
     * @type {string}
     * @memberof LikeRequest
     */
    singerName?: string;
    /**
     * 
     * @type {string}
     * @memberof LikeRequest
     */
    songUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof LikeRequest
     */
    trackId?: number;
}
/**
 * 
 * @export
 * @interface LikeResponse
 */
export interface LikeResponse {
    /**
     * 
     * @type {number}
     * @memberof LikeResponse
     */
    count?: number;
    /**
     * 
     * @type {number}
     * @memberof LikeResponse
     */
    trackId?: number;
}
/**
 * 
 * @export
 * @interface LoggedInMusicUser
 */
export interface LoggedInMusicUser {
    /**
     * 
     * @type {number}
     * @memberof LoggedInMusicUser
     */
    accessTime?: number;
    /**
     * 
     * @type {string}
     * @memberof LoggedInMusicUser
     */
    clientId?: string;
    /**
     * 
     * @type {string}
     * @memberof LoggedInMusicUser
     */
    nickname?: string;
    /**
     * 
     * @type {string}
     * @memberof LoggedInMusicUser
     */
    profileImageUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof LoggedInMusicUser
     */
    token?: string;
}
/**
 * 
 * @export
 * @interface MusicUser
 */
export interface MusicUser {
    /**
     * 
     * @type {number}
     * @memberof MusicUser
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof MusicUser
     */
    nickname?: string;
    /**
     * 
     * @type {string}
     * @memberof MusicUser
     */
    profileDisplayPhotoFileName?: string;
    /**
     * 
     * @type {string}
     * @memberof MusicUser
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof MusicUser
     */
    socialType?: string;
}
/**
 * 
 * @export
 * @interface NicknameChangeRequest
 */
export interface NicknameChangeRequest {
    /**
     * 
     * @type {string}
     * @memberof NicknameChangeRequest
     */
    newNickname?: string;
}
/**
 * 
 * @export
 * @interface PageSongResponse
 */
export interface PageSongResponse {
    /**
     * 
     * @type {Array<SongResponse>}
     * @memberof PageSongResponse
     */
    content?: Array<SongResponse>;
    /**
     * 
     * @type {boolean}
     * @memberof PageSongResponse
     */
    empty?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageSongResponse
     */
    first?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageSongResponse
     */
    last?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageSongResponse
     */
    number?: number;
    /**
     * 
     * @type {number}
     * @memberof PageSongResponse
     */
    numberOfElements?: number;
    /**
     * 
     * @type {Pageable}
     * @memberof PageSongResponse
     */
    pageable?: Pageable;
    /**
     * 
     * @type {number}
     * @memberof PageSongResponse
     */
    size?: number;
    /**
     * 
     * @type {Sort}
     * @memberof PageSongResponse
     */
    sort?: Sort;
    /**
     * 
     * @type {number}
     * @memberof PageSongResponse
     */
    totalElements?: number;
    /**
     * 
     * @type {number}
     * @memberof PageSongResponse
     */
    totalPages?: number;
}
/**
 * 
 * @export
 * @interface Pageable
 */
export interface Pageable {
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    offset?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    pageNumber?: number;
    /**
     * 
     * @type {number}
     * @memberof Pageable
     */
    pageSize?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Pageable
     */
    paged?: boolean;
    /**
     * 
     * @type {Sort}
     * @memberof Pageable
     */
    sort?: Sort;
    /**
     * 
     * @type {boolean}
     * @memberof Pageable
     */
    unpaged?: boolean;
}
/**
 * 
 * @export
 * @interface RankView
 */
export interface RankView {
    /**
     * 
     * @type {string}
     * @memberof RankView
     */
    nickname?: string;
    /**
     * 
     * @type {number}
     * @memberof RankView
     */
    point?: number;
    /**
     * 
     * @type {string}
     * @memberof RankView
     */
    profileImageUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof RankView
     */
    rankDiff?: number;
}
/**
 * 
 * @export
 * @interface RankViewModel
 */
export interface RankViewModel {
    /**
     * 
     * @type {Array<RankView>}
     * @memberof RankViewModel
     */
    rankViewList?: Array<RankView>;
    /**
     * 
     * @type {number}
     * @memberof RankViewModel
     */
    time?: number;
}
/**
 * 
 * @export
 * @interface ResponseBodyWrapperListstring
 */
export interface ResponseBodyWrapperListstring {
    /**
     * 응답 실패 사유
     * @type {string}
     * @memberof ResponseBodyWrapperListstring
     */
    errorMsg?: string;
    /**
     * 응답 성공 시 응답 클래스
     * @type {Array<string>}
     * @memberof ResponseBodyWrapperListstring
     */
    result?: Array<string>;
}
/**
 * 
 * @export
 * @interface ResponseBodyWrapperSong
 */
export interface ResponseBodyWrapperSong {
    /**
     * 응답 실패 사유
     * @type {string}
     * @memberof ResponseBodyWrapperSong
     */
    errorMsg?: string;
    /**
     * 
     * @type {Song}
     * @memberof ResponseBodyWrapperSong
     */
    result?: Song;
}
/**
 * 
 * @export
 * @interface ResponseBodyWrapperobject
 */
export interface ResponseBodyWrapperobject {
    /**
     * 응답 실패 사유
     * @type {string}
     * @memberof ResponseBodyWrapperobject
     */
    errorMsg?: string;
    /**
     * 응답 성공 시 응답 클래스
     * @type {object}
     * @memberof ResponseBodyWrapperobject
     */
    result?: object;
}
/**
 * 
 * @export
 * @interface ResponseDTO
 */
export interface ResponseDTO {
    /**
     * 
     * @type {object}
     * @memberof ResponseDTO
     */
    body?: object;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTO
     */
    status?: number;
}
/**
 * 
 * @export
 * @interface ResponseDTOGameResultResponse
 */
export interface ResponseDTOGameResultResponse {
    /**
     * 
     * @type {GameResultResponse}
     * @memberof ResponseDTOGameResultResponse
     */
    body?: GameResultResponse;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOGameResultResponse
     */
    status?: number;
}
/**
 * 
 * @export
 * @interface ResponseDTOGameResultResponseV2
 */
export interface ResponseDTOGameResultResponseV2 {
    /**
     * 
     * @type {GameResultResponseV2}
     * @memberof ResponseDTOGameResultResponseV2
     */
    body?: GameResultResponseV2;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOGameResultResponseV2
     */
    status?: number;
}
/**
 * 
 * @export
 * @interface ResponseDTOGameStartResponse
 */
export interface ResponseDTOGameStartResponse {
    /**
     * 
     * @type {GameStartResponse}
     * @memberof ResponseDTOGameStartResponse
     */
    body?: GameStartResponse;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOGameStartResponse
     */
    status?: number;
}
/**
 * 
 * @export
 * @interface ResponseDTOHeartResponse
 */
export interface ResponseDTOHeartResponse {
    /**
     * 
     * @type {HeartResponse}
     * @memberof ResponseDTOHeartResponse
     */
    body?: HeartResponse;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOHeartResponse
     */
    status?: number;
}
/**
 * 
 * @export
 * @interface ResponseDTOLikeResponse
 */
export interface ResponseDTOLikeResponse {
    /**
     * 
     * @type {LikeResponse}
     * @memberof ResponseDTOLikeResponse
     */
    body?: LikeResponse;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOLikeResponse
     */
    status?: number;
}
/**
 * 
 * @export
 * @interface ResponseDTOListItem
 */
export interface ResponseDTOListItem {
    /**
     * 
     * @type {Array<Item>}
     * @memberof ResponseDTOListItem
     */
    body?: Array<Item>;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOListItem
     */
    status?: number;
}
/**
 * 
 * @export
 * @interface ResponseDTOListLikeHistoryResponse
 */
export interface ResponseDTOListLikeHistoryResponse {
    /**
     * 
     * @type {Array<LikeHistoryResponse>}
     * @memberof ResponseDTOListLikeHistoryResponse
     */
    body?: Array<LikeHistoryResponse>;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOListLikeHistoryResponse
     */
    status?: number;
}
/**
 * 
 * @export
 * @interface ResponseDTOListSinger
 */
export interface ResponseDTOListSinger {
    /**
     * 
     * @type {Array<Singer>}
     * @memberof ResponseDTOListSinger
     */
    body?: Array<Singer>;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOListSinger
     */
    status?: number;
}
/**
 * 
 * @export
 * @interface ResponseDTOListUserLikeHistoryResponse
 */
export interface ResponseDTOListUserLikeHistoryResponse {
    /**
     * 
     * @type {Array<UserLikeHistoryResponse>}
     * @memberof ResponseDTOListUserLikeHistoryResponse
     */
    body?: Array<UserLikeHistoryResponse>;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOListUserLikeHistoryResponse
     */
    status?: number;
}
/**
 * 
 * @export
 * @interface ResponseDTOListstring
 */
export interface ResponseDTOListstring {
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseDTOListstring
     */
    body?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOListstring
     */
    status?: number;
}
/**
 * 
 * @export
 * @interface ResponseDTOLoggedInMusicUser
 */
export interface ResponseDTOLoggedInMusicUser {
    /**
     * 
     * @type {LoggedInMusicUser}
     * @memberof ResponseDTOLoggedInMusicUser
     */
    body?: LoggedInMusicUser;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOLoggedInMusicUser
     */
    status?: number;
}
/**
 * 
 * @export
 * @interface ResponseDTOPageSongResponse
 */
export interface ResponseDTOPageSongResponse {
    /**
     * 
     * @type {PageSongResponse}
     * @memberof ResponseDTOPageSongResponse
     */
    body?: PageSongResponse;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOPageSongResponse
     */
    status?: number;
}
/**
 * 
 * @export
 * @interface ResponseDTORankViewModel
 */
export interface ResponseDTORankViewModel {
    /**
     * 
     * @type {RankViewModel}
     * @memberof ResponseDTORankViewModel
     */
    body?: RankViewModel;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTORankViewModel
     */
    status?: number;
}
/**
 * 
 * @export
 * @interface ResponseDTOReward
 */
export interface ResponseDTOReward {
    /**
     * 
     * @type {Reward}
     * @memberof ResponseDTOReward
     */
    body?: Reward;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOReward
     */
    status?: number;
}
/**
 * 
 * @export
 * @interface ResponseDTOSetstring
 */
export interface ResponseDTOSetstring {
    /**
     * 
     * @type {Array<string>}
     * @memberof ResponseDTOSetstring
     */
    body?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOSetstring
     */
    status?: number;
}
/**
 * 
 * @export
 * @interface ResponseDTOSong
 */
export interface ResponseDTOSong {
    /**
     * 
     * @type {Song}
     * @memberof ResponseDTOSong
     */
    body?: Song;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOSong
     */
    status?: number;
}
/**
 * 
 * @export
 * @interface ResponseDTOboolean
 */
export interface ResponseDTOboolean {
    /**
     * 
     * @type {boolean}
     * @memberof ResponseDTOboolean
     */
    body?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOboolean
     */
    status?: number;
}
/**
 * 
 * @export
 * @interface ResponseDTOstring
 */
export interface ResponseDTOstring {
    /**
     * 
     * @type {string}
     * @memberof ResponseDTOstring
     */
    body?: string;
    /**
     * 
     * @type {number}
     * @memberof ResponseDTOstring
     */
    status?: number;
}
/**
 * 
 * @export
 * @interface RestrctionRequest
 */
export interface RestrctionRequest {
    /**
     * 
     * @type {string}
     * @memberof RestrctionRequest
     */
    singer?: string;
}
/**
 * 
 * @export
 * @interface Reward
 */
export interface Reward {
    /**
     * 
     * @type {number}
     * @memberof Reward
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Reward
     */
    rewardType?: string;
}
/**
 * 게임 결과 화면에 노출되는 스코어 관련 정보
 * @export
 * @interface ScoreViewModel
 */
export interface ScoreViewModel {
    /**
     * 스코어에 해당하는 랭킹.
     * @type {number}
     * @memberof ScoreViewModel
     */
    ranking?: number;
    /**
     * 
     * @type {AbstractScore}
     * @memberof ScoreViewModel
     */
    score?: AbstractScore;
    /**
     * 스코어에 해당하는 랭킹 타입.
     * @type {string}
     * @memberof ScoreViewModel
     */
    scoreType?: ScoreViewModelScoreTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ScoreViewModelScoreTypeEnum {
    SEASON = 'SEASON',
    MONTHLY = 'MONTHLY'
}

/**
 * 가수 정보를 갖고 있는 오브젝트.
 * @export
 * @interface Singer
 */
export interface Singer {
    /**
     * 가수의 최근 앨범 이미지 URL
     * @type {string}
     * @memberof Singer
     */
    artworkUrl?: string;
    /**
     * 사용자들에게 얼마나 많은 좋아요를 받았는지 여부.
     * @type {number}
     * @memberof Singer
     */
    exportedCount?: number;
    /**
     * 해당 가수가 문제로 출제 될 수 있는 highlight를 갖고 있는지에 대한 여부.
     * @type {boolean}
     * @memberof Singer
     */
    hasHighlight?: boolean;
    /**
     * 가수 ID
     * @type {number}
     * @memberof Singer
     */
    id?: number;
    /**
     * 가수 이름
     * @type {string}
     * @memberof Singer
     */
    singerName?: string;
}
/**
 * Admin 에서 사용하는 가수 정보 오브젝트.
 * @export
 * @interface SingerInfoView
 */
export interface SingerInfoView {
    /**
     * 
     * @type {Singer}
     * @memberof SingerInfoView
     */
    singer?: Singer;
    /**
     * 가수가 소지하고 있는 노래 리스트
     * @type {Array<Song>}
     * @memberof SingerInfoView
     */
    songList?: Array<Song>;
}
/**
 * 가수가 갖고있는 노래의 정보
 * @export
 * @interface Song
 */
export interface Song {
    /**
     * 노래 앨범 url
     * @type {string}
     * @memberof Song
     */
    artworkUrl?: string;
    /**
     * true : 사용자들에게 출제 되고 있는 문제임 / false : 사용자들에게 출제 되고 있지 않은 노래임.
     * @type {boolean}
     * @memberof Song
     */
    exported?: boolean;
    /**
     * 노래 ID
     * @type {number}
     * @memberof Song
     */
    id?: number;
    /**
     * 
     * @type {Like}
     * @memberof Song
     */
    like?: Like;
    /**
     * 
     * @type {MusicUser}
     * @memberof Song
     */
    musicUser?: MusicUser;
    /**
     * 노래의 정답. 사용자는 이 답을 입력 해야지만 정답 처리가 된다
     * @type {string}
     * @memberof Song
     */
    refinedTitle?: string;
    /**
     * 이 노래의 주인인 가수 정보.
     * @type {string}
     * @memberof Song
     */
    singer?: string;
    /**
     * 해당 노래가 갖고있는 Highlight들의 집합. 해당 highlight 정보를 이용하여 게임 플레이를 진행함.
     * @type {Array<SongHighlight>}
     * @memberof Song
     */
    songHighlight?: Array<SongHighlight>;
    /**
     * 사용자들에게 노출될 title
     * @type {string}
     * @memberof Song
     */
    title?: string;
    /**
     * 노래 trackId, 이 값은 SoundCloud의 노래의 trackId랑 같은 값임
     * @type {number}
     * @memberof Song
     */
    trackId?: number;
    /**
     * 노래 streaming url
     * @type {string}
     * @memberof Song
     */
    url?: string;
}
/**
 * 노래를 신규로 등록할 때 사용함.
 * @export
 * @interface SongCreateRequest
 */
export interface SongCreateRequest {
    /**
     * 노래의 앨범 혹은 대표 이미지 URL, 아무것도 작성하지 않으면 soundCloud 기준의 artworkUrl이 자동으로 들어가진다.
     * @type {string}
     * @memberof SongCreateRequest
     */
    artworkUrl?: string;
    /**
     * songUrl에 해당하는 노래에 댓글이 달려 있을 경우, 해당 댓글을 이용하여 자동으로 문제를 만들 것 인지에 대한 여부
     * @type {boolean}
     * @memberof SongCreateRequest
     */
    autoRegisterHighlights?: boolean;
    /**
     * 노래가 사용자들에게 퀴즈로 노출될건지 여부
     * @type {boolean}
     * @memberof SongCreateRequest
     */
    exported?: boolean;
    /**
     * 해당 문제의 정답.
     * @type {string}
     * @memberof SongCreateRequest
     */
    refineTitle?: string;
    /**
     * 등록할 노래의 URL 
     * @type {string}
     * @memberof SongCreateRequest
     */
    songUrl?: string;
    /**
     * 노래 제목, 아무것도 작성하지 않으면 soundCloud 기준의 제목이 자동으로 들어가진다.
     * @type {string}
     * @memberof SongCreateRequest
     */
    title?: string;
}
/**
 * 특정 Song에 등록된 Highlight들. 해당 객체의 정보를 바탕으로 문제가 출제된다.
 * @export
 * @interface SongHighlight
 */
export interface SongHighlight {
    /**
     * 해당 highlight가 출제되고 있는지에 대한 여부
     * @type {boolean}
     * @memberof SongHighlight
     */
    elected?: boolean;
    /**
     * songHighlight ID
     * @type {number}
     * @memberof SongHighlight
     */
    id?: number;
    /**
     * 사용자가 노래를 듣게 될 시작부분.
     * @type {number}
     * @memberof SongHighlight
     */
    millisecond?: number;
    /**
     * 
     * @type {Song}
     * @memberof SongHighlight
     */
    song?: Song;
}
/**
 * 
 * @export
 * @interface SongHighlightAddRequest
 */
export interface SongHighlightAddRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof SongHighlightAddRequest
     */
    highlightSeconds?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof SongHighlightAddRequest
     */
    songId?: number;
}
/**
 * 
 * @export
 * @interface SongHighlightDTO
 */
export interface SongHighlightDTO {
    /**
     * 
     * @type {number}
     * @memberof SongHighlightDTO
     */
    millisecond?: number;
    /**
     * 
     * @type {string}
     * @memberof SongHighlightDTO
     */
    singer?: string;
    /**
     * 
     * @type {string}
     * @memberof SongHighlightDTO
     */
    title?: string;
}
/**
 * 
 * @export
 * @interface SongRegisterRequest
 */
export interface SongRegisterRequest {
    /**
     * 
     * @type {Array<number>}
     * @memberof SongRegisterRequest
     */
    highlightSeconds?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof SongRegisterRequest
     */
    singerName?: string;
    /**
     * 
     * @type {string}
     * @memberof SongRegisterRequest
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface SongResponse
 */
export interface SongResponse {
    /**
     * 
     * @type {boolean}
     * @memberof SongResponse
     */
    alreadyLike?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SongResponse
     */
    artworkUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof SongResponse
     */
    like?: number;
    /**
     * 
     * @type {string}
     * @memberof SongResponse
     */
    singer?: string;
    /**
     * 
     * @type {string}
     * @memberof SongResponse
     */
    title?: string;
    /**
     * 
     * @type {number}
     * @memberof SongResponse
     */
    trackId?: number;
    /**
     * 
     * @type {string}
     * @memberof SongResponse
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface SongUpdateRequest
 */
export interface SongUpdateRequest {
    /**
     * 노래 앨범 url
     * @type {string}
     * @memberof SongUpdateRequest
     */
    artworkUrl?: string;
    /**
     * 사용자들에게 문제로 출제 되고 있는지에 대한 유무
     * @type {boolean}
     * @memberof SongUpdateRequest
     */
    exported?: boolean;
    /**
     * 노래의 정답. 사용자는 이 답을 입력 해야지만 정답 처리가 된다
     * @type {string}
     * @memberof SongUpdateRequest
     */
    refineTitle?: string;
    /**
     * 노래 제목
     * @type {string}
     * @memberof SongUpdateRequest
     */
    title?: string;
    /**
     * 노래 streaming url
     * @type {string}
     * @memberof SongUpdateRequest
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface Sort
 */
export interface Sort {
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    empty?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    sorted?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Sort
     */
    unsorted?: boolean;
}
/**
 * 
 * @export
 * @interface Track
 */
export interface Track {
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    artwork_url?: string;
    /**
     * 
     * @type {number}
     * @memberof Track
     */
    comment_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Track
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    singerName?: string;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    stream_url?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Track
     */
    streamable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof Track
     */
    uri?: string;
}
/**
 * 
 * @export
 * @interface UserLikeHistoryResponse
 */
export interface UserLikeHistoryResponse {
    /**
     * 
     * @type {string}
     * @memberof UserLikeHistoryResponse
     */
    accessId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLikeHistoryResponse
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLikeHistoryResponse
     */
    nickname?: string;
}
/**
 * 
 * @export
 * @interface UserLoginRequest
 */
export interface UserLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof UserLoginRequest
     */
    accessId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginRequest
     */
    accessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof UserLoginRequest
     */
    refreshToken?: string;
}
/**
 * 
 * @export
 * @interface UserSignUpRequest
 */
export interface UserSignUpRequest {
    /**
     * 
     * @type {string}
     * @memberof UserSignUpRequest
     */
    accessId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSignUpRequest
     */
    deviceId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSignUpRequest
     */
    invitedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSignUpRequest
     */
    nickname?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSignUpRequest
     */
    socialType?: string;
}

/**
 * APIApi - axios parameter creator
 * @export
 */
export const APIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 신규 Highlight 정보 생성
         * @summary 하이라이트 정보 생성
         * @param {number} songId 생성할 하이라이트의 노래 ID
         * @param {HighlightUpdateOrCreateRequest} request 생성할 하이라이트 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHighlightUsingPOST: async (songId: number, request: HighlightUpdateOrCreateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'songId' is not null or undefined
            if (songId === null || songId === undefined) {
                throw new RequiredError('songId','Required parameter songId was null or undefined when calling createHighlightUsingPOST.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling createHighlightUsingPOST.');
            }
            const localVarPath = `/v2/admin/songs/{songId}/highlights`
                .replace(`{${"songId"}}`, encodeURIComponent(String(songId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 가수 이름을 기반으로 신규 가수를 등록합니다.
         * @summary 가수 신규 등록
         * @param {string} singerName 가수 이름
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewSingerUsingPOST: async (singerName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'singerName' is not null or undefined
            if (singerName === null || singerName === undefined) {
                throw new RequiredError('singerName','Required parameter singerName was null or undefined when calling createNewSingerUsingPOST.');
            }
            const localVarPath = `/v2/admin/singers/{singerName}`
                .replace(`{${"singerName"}}`, encodeURIComponent(String(singerName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 가수의 노래를 신규로 등록한다.
         * @summary 가수 노래 신규 등록
         * @param {string} singerName 가수 이름
         * @param {SongCreateRequest} songCreateRequest 등록할 노래 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewSongUsingPOST: async (singerName: string, songCreateRequest: SongCreateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'singerName' is not null or undefined
            if (singerName === null || singerName === undefined) {
                throw new RequiredError('singerName','Required parameter singerName was null or undefined when calling createNewSongUsingPOST.');
            }
            // verify required parameter 'songCreateRequest' is not null or undefined
            if (songCreateRequest === null || songCreateRequest === undefined) {
                throw new RequiredError('songCreateRequest','Required parameter songCreateRequest was null or undefined when calling createNewSongUsingPOST.');
            }
            const localVarPath = `/v2/admin/singers/{singerName}/songs`
                .replace(`{${"singerName"}}`, encodeURIComponent(String(singerName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof songCreateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(songCreateRequest !== undefined ? songCreateRequest : {}) : (songCreateRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * highlightId를 이용하여 한 개의 highlight 정보를 영구적으로 삭제한다.
         * @summary 하이라이트 삭제
         * @param {number} highlightId 하이라이트 ID
         * @param {number} songId 삭제할 하이라이트의 노래 ID ( default 는 장범준 노래임 )
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHighlightUsingDELETE: async (highlightId: number, songId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'highlightId' is not null or undefined
            if (highlightId === null || highlightId === undefined) {
                throw new RequiredError('highlightId','Required parameter highlightId was null or undefined when calling deleteHighlightUsingDELETE.');
            }
            // verify required parameter 'songId' is not null or undefined
            if (songId === null || songId === undefined) {
                throw new RequiredError('songId','Required parameter songId was null or undefined when calling deleteHighlightUsingDELETE.');
            }
            const localVarPath = `/v2/admin/songs/{songId}/highlights/{highlightId}`
                .replace(`{${"highlightId"}}`, encodeURIComponent(String(highlightId)))
                .replace(`{${"songId"}}`, encodeURIComponent(String(songId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 가수의 노래를 삭제한다. 응답 결과로는 삭제된 노래의 정보가 반환된다.
         * @summary 가수 노래 정보 삭제
         * @param {number} songId 삭제할 노래 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSongUsingDELETE: async (songId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'songId' is not null or undefined
            if (songId === null || songId === undefined) {
                throw new RequiredError('songId','Required parameter songId was null or undefined when calling deleteSongUsingDELETE.');
            }
            const localVarPath = `/v2/admin/songs/{songId}`
                .replace(`{${"songId"}}`, encodeURIComponent(String(songId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 가수 이름을 기반으로 가수 이름을 검색 합니다.
         * @summary 가수 정보 조회
         * @param {string} singerName 가수 이름
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingerInfoUsingGET: async (singerName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'singerName' is not null or undefined
            if (singerName === null || singerName === undefined) {
                throw new RequiredError('singerName','Required parameter singerName was null or undefined when calling getSingerInfoUsingGET.');
            }
            const localVarPath = `/v2/admin/singers/{singerName}`
                .replace(`{${"singerName"}}`, encodeURIComponent(String(singerName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 가수의 노래 정보를 변경한다.
         * @summary 가수 노래 정보 변경
         * @param {number} songId 변경할 노래 ID
         * @param {SongUpdateRequest} request 변경할 노래 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtworkUrlOfSongUsingPUT: async (songId: number, request: SongUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'songId' is not null or undefined
            if (songId === null || songId === undefined) {
                throw new RequiredError('songId','Required parameter songId was null or undefined when calling updateArtworkUrlOfSongUsingPUT.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling updateArtworkUrlOfSongUsingPUT.');
            }
            const localVarPath = `/v2/admin/songs/{songId}/artworkUrl`
                .replace(`{${"songId"}}`, encodeURIComponent(String(songId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 가수 앨범 이미지를 변경 합니다.
         * @summary 가수 대표 이미지 변경
         * @param {string} singerName 가수 이름
         * @param {ArtworkUrlUpdateRequest} request 변경할 앨범 이미지 URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtworkUrlUsingPUT: async (singerName: string, request: ArtworkUrlUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'singerName' is not null or undefined
            if (singerName === null || singerName === undefined) {
                throw new RequiredError('singerName','Required parameter singerName was null or undefined when calling updateArtworkUrlUsingPUT.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling updateArtworkUrlUsingPUT.');
            }
            const localVarPath = `/v2/admin/singers/{singerName}/artworkUrl`
                .replace(`{${"singerName"}}`, encodeURIComponent(String(singerName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 가수의 노래의 노출 여부를 변경한다.
         * @summary 가수 노래 노출 여부 변경
         * @param {number} songId 변경할 노래 ID
         * @param {string} exported 변경할 노래 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExportedOfSongUsingPUT: async (songId: number, exported: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'songId' is not null or undefined
            if (songId === null || songId === undefined) {
                throw new RequiredError('songId','Required parameter songId was null or undefined when calling updateExportedOfSongUsingPUT.');
            }
            // verify required parameter 'exported' is not null or undefined
            if (exported === null || exported === undefined) {
                throw new RequiredError('exported','Required parameter exported was null or undefined when calling updateExportedOfSongUsingPUT.');
            }
            const localVarPath = `/v2/admin/songs/{songId}/exported`
                .replace(`{${"songId"}}`, encodeURIComponent(String(songId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof exported !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(exported !== undefined ? exported : {}) : (exported || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 해당 가수가 유저들에게 노출 되는지의 여부를 변경한다.
         * @summary 가수 노출 여부 변경
         * @param {string} singerName 변경할 가수 이름
         * @param {string} hasHighlight 변경할 노래 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHasHighlightUsingPUT: async (singerName: string, hasHighlight: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'singerName' is not null or undefined
            if (singerName === null || singerName === undefined) {
                throw new RequiredError('singerName','Required parameter singerName was null or undefined when calling updateHasHighlightUsingPUT.');
            }
            // verify required parameter 'hasHighlight' is not null or undefined
            if (hasHighlight === null || hasHighlight === undefined) {
                throw new RequiredError('hasHighlight','Required parameter hasHighlight was null or undefined when calling updateHasHighlightUsingPUT.');
            }
            const localVarPath = `/v2/admin/singers/{singerName}/has-highlight`
                .replace(`{${"singerName"}}`, encodeURIComponent(String(singerName)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof hasHighlight !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(hasHighlight !== undefined ? hasHighlight : {}) : (hasHighlight || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admin UI에 알맞게 highlightId 만을 이용하여 하이라이트 정보를 변경한다.
         * @summary 하이라이트 정보 변경
         * @param {number} highlightId 하이라이트 ID
         * @param {number} songId 변경할 하이라이트의 노래 ID
         * @param {HighlightUpdateOrCreateRequest} request 변경할 하이라이트 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHighlightUsingPUT: async (highlightId: number, songId: number, request: HighlightUpdateOrCreateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'highlightId' is not null or undefined
            if (highlightId === null || highlightId === undefined) {
                throw new RequiredError('highlightId','Required parameter highlightId was null or undefined when calling updateHighlightUsingPUT.');
            }
            // verify required parameter 'songId' is not null or undefined
            if (songId === null || songId === undefined) {
                throw new RequiredError('songId','Required parameter songId was null or undefined when calling updateHighlightUsingPUT.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling updateHighlightUsingPUT.');
            }
            const localVarPath = `/v2/admin/songs/{songId}/highlights/{highlightId}`
                .replace(`{${"highlightId"}}`, encodeURIComponent(String(highlightId)))
                .replace(`{${"songId"}}`, encodeURIComponent(String(songId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 가수의 노래 refine title만 변경한다.
         * @summary 가수 노래의 refined_title만 변경 
         * @param {number} songId 변경할 노래 ID
         * @param {string} refineTitle 변경할 노래 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRefinedTitleOfSongUsingPUT: async (songId: number, refineTitle: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'songId' is not null or undefined
            if (songId === null || songId === undefined) {
                throw new RequiredError('songId','Required parameter songId was null or undefined when calling updateRefinedTitleOfSongUsingPUT.');
            }
            // verify required parameter 'refineTitle' is not null or undefined
            if (refineTitle === null || refineTitle === undefined) {
                throw new RequiredError('refineTitle','Required parameter refineTitle was null or undefined when calling updateRefinedTitleOfSongUsingPUT.');
            }
            const localVarPath = `/v2/admin/songs/{songId}/refinedTitle`
                .replace(`{${"songId"}}`, encodeURIComponent(String(songId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof refineTitle !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(refineTitle !== undefined ? refineTitle : {}) : (refineTitle || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 가수의 노래 정보를 변경한다.
         * @summary 가수 노래 정보 변경
         * @param {number} songId 변경할 노래 ID
         * @param {SongUpdateRequest} request 변경할 노래 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSongUsingPUT: async (songId: number, request: SongUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'songId' is not null or undefined
            if (songId === null || songId === undefined) {
                throw new RequiredError('songId','Required parameter songId was null or undefined when calling updateSongUsingPUT.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling updateSongUsingPUT.');
            }
            const localVarPath = `/v2/admin/songs/{songId}`
                .replace(`{${"songId"}}`, encodeURIComponent(String(songId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIApi - functional programming interface
 * @export
 */
export const APIApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 신규 Highlight 정보 생성
         * @summary 하이라이트 정보 생성
         * @param {number} songId 생성할 하이라이트의 노래 ID
         * @param {HighlightUpdateOrCreateRequest} request 생성할 하이라이트 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createHighlightUsingPOST(songId: number, request: HighlightUpdateOrCreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SongHighlight>> {
            const localVarAxiosArgs = await APIApiAxiosParamCreator(configuration).createHighlightUsingPOST(songId, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 가수 이름을 기반으로 신규 가수를 등록합니다.
         * @summary 가수 신규 등록
         * @param {string} singerName 가수 이름
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewSingerUsingPOST(singerName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SingerInfoView>> {
            const localVarAxiosArgs = await APIApiAxiosParamCreator(configuration).createNewSingerUsingPOST(singerName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 가수의 노래를 신규로 등록한다.
         * @summary 가수 노래 신규 등록
         * @param {string} singerName 가수 이름
         * @param {SongCreateRequest} songCreateRequest 등록할 노래 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewSongUsingPOST(singerName: string, songCreateRequest: SongCreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Song>> {
            const localVarAxiosArgs = await APIApiAxiosParamCreator(configuration).createNewSongUsingPOST(singerName, songCreateRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * highlightId를 이용하여 한 개의 highlight 정보를 영구적으로 삭제한다.
         * @summary 하이라이트 삭제
         * @param {number} highlightId 하이라이트 ID
         * @param {number} songId 삭제할 하이라이트의 노래 ID ( default 는 장범준 노래임 )
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteHighlightUsingDELETE(highlightId: number, songId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SongHighlight>> {
            const localVarAxiosArgs = await APIApiAxiosParamCreator(configuration).deleteHighlightUsingDELETE(highlightId, songId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 가수의 노래를 삭제한다. 응답 결과로는 삭제된 노래의 정보가 반환된다.
         * @summary 가수 노래 정보 삭제
         * @param {number} songId 삭제할 노래 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSongUsingDELETE(songId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Song>> {
            const localVarAxiosArgs = await APIApiAxiosParamCreator(configuration).deleteSongUsingDELETE(songId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 가수 이름을 기반으로 가수 이름을 검색 합니다.
         * @summary 가수 정보 조회
         * @param {string} singerName 가수 이름
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSingerInfoUsingGET(singerName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SingerInfoView>> {
            const localVarAxiosArgs = await APIApiAxiosParamCreator(configuration).getSingerInfoUsingGET(singerName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 가수의 노래 정보를 변경한다.
         * @summary 가수 노래 정보 변경
         * @param {number} songId 변경할 노래 ID
         * @param {SongUpdateRequest} request 변경할 노래 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArtworkUrlOfSongUsingPUT(songId: number, request: SongUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Song>> {
            const localVarAxiosArgs = await APIApiAxiosParamCreator(configuration).updateArtworkUrlOfSongUsingPUT(songId, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 가수 앨범 이미지를 변경 합니다.
         * @summary 가수 대표 이미지 변경
         * @param {string} singerName 가수 이름
         * @param {ArtworkUrlUpdateRequest} request 변경할 앨범 이미지 URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArtworkUrlUsingPUT(singerName: string, request: ArtworkUrlUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Singer>> {
            const localVarAxiosArgs = await APIApiAxiosParamCreator(configuration).updateArtworkUrlUsingPUT(singerName, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 가수의 노래의 노출 여부를 변경한다.
         * @summary 가수 노래 노출 여부 변경
         * @param {number} songId 변경할 노래 ID
         * @param {string} exported 변경할 노래 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExportedOfSongUsingPUT(songId: number, exported: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Song>> {
            const localVarAxiosArgs = await APIApiAxiosParamCreator(configuration).updateExportedOfSongUsingPUT(songId, exported, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 해당 가수가 유저들에게 노출 되는지의 여부를 변경한다.
         * @summary 가수 노출 여부 변경
         * @param {string} singerName 변경할 가수 이름
         * @param {string} hasHighlight 변경할 노래 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHasHighlightUsingPUT(singerName: string, hasHighlight: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Singer>> {
            const localVarAxiosArgs = await APIApiAxiosParamCreator(configuration).updateHasHighlightUsingPUT(singerName, hasHighlight, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Admin UI에 알맞게 highlightId 만을 이용하여 하이라이트 정보를 변경한다.
         * @summary 하이라이트 정보 변경
         * @param {number} highlightId 하이라이트 ID
         * @param {number} songId 변경할 하이라이트의 노래 ID
         * @param {HighlightUpdateOrCreateRequest} request 변경할 하이라이트 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateHighlightUsingPUT(highlightId: number, songId: number, request: HighlightUpdateOrCreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SongHighlight>> {
            const localVarAxiosArgs = await APIApiAxiosParamCreator(configuration).updateHighlightUsingPUT(highlightId, songId, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 가수의 노래 refine title만 변경한다.
         * @summary 가수 노래의 refined_title만 변경 
         * @param {number} songId 변경할 노래 ID
         * @param {string} refineTitle 변경할 노래 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRefinedTitleOfSongUsingPUT(songId: number, refineTitle: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Song>> {
            const localVarAxiosArgs = await APIApiAxiosParamCreator(configuration).updateRefinedTitleOfSongUsingPUT(songId, refineTitle, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 가수의 노래 정보를 변경한다.
         * @summary 가수 노래 정보 변경
         * @param {number} songId 변경할 노래 ID
         * @param {SongUpdateRequest} request 변경할 노래 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSongUsingPUT(songId: number, request: SongUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Song>> {
            const localVarAxiosArgs = await APIApiAxiosParamCreator(configuration).updateSongUsingPUT(songId, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * APIApi - factory interface
 * @export
 */
export const APIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 신규 Highlight 정보 생성
         * @summary 하이라이트 정보 생성
         * @param {number} songId 생성할 하이라이트의 노래 ID
         * @param {HighlightUpdateOrCreateRequest} request 생성할 하이라이트 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createHighlightUsingPOST(songId: number, request: HighlightUpdateOrCreateRequest, options?: any): AxiosPromise<SongHighlight> {
            return APIApiFp(configuration).createHighlightUsingPOST(songId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 가수 이름을 기반으로 신규 가수를 등록합니다.
         * @summary 가수 신규 등록
         * @param {string} singerName 가수 이름
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewSingerUsingPOST(singerName: string, options?: any): AxiosPromise<SingerInfoView> {
            return APIApiFp(configuration).createNewSingerUsingPOST(singerName, options).then((request) => request(axios, basePath));
        },
        /**
         * 가수의 노래를 신규로 등록한다.
         * @summary 가수 노래 신규 등록
         * @param {string} singerName 가수 이름
         * @param {SongCreateRequest} songCreateRequest 등록할 노래 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewSongUsingPOST(singerName: string, songCreateRequest: SongCreateRequest, options?: any): AxiosPromise<Song> {
            return APIApiFp(configuration).createNewSongUsingPOST(singerName, songCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * highlightId를 이용하여 한 개의 highlight 정보를 영구적으로 삭제한다.
         * @summary 하이라이트 삭제
         * @param {number} highlightId 하이라이트 ID
         * @param {number} songId 삭제할 하이라이트의 노래 ID ( default 는 장범준 노래임 )
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHighlightUsingDELETE(highlightId: number, songId: number, options?: any): AxiosPromise<SongHighlight> {
            return APIApiFp(configuration).deleteHighlightUsingDELETE(highlightId, songId, options).then((request) => request(axios, basePath));
        },
        /**
         * 가수의 노래를 삭제한다. 응답 결과로는 삭제된 노래의 정보가 반환된다.
         * @summary 가수 노래 정보 삭제
         * @param {number} songId 삭제할 노래 ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSongUsingDELETE(songId: number, options?: any): AxiosPromise<Song> {
            return APIApiFp(configuration).deleteSongUsingDELETE(songId, options).then((request) => request(axios, basePath));
        },
        /**
         * 가수 이름을 기반으로 가수 이름을 검색 합니다.
         * @summary 가수 정보 조회
         * @param {string} singerName 가수 이름
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingerInfoUsingGET(singerName: string, options?: any): AxiosPromise<SingerInfoView> {
            return APIApiFp(configuration).getSingerInfoUsingGET(singerName, options).then((request) => request(axios, basePath));
        },
        /**
         * 가수의 노래 정보를 변경한다.
         * @summary 가수 노래 정보 변경
         * @param {number} songId 변경할 노래 ID
         * @param {SongUpdateRequest} request 변경할 노래 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtworkUrlOfSongUsingPUT(songId: number, request: SongUpdateRequest, options?: any): AxiosPromise<Song> {
            return APIApiFp(configuration).updateArtworkUrlOfSongUsingPUT(songId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 가수 앨범 이미지를 변경 합니다.
         * @summary 가수 대표 이미지 변경
         * @param {string} singerName 가수 이름
         * @param {ArtworkUrlUpdateRequest} request 변경할 앨범 이미지 URL
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtworkUrlUsingPUT(singerName: string, request: ArtworkUrlUpdateRequest, options?: any): AxiosPromise<Singer> {
            return APIApiFp(configuration).updateArtworkUrlUsingPUT(singerName, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 가수의 노래의 노출 여부를 변경한다.
         * @summary 가수 노래 노출 여부 변경
         * @param {number} songId 변경할 노래 ID
         * @param {string} exported 변경할 노래 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExportedOfSongUsingPUT(songId: number, exported: string, options?: any): AxiosPromise<Song> {
            return APIApiFp(configuration).updateExportedOfSongUsingPUT(songId, exported, options).then((request) => request(axios, basePath));
        },
        /**
         * 해당 가수가 유저들에게 노출 되는지의 여부를 변경한다.
         * @summary 가수 노출 여부 변경
         * @param {string} singerName 변경할 가수 이름
         * @param {string} hasHighlight 변경할 노래 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHasHighlightUsingPUT(singerName: string, hasHighlight: string, options?: any): AxiosPromise<Singer> {
            return APIApiFp(configuration).updateHasHighlightUsingPUT(singerName, hasHighlight, options).then((request) => request(axios, basePath));
        },
        /**
         * Admin UI에 알맞게 highlightId 만을 이용하여 하이라이트 정보를 변경한다.
         * @summary 하이라이트 정보 변경
         * @param {number} highlightId 하이라이트 ID
         * @param {number} songId 변경할 하이라이트의 노래 ID
         * @param {HighlightUpdateOrCreateRequest} request 변경할 하이라이트 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHighlightUsingPUT(highlightId: number, songId: number, request: HighlightUpdateOrCreateRequest, options?: any): AxiosPromise<SongHighlight> {
            return APIApiFp(configuration).updateHighlightUsingPUT(highlightId, songId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 가수의 노래 refine title만 변경한다.
         * @summary 가수 노래의 refined_title만 변경 
         * @param {number} songId 변경할 노래 ID
         * @param {string} refineTitle 변경할 노래 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRefinedTitleOfSongUsingPUT(songId: number, refineTitle: string, options?: any): AxiosPromise<Song> {
            return APIApiFp(configuration).updateRefinedTitleOfSongUsingPUT(songId, refineTitle, options).then((request) => request(axios, basePath));
        },
        /**
         * 가수의 노래 정보를 변경한다.
         * @summary 가수 노래 정보 변경
         * @param {number} songId 변경할 노래 ID
         * @param {SongUpdateRequest} request 변경할 노래 정보
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSongUsingPUT(songId: number, request: SongUpdateRequest, options?: any): AxiosPromise<Song> {
            return APIApiFp(configuration).updateSongUsingPUT(songId, request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIApi - object-oriented interface
 * @export
 * @class APIApi
 * @extends {BaseAPI}
 */
export class APIApi extends BaseAPI {
    /**
     * 신규 Highlight 정보 생성
     * @summary 하이라이트 정보 생성
     * @param {number} songId 생성할 하이라이트의 노래 ID
     * @param {HighlightUpdateOrCreateRequest} request 생성할 하이라이트 정보
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public createHighlightUsingPOST(songId: number, request: HighlightUpdateOrCreateRequest, options?: any) {
        return APIApiFp(this.configuration).createHighlightUsingPOST(songId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 가수 이름을 기반으로 신규 가수를 등록합니다.
     * @summary 가수 신규 등록
     * @param {string} singerName 가수 이름
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public createNewSingerUsingPOST(singerName: string, options?: any) {
        return APIApiFp(this.configuration).createNewSingerUsingPOST(singerName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 가수의 노래를 신규로 등록한다.
     * @summary 가수 노래 신규 등록
     * @param {string} singerName 가수 이름
     * @param {SongCreateRequest} songCreateRequest 등록할 노래 정보
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public createNewSongUsingPOST(singerName: string, songCreateRequest: SongCreateRequest, options?: any) {
        return APIApiFp(this.configuration).createNewSongUsingPOST(singerName, songCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * highlightId를 이용하여 한 개의 highlight 정보를 영구적으로 삭제한다.
     * @summary 하이라이트 삭제
     * @param {number} highlightId 하이라이트 ID
     * @param {number} songId 삭제할 하이라이트의 노래 ID ( default 는 장범준 노래임 )
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public deleteHighlightUsingDELETE(highlightId: number, songId: number, options?: any) {
        return APIApiFp(this.configuration).deleteHighlightUsingDELETE(highlightId, songId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 가수의 노래를 삭제한다. 응답 결과로는 삭제된 노래의 정보가 반환된다.
     * @summary 가수 노래 정보 삭제
     * @param {number} songId 삭제할 노래 ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public deleteSongUsingDELETE(songId: number, options?: any) {
        return APIApiFp(this.configuration).deleteSongUsingDELETE(songId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 가수 이름을 기반으로 가수 이름을 검색 합니다.
     * @summary 가수 정보 조회
     * @param {string} singerName 가수 이름
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public getSingerInfoUsingGET(singerName: string, options?: any) {
        return APIApiFp(this.configuration).getSingerInfoUsingGET(singerName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 가수의 노래 정보를 변경한다.
     * @summary 가수 노래 정보 변경
     * @param {number} songId 변경할 노래 ID
     * @param {SongUpdateRequest} request 변경할 노래 정보
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public updateArtworkUrlOfSongUsingPUT(songId: number, request: SongUpdateRequest, options?: any) {
        return APIApiFp(this.configuration).updateArtworkUrlOfSongUsingPUT(songId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 가수 앨범 이미지를 변경 합니다.
     * @summary 가수 대표 이미지 변경
     * @param {string} singerName 가수 이름
     * @param {ArtworkUrlUpdateRequest} request 변경할 앨범 이미지 URL
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public updateArtworkUrlUsingPUT(singerName: string, request: ArtworkUrlUpdateRequest, options?: any) {
        return APIApiFp(this.configuration).updateArtworkUrlUsingPUT(singerName, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 가수의 노래의 노출 여부를 변경한다.
     * @summary 가수 노래 노출 여부 변경
     * @param {number} songId 변경할 노래 ID
     * @param {string} exported 변경할 노래 정보
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public updateExportedOfSongUsingPUT(songId: number, exported: string, options?: any) {
        return APIApiFp(this.configuration).updateExportedOfSongUsingPUT(songId, exported, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 해당 가수가 유저들에게 노출 되는지의 여부를 변경한다.
     * @summary 가수 노출 여부 변경
     * @param {string} singerName 변경할 가수 이름
     * @param {string} hasHighlight 변경할 노래 정보
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public updateHasHighlightUsingPUT(singerName: string, hasHighlight: string, options?: any) {
        return APIApiFp(this.configuration).updateHasHighlightUsingPUT(singerName, hasHighlight, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admin UI에 알맞게 highlightId 만을 이용하여 하이라이트 정보를 변경한다.
     * @summary 하이라이트 정보 변경
     * @param {number} highlightId 하이라이트 ID
     * @param {number} songId 변경할 하이라이트의 노래 ID
     * @param {HighlightUpdateOrCreateRequest} request 변경할 하이라이트 정보
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public updateHighlightUsingPUT(highlightId: number, songId: number, request: HighlightUpdateOrCreateRequest, options?: any) {
        return APIApiFp(this.configuration).updateHighlightUsingPUT(highlightId, songId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 가수의 노래 refine title만 변경한다.
     * @summary 가수 노래의 refined_title만 변경 
     * @param {number} songId 변경할 노래 ID
     * @param {string} refineTitle 변경할 노래 정보
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public updateRefinedTitleOfSongUsingPUT(songId: number, refineTitle: string, options?: any) {
        return APIApiFp(this.configuration).updateRefinedTitleOfSongUsingPUT(songId, refineTitle, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 가수의 노래 정보를 변경한다.
     * @summary 가수 노래 정보 변경
     * @param {number} songId 변경할 노래 ID
     * @param {SongUpdateRequest} request 변경할 노래 정보
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public updateSongUsingPUT(songId: number, request: SongUpdateRequest, options?: any) {
        return APIApiFp(this.configuration).updateSongUsingPUT(songId, request, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * AdminControllerApi - axios parameter creator
 * @export
 */
export const AdminControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteRestriction
         * @param {number} restrictionId restrictionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRestrictionUsingDELETE: async (restrictionId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'restrictionId' is not null or undefined
            if (restrictionId === null || restrictionId === undefined) {
                throw new RequiredError('restrictionId','Required parameter restrictionId was null or undefined when calling deleteRestrictionUsingDELETE.');
            }
            const localVarPath = `/v1/admin/restrictions/{restrictionId}`
                .replace(`{${"restrictionId"}}`, encodeURIComponent(String(restrictionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete
         * @param {number} songId songId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsingDELETE: async (songId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'songId' is not null or undefined
            if (songId === null || songId === undefined) {
                throw new RequiredError('songId','Required parameter songId was null or undefined when calling deleteUsingDELETE.');
            }
            const localVarPath = `/v1/admin/songs/{songId}`
                .replace(`{${"songId"}}`, encodeURIComponent(String(songId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary findByNickname
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByNicknameUsingGET: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling findByNicknameUsingGET.');
            }
            const localVarPath = `/v1/admin/user/findByNickname/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPlayLogsByNickname
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayLogsByNicknameUsingGET: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getPlayLogsByNicknameUsingGET.');
            }
            const localVarPath = `/v1/admin/log/names/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveAdminSetting
         * @param {AdminSetting} setting setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAdminSettingUsingPUT: async (setting: AdminSetting, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'setting' is not null or undefined
            if (setting === null || setting === undefined) {
                throw new RequiredError('setting','Required parameter setting was null or undefined when calling saveAdminSettingUsingPUT.');
            }
            const localVarPath = `/v1/admin/setting`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof setting !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(setting !== undefined ? setting : {}) : (setting || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary saveAdminSetting
         * @param {number} settingId settingId
         * @param {AdminRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAdminSettingUsingPUT1: async (settingId: number, request: AdminRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'settingId' is not null or undefined
            if (settingId === null || settingId === undefined) {
                throw new RequiredError('settingId','Required parameter settingId was null or undefined when calling saveAdminSettingUsingPUT1.');
            }
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling saveAdminSettingUsingPUT1.');
            }
            const localVarPath = `/v1/admin/settings/{settingId}`
                .replace(`{${"settingId"}}`, encodeURIComponent(String(settingId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary save
         * @param {RestrctionRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUsingPOST: async (request: RestrctionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling saveUsingPOST.');
            }
            const localVarPath = `/v1/admin/restriction`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateExcludeWord
         * @param {number} id id
         * @param {string} excludeWord excludeWord
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExcludeWordUsingPOST: async (id: number, excludeWord: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateExcludeWordUsingPOST.');
            }
            // verify required parameter 'excludeWord' is not null or undefined
            if (excludeWord === null || excludeWord === undefined) {
                throw new RequiredError('excludeWord','Required parameter excludeWord was null or undefined when calling updateExcludeWordUsingPOST.');
            }
            const localVarPath = `/v1/admin/excludeWord/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof excludeWord !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(excludeWord !== undefined ? excludeWord : {}) : (excludeWord || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateExcludeWord
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExcludeWordUsingPUT: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateExcludeWordUsingPUT.');
            }
            const localVarPath = `/v1/admin/excludeWord/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary updateItemByNickname
         * @param {ItemUpdateRequest} itemUpdateRequest itemUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemByNicknameUsingPUT: async (itemUpdateRequest: ItemUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemUpdateRequest' is not null or undefined
            if (itemUpdateRequest === null || itemUpdateRequest === undefined) {
                throw new RequiredError('itemUpdateRequest','Required parameter itemUpdateRequest was null or undefined when calling updateItemByNicknameUsingPUT.');
            }
            const localVarPath = `/v1/admin/item/update`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof itemUpdateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(itemUpdateRequest !== undefined ? itemUpdateRequest : {}) : (itemUpdateRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update
         * @param {number} songId songId
         * @param {SongUpdateRequest} songUpdateRequest songUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsingPOST: async (songId: number, songUpdateRequest: SongUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'songId' is not null or undefined
            if (songId === null || songId === undefined) {
                throw new RequiredError('songId','Required parameter songId was null or undefined when calling updateUsingPOST.');
            }
            // verify required parameter 'songUpdateRequest' is not null or undefined
            if (songUpdateRequest === null || songUpdateRequest === undefined) {
                throw new RequiredError('songUpdateRequest','Required parameter songUpdateRequest was null or undefined when calling updateUsingPOST.');
            }
            const localVarPath = `/v1/admin/songs/{songId}`
                .replace(`{${"songId"}}`, encodeURIComponent(String(songId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof songUpdateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(songUpdateRequest !== undefined ? songUpdateRequest : {}) : (songUpdateRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminControllerApi - functional programming interface
 * @export
 */
export const AdminControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary deleteRestriction
         * @param {number} restrictionId restrictionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRestrictionUsingDELETE(restrictionId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).deleteRestrictionUsingDELETE(restrictionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary delete
         * @param {number} songId songId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUsingDELETE(songId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).deleteUsingDELETE(songId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary findByNickname
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findByNicknameUsingGET(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemCountInfo>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).findByNicknameUsingGET(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary getPlayLogsByNickname
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayLogsByNicknameUsingGET(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GamePlayLogResponse>>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).getPlayLogsByNicknameUsingGET(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary saveAdminSetting
         * @param {AdminSetting} setting setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveAdminSettingUsingPUT(setting: AdminSetting, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTO>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).saveAdminSettingUsingPUT(setting, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary saveAdminSetting
         * @param {number} settingId settingId
         * @param {AdminRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveAdminSettingUsingPUT1(settingId: number, request: AdminRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).saveAdminSettingUsingPUT1(settingId, request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary save
         * @param {RestrctionRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveUsingPOST(request: RestrctionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).saveUsingPOST(request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary updateExcludeWord
         * @param {number} id id
         * @param {string} excludeWord excludeWord
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExcludeWordUsingPOST(id: number, excludeWord: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).updateExcludeWordUsingPOST(id, excludeWord, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary updateExcludeWord
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExcludeWordUsingPUT(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).updateExcludeWordUsingPUT(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary updateItemByNickname
         * @param {ItemUpdateRequest} itemUpdateRequest itemUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateItemByNicknameUsingPUT(itemUpdateRequest: ItemUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTO>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).updateItemByNicknameUsingPUT(itemUpdateRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary update
         * @param {number} songId songId
         * @param {SongUpdateRequest} songUpdateRequest songUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUsingPOST(songId: number, songUpdateRequest: SongUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseBodyWrapperSong>> {
            const localVarAxiosArgs = await AdminControllerApiAxiosParamCreator(configuration).updateUsingPOST(songId, songUpdateRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AdminControllerApi - factory interface
 * @export
 */
export const AdminControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary deleteRestriction
         * @param {number} restrictionId restrictionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRestrictionUsingDELETE(restrictionId: number, options?: any): AxiosPromise<number> {
            return AdminControllerApiFp(configuration).deleteRestrictionUsingDELETE(restrictionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary delete
         * @param {number} songId songId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUsingDELETE(songId: number, options?: any): AxiosPromise<number> {
            return AdminControllerApiFp(configuration).deleteUsingDELETE(songId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary findByNickname
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByNicknameUsingGET(name: string, options?: any): AxiosPromise<ItemCountInfo> {
            return AdminControllerApiFp(configuration).findByNicknameUsingGET(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getPlayLogsByNickname
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayLogsByNicknameUsingGET(name: string, options?: any): AxiosPromise<Array<GamePlayLogResponse>> {
            return AdminControllerApiFp(configuration).getPlayLogsByNicknameUsingGET(name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary saveAdminSetting
         * @param {AdminSetting} setting setting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAdminSettingUsingPUT(setting: AdminSetting, options?: any): AxiosPromise<ResponseDTO> {
            return AdminControllerApiFp(configuration).saveAdminSettingUsingPUT(setting, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary saveAdminSetting
         * @param {number} settingId settingId
         * @param {AdminRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAdminSettingUsingPUT1(settingId: number, request: AdminRequest, options?: any): AxiosPromise<number> {
            return AdminControllerApiFp(configuration).saveAdminSettingUsingPUT1(settingId, request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary save
         * @param {RestrctionRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveUsingPOST(request: RestrctionRequest, options?: any): AxiosPromise<number> {
            return AdminControllerApiFp(configuration).saveUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateExcludeWord
         * @param {number} id id
         * @param {string} excludeWord excludeWord
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExcludeWordUsingPOST(id: number, excludeWord: string, options?: any): AxiosPromise<boolean> {
            return AdminControllerApiFp(configuration).updateExcludeWordUsingPOST(id, excludeWord, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateExcludeWord
         * @param {number} id id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExcludeWordUsingPUT(id: number, options?: any): AxiosPromise<boolean> {
            return AdminControllerApiFp(configuration).updateExcludeWordUsingPUT(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary updateItemByNickname
         * @param {ItemUpdateRequest} itemUpdateRequest itemUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateItemByNicknameUsingPUT(itemUpdateRequest: ItemUpdateRequest, options?: any): AxiosPromise<ResponseDTO> {
            return AdminControllerApiFp(configuration).updateItemByNicknameUsingPUT(itemUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update
         * @param {number} songId songId
         * @param {SongUpdateRequest} songUpdateRequest songUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsingPOST(songId: number, songUpdateRequest: SongUpdateRequest, options?: any): AxiosPromise<ResponseBodyWrapperSong> {
            return AdminControllerApiFp(configuration).updateUsingPOST(songId, songUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminControllerApi - object-oriented interface
 * @export
 * @class AdminControllerApi
 * @extends {BaseAPI}
 */
export class AdminControllerApi extends BaseAPI {
    /**
     * 
     * @summary deleteRestriction
     * @param {number} restrictionId restrictionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public deleteRestrictionUsingDELETE(restrictionId: number, options?: any) {
        return AdminControllerApiFp(this.configuration).deleteRestrictionUsingDELETE(restrictionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary delete
     * @param {number} songId songId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public deleteUsingDELETE(songId: number, options?: any) {
        return AdminControllerApiFp(this.configuration).deleteUsingDELETE(songId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary findByNickname
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public findByNicknameUsingGET(name: string, options?: any) {
        return AdminControllerApiFp(this.configuration).findByNicknameUsingGET(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getPlayLogsByNickname
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public getPlayLogsByNicknameUsingGET(name: string, options?: any) {
        return AdminControllerApiFp(this.configuration).getPlayLogsByNicknameUsingGET(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary saveAdminSetting
     * @param {AdminSetting} setting setting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public saveAdminSettingUsingPUT(setting: AdminSetting, options?: any) {
        return AdminControllerApiFp(this.configuration).saveAdminSettingUsingPUT(setting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary saveAdminSetting
     * @param {number} settingId settingId
     * @param {AdminRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public saveAdminSettingUsingPUT1(settingId: number, request: AdminRequest, options?: any) {
        return AdminControllerApiFp(this.configuration).saveAdminSettingUsingPUT1(settingId, request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary save
     * @param {RestrctionRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public saveUsingPOST(request: RestrctionRequest, options?: any) {
        return AdminControllerApiFp(this.configuration).saveUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateExcludeWord
     * @param {number} id id
     * @param {string} excludeWord excludeWord
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public updateExcludeWordUsingPOST(id: number, excludeWord: string, options?: any) {
        return AdminControllerApiFp(this.configuration).updateExcludeWordUsingPOST(id, excludeWord, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateExcludeWord
     * @param {number} id id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public updateExcludeWordUsingPUT(id: number, options?: any) {
        return AdminControllerApiFp(this.configuration).updateExcludeWordUsingPUT(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary updateItemByNickname
     * @param {ItemUpdateRequest} itemUpdateRequest itemUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public updateItemByNicknameUsingPUT(itemUpdateRequest: ItemUpdateRequest, options?: any) {
        return AdminControllerApiFp(this.configuration).updateItemByNicknameUsingPUT(itemUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update
     * @param {number} songId songId
     * @param {SongUpdateRequest} songUpdateRequest songUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminControllerApi
     */
    public updateUsingPOST(songId: number, songUpdateRequest: SongUpdateRequest, options?: any) {
        return AdminControllerApiFp(this.configuration).updateUsingPOST(songId, songUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * AdminViewControllerApi - axios parameter creator
 * @export
 */
export const AdminViewControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addItemToUser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItemToUserUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/addItemToUser`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getPlayLogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayLogsUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/logView`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getRestriction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestrictionUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/restrictions`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/settings`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/main`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary refineWord
         * @param {string} [singerName] singerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refineWordUsingGET: async (singerName?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/refine-word`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (singerName !== undefined) {
                localVarQueryParameter['singerName'] = singerName;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary settingUpdate
         * @param {number} settingId settingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingUpdateUsingGET: async (settingId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'settingId' is not null or undefined
            if (settingId === null || settingId === undefined) {
                throw new RequiredError('settingId','Required parameter settingId was null or undefined when calling settingUpdateUsingGET.');
            }
            const localVarPath = `/admin/settings/{settingId}`
                .replace(`{${"settingId"}}`, encodeURIComponent(String(settingId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary songsUpdate
         * @param {number} songId songId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songsUpdateUsingGET: async (songId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'songId' is not null or undefined
            if (songId === null || songId === undefined) {
                throw new RequiredError('songId','Required parameter songId was null or undefined when calling songsUpdateUsingGET.');
            }
            const localVarPath = `/admin/songs/{songId}`
                .replace(`{${"songId"}}`, encodeURIComponent(String(songId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminViewControllerApi - functional programming interface
 * @export
 */
export const AdminViewControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addItemToUser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addItemToUserUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AdminViewControllerApiAxiosParamCreator(configuration).addItemToUserUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary getPlayLogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlayLogsUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AdminViewControllerApiAxiosParamCreator(configuration).getPlayLogsUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary getRestriction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRestrictionUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AdminViewControllerApiAxiosParamCreator(configuration).getRestrictionUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary getSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSettingUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AdminViewControllerApiAxiosParamCreator(configuration).getSettingUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mainUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AdminViewControllerApiAxiosParamCreator(configuration).mainUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary refineWord
         * @param {string} [singerName] singerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refineWordUsingGET(singerName?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AdminViewControllerApiAxiosParamCreator(configuration).refineWordUsingGET(singerName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary settingUpdate
         * @param {number} settingId settingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingUpdateUsingGET(settingId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AdminViewControllerApiAxiosParamCreator(configuration).settingUpdateUsingGET(settingId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary songsUpdate
         * @param {number} songId songId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async songsUpdateUsingGET(songId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await AdminViewControllerApiAxiosParamCreator(configuration).songsUpdateUsingGET(songId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AdminViewControllerApi - factory interface
 * @export
 */
export const AdminViewControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary addItemToUser
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addItemToUserUsingGET(options?: any): AxiosPromise<string> {
            return AdminViewControllerApiFp(configuration).addItemToUserUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getPlayLogs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlayLogsUsingGET(options?: any): AxiosPromise<string> {
            return AdminViewControllerApiFp(configuration).getPlayLogsUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getRestriction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestrictionUsingGET(options?: any): AxiosPromise<string> {
            return AdminViewControllerApiFp(configuration).getRestrictionUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getSetting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSettingUsingGET(options?: any): AxiosPromise<string> {
            return AdminViewControllerApiFp(configuration).getSettingUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary main
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mainUsingGET(options?: any): AxiosPromise<string> {
            return AdminViewControllerApiFp(configuration).mainUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary refineWord
         * @param {string} [singerName] singerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refineWordUsingGET(singerName?: string, options?: any): AxiosPromise<string> {
            return AdminViewControllerApiFp(configuration).refineWordUsingGET(singerName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary settingUpdate
         * @param {number} settingId settingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingUpdateUsingGET(settingId: number, options?: any): AxiosPromise<string> {
            return AdminViewControllerApiFp(configuration).settingUpdateUsingGET(settingId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary songsUpdate
         * @param {number} songId songId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        songsUpdateUsingGET(songId: number, options?: any): AxiosPromise<string> {
            return AdminViewControllerApiFp(configuration).songsUpdateUsingGET(songId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminViewControllerApi - object-oriented interface
 * @export
 * @class AdminViewControllerApi
 * @extends {BaseAPI}
 */
export class AdminViewControllerApi extends BaseAPI {
    /**
     * 
     * @summary addItemToUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminViewControllerApi
     */
    public addItemToUserUsingGET(options?: any) {
        return AdminViewControllerApiFp(this.configuration).addItemToUserUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getPlayLogs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminViewControllerApi
     */
    public getPlayLogsUsingGET(options?: any) {
        return AdminViewControllerApiFp(this.configuration).getPlayLogsUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getRestriction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminViewControllerApi
     */
    public getRestrictionUsingGET(options?: any) {
        return AdminViewControllerApiFp(this.configuration).getRestrictionUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getSetting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminViewControllerApi
     */
    public getSettingUsingGET(options?: any) {
        return AdminViewControllerApiFp(this.configuration).getSettingUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary main
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminViewControllerApi
     */
    public mainUsingGET(options?: any) {
        return AdminViewControllerApiFp(this.configuration).mainUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary refineWord
     * @param {string} [singerName] singerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminViewControllerApi
     */
    public refineWordUsingGET(singerName?: string, options?: any) {
        return AdminViewControllerApiFp(this.configuration).refineWordUsingGET(singerName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary settingUpdate
     * @param {number} settingId settingId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminViewControllerApi
     */
    public settingUpdateUsingGET(settingId: number, options?: any) {
        return AdminViewControllerApiFp(this.configuration).settingUpdateUsingGET(settingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary songsUpdate
     * @param {number} songId songId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminViewControllerApi
     */
    public songsUpdateUsingGET(songId: number, options?: any) {
        return AdminViewControllerApiFp(this.configuration).songsUpdateUsingGET(songId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * AdvertiseKeywordControllerApi - axios parameter creator
 * @export
 */
export const AdvertiseKeywordControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAdvertiseKeyword
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdvertiseKeywordUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/advertise/keywords`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdvertiseKeywordControllerApi - functional programming interface
 * @export
 */
export const AdvertiseKeywordControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAdvertiseKeyword
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdvertiseKeywordUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOListstring>> {
            const localVarAxiosArgs = await AdvertiseKeywordControllerApiAxiosParamCreator(configuration).getAdvertiseKeywordUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AdvertiseKeywordControllerApi - factory interface
 * @export
 */
export const AdvertiseKeywordControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary getAdvertiseKeyword
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdvertiseKeywordUsingGET(options?: any): AxiosPromise<ResponseDTOListstring> {
            return AdvertiseKeywordControllerApiFp(configuration).getAdvertiseKeywordUsingGET(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdvertiseKeywordControllerApi - object-oriented interface
 * @export
 * @class AdvertiseKeywordControllerApi
 * @extends {BaseAPI}
 */
export class AdvertiseKeywordControllerApi extends BaseAPI {
    /**
     * 
     * @summary getAdvertiseKeyword
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvertiseKeywordControllerApi
     */
    public getAdvertiseKeywordUsingGET(options?: any) {
        return AdvertiseKeywordControllerApiFp(this.configuration).getAdvertiseKeywordUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * Class01APIV2Api - axios parameter creator
 * @export
 */
export const Class01APIV2ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 시즌 랭킹, 월간 랭킹 부분을 누적하여 저장하는 API. 하위 호환성을 위하여 V2로 분기함.
         * @summary 게임 결과 데이터 가져오는 API
         * @param {GameResultRequest} resultRequest resultRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameResultUsingPOST1: async (resultRequest: GameResultRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resultRequest' is not null or undefined
            if (resultRequest === null || resultRequest === undefined) {
                throw new RequiredError('resultRequest','Required parameter resultRequest was null or undefined when calling gameResultUsingPOST1.');
            }
            const localVarPath = `/v2/game/result`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof resultRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(resultRequest !== undefined ? resultRequest : {}) : (resultRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Class01APIV2Api - functional programming interface
 * @export
 */
export const Class01APIV2ApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 시즌 랭킹, 월간 랭킹 부분을 누적하여 저장하는 API. 하위 호환성을 위하여 V2로 분기함.
         * @summary 게임 결과 데이터 가져오는 API
         * @param {GameResultRequest} resultRequest resultRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameResultUsingPOST1(resultRequest: GameResultRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOGameResultResponseV2>> {
            const localVarAxiosArgs = await Class01APIV2ApiAxiosParamCreator(configuration).gameResultUsingPOST1(resultRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * Class01APIV2Api - factory interface
 * @export
 */
export const Class01APIV2ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 시즌 랭킹, 월간 랭킹 부분을 누적하여 저장하는 API. 하위 호환성을 위하여 V2로 분기함.
         * @summary 게임 결과 데이터 가져오는 API
         * @param {GameResultRequest} resultRequest resultRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameResultUsingPOST1(resultRequest: GameResultRequest, options?: any): AxiosPromise<ResponseDTOGameResultResponseV2> {
            return Class01APIV2ApiFp(configuration).gameResultUsingPOST1(resultRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Class01APIV2Api - object-oriented interface
 * @export
 * @class Class01APIV2Api
 * @extends {BaseAPI}
 */
export class Class01APIV2Api extends BaseAPI {
    /**
     * 시즌 랭킹, 월간 랭킹 부분을 누적하여 저장하는 API. 하위 호환성을 위하여 V2로 분기함.
     * @summary 게임 결과 데이터 가져오는 API
     * @param {GameResultRequest} resultRequest resultRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Class01APIV2Api
     */
    public gameResultUsingPOST1(resultRequest: GameResultRequest, options?: any) {
        return Class01APIV2ApiFp(this.configuration).gameResultUsingPOST1(resultRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * GameControllerApi - axios parameter creator
 * @export
 */
export const GameControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary gameResult
         * @param {GameResultRequest} resultRequest resultRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameResultUsingPOST: async (resultRequest: GameResultRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'resultRequest' is not null or undefined
            if (resultRequest === null || resultRequest === undefined) {
                throw new RequiredError('resultRequest','Required parameter resultRequest was null or undefined when calling gameResultUsingPOST.');
            }
            const localVarPath = `/game/result`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof resultRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(resultRequest !== undefined ? resultRequest : {}) : (resultRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getHighlightList
         * @param {GameStartRequest} gameRequest gameRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightListUsingPOST: async (gameRequest: GameStartRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameRequest' is not null or undefined
            if (gameRequest === null || gameRequest === undefined) {
                throw new RequiredError('gameRequest','Required parameter gameRequest was null or undefined when calling getHighlightListUsingPOST.');
            }
            const localVarPath = `/game/start`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof gameRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(gameRequest !== undefined ? gameRequest : {}) : (gameRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary isAnswer
         * @param {GameAnswerCheckRequest} answerCheckRequest answerCheckRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAnswerUsingPOST: async (answerCheckRequest: GameAnswerCheckRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'answerCheckRequest' is not null or undefined
            if (answerCheckRequest === null || answerCheckRequest === undefined) {
                throw new RequiredError('answerCheckRequest','Required parameter answerCheckRequest was null or undefined when calling isAnswerUsingPOST.');
            }
            const localVarPath = `/game/answer`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof answerCheckRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(answerCheckRequest !== undefined ? answerCheckRequest : {}) : (answerCheckRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary refine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refineUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/game/refine`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GameControllerApi - functional programming interface
 * @export
 */
export const GameControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary gameResult
         * @param {GameResultRequest} resultRequest resultRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameResultUsingPOST(resultRequest: GameResultRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOGameResultResponse>> {
            const localVarAxiosArgs = await GameControllerApiAxiosParamCreator(configuration).gameResultUsingPOST(resultRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary getHighlightList
         * @param {GameStartRequest} gameRequest gameRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHighlightListUsingPOST(gameRequest: GameStartRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOGameStartResponse>> {
            const localVarAxiosArgs = await GameControllerApiAxiosParamCreator(configuration).getHighlightListUsingPOST(gameRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary isAnswer
         * @param {GameAnswerCheckRequest} answerCheckRequest answerCheckRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isAnswerUsingPOST(answerCheckRequest: GameAnswerCheckRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOboolean>> {
            const localVarAxiosArgs = await GameControllerApiAxiosParamCreator(configuration).isAnswerUsingPOST(answerCheckRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary refine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refineUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await GameControllerApiAxiosParamCreator(configuration).refineUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GameControllerApi - factory interface
 * @export
 */
export const GameControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary gameResult
         * @param {GameResultRequest} resultRequest resultRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameResultUsingPOST(resultRequest: GameResultRequest, options?: any): AxiosPromise<ResponseDTOGameResultResponse> {
            return GameControllerApiFp(configuration).gameResultUsingPOST(resultRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getHighlightList
         * @param {GameStartRequest} gameRequest gameRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHighlightListUsingPOST(gameRequest: GameStartRequest, options?: any): AxiosPromise<ResponseDTOGameStartResponse> {
            return GameControllerApiFp(configuration).getHighlightListUsingPOST(gameRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary isAnswer
         * @param {GameAnswerCheckRequest} answerCheckRequest answerCheckRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAnswerUsingPOST(answerCheckRequest: GameAnswerCheckRequest, options?: any): AxiosPromise<ResponseDTOboolean> {
            return GameControllerApiFp(configuration).isAnswerUsingPOST(answerCheckRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary refine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refineUsingGET(options?: any): AxiosPromise<string> {
            return GameControllerApiFp(configuration).refineUsingGET(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GameControllerApi - object-oriented interface
 * @export
 * @class GameControllerApi
 * @extends {BaseAPI}
 */
export class GameControllerApi extends BaseAPI {
    /**
     * 
     * @summary gameResult
     * @param {GameResultRequest} resultRequest resultRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public gameResultUsingPOST(resultRequest: GameResultRequest, options?: any) {
        return GameControllerApiFp(this.configuration).gameResultUsingPOST(resultRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getHighlightList
     * @param {GameStartRequest} gameRequest gameRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public getHighlightListUsingPOST(gameRequest: GameStartRequest, options?: any) {
        return GameControllerApiFp(this.configuration).getHighlightListUsingPOST(gameRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary isAnswer
     * @param {GameAnswerCheckRequest} answerCheckRequest answerCheckRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public isAnswerUsingPOST(answerCheckRequest: GameAnswerCheckRequest, options?: any) {
        return GameControllerApiFp(this.configuration).isAnswerUsingPOST(answerCheckRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary refine
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameControllerApi
     */
    public refineUsingGET(options?: any) {
        return GameControllerApiFp(this.configuration).refineUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * HealthCheckControllerApi - axios parameter creator
 * @export
 */
export const HealthCheckControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cacheUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/cache`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary healthCheck2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck2UsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/check`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/test`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthCheckControllerApi - functional programming interface
 * @export
 */
export const HealthCheckControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cacheUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await HealthCheckControllerApiAxiosParamCreator(configuration).cacheUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary healthCheck2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheck2UsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await HealthCheckControllerApiAxiosParamCreator(configuration).healthCheck2UsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await HealthCheckControllerApiAxiosParamCreator(configuration).testUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HealthCheckControllerApi - factory interface
 * @export
 */
export const HealthCheckControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary cache
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cacheUsingGET(options?: any): AxiosPromise<number> {
            return HealthCheckControllerApiFp(configuration).cacheUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary healthCheck2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck2UsingGET(options?: any): AxiosPromise<boolean> {
            return HealthCheckControllerApiFp(configuration).healthCheck2UsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testUsingGET(options?: any): AxiosPromise<boolean> {
            return HealthCheckControllerApiFp(configuration).testUsingGET(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthCheckControllerApi - object-oriented interface
 * @export
 * @class HealthCheckControllerApi
 * @extends {BaseAPI}
 */
export class HealthCheckControllerApi extends BaseAPI {
    /**
     * 
     * @summary cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckControllerApi
     */
    public cacheUsingGET(options?: any) {
        return HealthCheckControllerApiFp(this.configuration).cacheUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary healthCheck2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckControllerApi
     */
    public healthCheck2UsingGET(options?: any) {
        return HealthCheckControllerApiFp(this.configuration).healthCheck2UsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckControllerApi
     */
    public testUsingGET(options?: any) {
        return HealthCheckControllerApiFp(this.configuration).testUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * HeartControllerApi - axios parameter creator
 * @export
 */
export const HeartControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary checkMyHeart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkMyHeartUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/heart/check`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary useHeart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useHeartUsingPUT: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/heart/use`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HeartControllerApi - functional programming interface
 * @export
 */
export const HeartControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary checkMyHeart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkMyHeartUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOHeartResponse>> {
            const localVarAxiosArgs = await HeartControllerApiAxiosParamCreator(configuration).checkMyHeartUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary useHeart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async useHeartUsingPUT(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOHeartResponse>> {
            const localVarAxiosArgs = await HeartControllerApiAxiosParamCreator(configuration).useHeartUsingPUT(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HeartControllerApi - factory interface
 * @export
 */
export const HeartControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary checkMyHeart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkMyHeartUsingGET(options?: any): AxiosPromise<ResponseDTOHeartResponse> {
            return HeartControllerApiFp(configuration).checkMyHeartUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary useHeart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useHeartUsingPUT(options?: any): AxiosPromise<ResponseDTOHeartResponse> {
            return HeartControllerApiFp(configuration).useHeartUsingPUT(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HeartControllerApi - object-oriented interface
 * @export
 * @class HeartControllerApi
 * @extends {BaseAPI}
 */
export class HeartControllerApi extends BaseAPI {
    /**
     * 
     * @summary checkMyHeart
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartControllerApi
     */
    public checkMyHeartUsingGET(options?: any) {
        return HeartControllerApiFp(this.configuration).checkMyHeartUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary useHeart
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HeartControllerApi
     */
    public useHeartUsingPUT(options?: any) {
        return HeartControllerApiFp(this.configuration).useHeartUsingPUT(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ItemControllerApi - axios parameter creator
 * @export
 */
export const ItemControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary findItemAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findItemAllUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/item/all`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 아이템 종류는 SKIP, CHARGE_ALL_HEART 있음. 
         * @summary 아이템 사용하는 컨트롤러
         * @param {ItemUseRequest} itemUseRequest itemUseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useItemUsingPUT: async (itemUseRequest: ItemUseRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemUseRequest' is not null or undefined
            if (itemUseRequest === null || itemUseRequest === undefined) {
                throw new RequiredError('itemUseRequest','Required parameter itemUseRequest was null or undefined when calling useItemUsingPUT.');
            }
            const localVarPath = `/item/use`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof itemUseRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(itemUseRequest !== undefined ? itemUseRequest : {}) : (itemUseRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemControllerApi - functional programming interface
 * @export
 */
export const ItemControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary findItemAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findItemAllUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOListItem>> {
            const localVarAxiosArgs = await ItemControllerApiAxiosParamCreator(configuration).findItemAllUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 아이템 종류는 SKIP, CHARGE_ALL_HEART 있음. 
         * @summary 아이템 사용하는 컨트롤러
         * @param {ItemUseRequest} itemUseRequest itemUseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async useItemUsingPUT(itemUseRequest: ItemUseRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTO>> {
            const localVarAxiosArgs = await ItemControllerApiAxiosParamCreator(configuration).useItemUsingPUT(itemUseRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ItemControllerApi - factory interface
 * @export
 */
export const ItemControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary findItemAll
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findItemAllUsingGET(options?: any): AxiosPromise<ResponseDTOListItem> {
            return ItemControllerApiFp(configuration).findItemAllUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 아이템 종류는 SKIP, CHARGE_ALL_HEART 있음. 
         * @summary 아이템 사용하는 컨트롤러
         * @param {ItemUseRequest} itemUseRequest itemUseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        useItemUsingPUT(itemUseRequest: ItemUseRequest, options?: any): AxiosPromise<ResponseDTO> {
            return ItemControllerApiFp(configuration).useItemUsingPUT(itemUseRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemControllerApi - object-oriented interface
 * @export
 * @class ItemControllerApi
 * @extends {BaseAPI}
 */
export class ItemControllerApi extends BaseAPI {
    /**
     * 
     * @summary findItemAll
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemControllerApi
     */
    public findItemAllUsingGET(options?: any) {
        return ItemControllerApiFp(this.configuration).findItemAllUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 아이템 종류는 SKIP, CHARGE_ALL_HEART 있음. 
     * @summary 아이템 사용하는 컨트롤러
     * @param {ItemUseRequest} itemUseRequest itemUseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemControllerApi
     */
    public useItemUsingPUT(itemUseRequest: ItemUseRequest, options?: any) {
        return ItemControllerApiFp(this.configuration).useItemUsingPUT(itemUseRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * LikeControllerApi - axios parameter creator
 * @export
 */
export const LikeControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary dislike
         * @param {LikeRequest} likeRequest likeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dislikeUsingPOST: async (likeRequest: LikeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'likeRequest' is not null or undefined
            if (likeRequest === null || likeRequest === undefined) {
                throw new RequiredError('likeRequest','Required parameter likeRequest was null or undefined when calling dislikeUsingPOST.');
            }
            const localVarPath = `/dislike`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof likeRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(likeRequest !== undefined ? likeRequest : {}) : (likeRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary like
         * @param {LikeRequest} likeRequest likeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeUsingPOST: async (likeRequest: LikeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'likeRequest' is not null or undefined
            if (likeRequest === null || likeRequest === undefined) {
                throw new RequiredError('likeRequest','Required parameter likeRequest was null or undefined when calling likeUsingPOST.');
            }
            const localVarPath = `/like`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof likeRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(likeRequest !== undefined ? likeRequest : {}) : (likeRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LikeControllerApi - functional programming interface
 * @export
 */
export const LikeControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary dislike
         * @param {LikeRequest} likeRequest likeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dislikeUsingPOST(likeRequest: LikeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOLikeResponse>> {
            const localVarAxiosArgs = await LikeControllerApiAxiosParamCreator(configuration).dislikeUsingPOST(likeRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary like
         * @param {LikeRequest} likeRequest likeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async likeUsingPOST(likeRequest: LikeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOLikeResponse>> {
            const localVarAxiosArgs = await LikeControllerApiAxiosParamCreator(configuration).likeUsingPOST(likeRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LikeControllerApi - factory interface
 * @export
 */
export const LikeControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary dislike
         * @param {LikeRequest} likeRequest likeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dislikeUsingPOST(likeRequest: LikeRequest, options?: any): AxiosPromise<ResponseDTOLikeResponse> {
            return LikeControllerApiFp(configuration).dislikeUsingPOST(likeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary like
         * @param {LikeRequest} likeRequest likeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeUsingPOST(likeRequest: LikeRequest, options?: any): AxiosPromise<ResponseDTOLikeResponse> {
            return LikeControllerApiFp(configuration).likeUsingPOST(likeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LikeControllerApi - object-oriented interface
 * @export
 * @class LikeControllerApi
 * @extends {BaseAPI}
 */
export class LikeControllerApi extends BaseAPI {
    /**
     * 
     * @summary dislike
     * @param {LikeRequest} likeRequest likeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeControllerApi
     */
    public dislikeUsingPOST(likeRequest: LikeRequest, options?: any) {
        return LikeControllerApiFp(this.configuration).dislikeUsingPOST(likeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary like
     * @param {LikeRequest} likeRequest likeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeControllerApi
     */
    public likeUsingPOST(likeRequest: LikeRequest, options?: any) {
        return LikeControllerApiFp(this.configuration).likeUsingPOST(likeRequest, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * LikeHistoryControllerApi - axios parameter creator
 * @export
 */
export const LikeHistoryControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getLikeHistory
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikeHistoryUsingGET: async (trackId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackId' is not null or undefined
            if (trackId === null || trackId === undefined) {
                throw new RequiredError('trackId','Required parameter trackId was null or undefined when calling getLikeHistoryUsingGET.');
            }
            const localVarPath = `/history/like/song/{trackId}`
                .replace(`{${"trackId"}}`, encodeURIComponent(String(trackId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getUserHistory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHistoryUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/history/like/user`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LikeHistoryControllerApi - functional programming interface
 * @export
 */
export const LikeHistoryControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getLikeHistory
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLikeHistoryUsingGET(trackId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOListUserLikeHistoryResponse>> {
            const localVarAxiosArgs = await LikeHistoryControllerApiAxiosParamCreator(configuration).getLikeHistoryUsingGET(trackId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary getUserHistory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserHistoryUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOListLikeHistoryResponse>> {
            const localVarAxiosArgs = await LikeHistoryControllerApiAxiosParamCreator(configuration).getUserHistoryUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * LikeHistoryControllerApi - factory interface
 * @export
 */
export const LikeHistoryControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary getLikeHistory
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikeHistoryUsingGET(trackId: number, options?: any): AxiosPromise<ResponseDTOListUserLikeHistoryResponse> {
            return LikeHistoryControllerApiFp(configuration).getLikeHistoryUsingGET(trackId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getUserHistory
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserHistoryUsingGET(options?: any): AxiosPromise<ResponseDTOListLikeHistoryResponse> {
            return LikeHistoryControllerApiFp(configuration).getUserHistoryUsingGET(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LikeHistoryControllerApi - object-oriented interface
 * @export
 * @class LikeHistoryControllerApi
 * @extends {BaseAPI}
 */
export class LikeHistoryControllerApi extends BaseAPI {
    /**
     * 
     * @summary getLikeHistory
     * @param {number} trackId trackId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeHistoryControllerApi
     */
    public getLikeHistoryUsingGET(trackId: number, options?: any) {
        return LikeHistoryControllerApiFp(this.configuration).getLikeHistoryUsingGET(trackId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getUserHistory
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeHistoryControllerApi
     */
    public getUserHistoryUsingGET(options?: any) {
        return LikeHistoryControllerApiFp(this.configuration).getUserHistoryUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * MusicUserControllerApi - axios parameter creator
 * @export
 */
export const MusicUserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary myInfoChange
         * @param {any} profileImage profileImage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInfoChangeUsingPOST: async (profileImage: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileImage' is not null or undefined
            if (profileImage === null || profileImage === undefined) {
                throw new RequiredError('profileImage','Required parameter profileImage was null or undefined when calling myInfoChangeUsingPOST.');
            }
            const localVarPath = `/user/profile/dp`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();


            if (profileImage !== undefined) { 
                localVarFormParams.append('profileImage', profileImage as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary myInfoChange
         * @param {NicknameChangeRequest} nicknameChangeRequest nicknameChangeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInfoChangeUsingPUT: async (nicknameChangeRequest: NicknameChangeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'nicknameChangeRequest' is not null or undefined
            if (nicknameChangeRequest === null || nicknameChangeRequest === undefined) {
                throw new RequiredError('nicknameChangeRequest','Required parameter nicknameChangeRequest was null or undefined when calling myInfoChangeUsingPUT.');
            }
            const localVarPath = `/user/profile/nickname`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof nicknameChangeRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(nicknameChangeRequest !== undefined ? nicknameChangeRequest : {}) : (nicknameChangeRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary refreshToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenUsingPOST: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/login/refresh`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary secedeSelf
         * @param {string} password password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secedeSelfUsingDELETE: async (password: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling secedeSelfUsingDELETE.');
            }
            const localVarPath = `/user/delete`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof password !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(password !== undefined ? password : {}) : (password || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary signIn
         * @param {UserLoginRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInUsingPOST: async (request: UserLoginRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling signInUsingPOST.');
            }
            const localVarPath = `/user/login`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary signUp
         * @param {UserSignUpRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpUsingPOST: async (request: UserSignUpRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling signUpUsingPOST.');
            }
            const localVarPath = `/user/signup`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MusicUserControllerApi - functional programming interface
 * @export
 */
export const MusicUserControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary myInfoChange
         * @param {any} profileImage profileImage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async myInfoChangeUsingPOST(profileImage: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOstring>> {
            const localVarAxiosArgs = await MusicUserControllerApiAxiosParamCreator(configuration).myInfoChangeUsingPOST(profileImage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary myInfoChange
         * @param {NicknameChangeRequest} nicknameChangeRequest nicknameChangeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async myInfoChangeUsingPUT(nicknameChangeRequest: NicknameChangeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOboolean>> {
            const localVarAxiosArgs = await MusicUserControllerApiAxiosParamCreator(configuration).myInfoChangeUsingPUT(nicknameChangeRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary refreshToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshTokenUsingPOST(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOstring>> {
            const localVarAxiosArgs = await MusicUserControllerApiAxiosParamCreator(configuration).refreshTokenUsingPOST(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary secedeSelf
         * @param {string} password password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secedeSelfUsingDELETE(password: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOstring>> {
            const localVarAxiosArgs = await MusicUserControllerApiAxiosParamCreator(configuration).secedeSelfUsingDELETE(password, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary signIn
         * @param {UserLoginRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signInUsingPOST(request: UserLoginRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOLoggedInMusicUser>> {
            const localVarAxiosArgs = await MusicUserControllerApiAxiosParamCreator(configuration).signInUsingPOST(request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary signUp
         * @param {UserSignUpRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signUpUsingPOST(request: UserSignUpRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTO>> {
            const localVarAxiosArgs = await MusicUserControllerApiAxiosParamCreator(configuration).signUpUsingPOST(request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MusicUserControllerApi - factory interface
 * @export
 */
export const MusicUserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary myInfoChange
         * @param {any} profileImage profileImage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInfoChangeUsingPOST(profileImage: any, options?: any): AxiosPromise<ResponseDTOstring> {
            return MusicUserControllerApiFp(configuration).myInfoChangeUsingPOST(profileImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary myInfoChange
         * @param {NicknameChangeRequest} nicknameChangeRequest nicknameChangeRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myInfoChangeUsingPUT(nicknameChangeRequest: NicknameChangeRequest, options?: any): AxiosPromise<ResponseDTOboolean> {
            return MusicUserControllerApiFp(configuration).myInfoChangeUsingPUT(nicknameChangeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary refreshToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenUsingPOST(options?: any): AxiosPromise<ResponseDTOstring> {
            return MusicUserControllerApiFp(configuration).refreshTokenUsingPOST(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary secedeSelf
         * @param {string} password password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secedeSelfUsingDELETE(password: string, options?: any): AxiosPromise<ResponseDTOstring> {
            return MusicUserControllerApiFp(configuration).secedeSelfUsingDELETE(password, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary signIn
         * @param {UserLoginRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInUsingPOST(request: UserLoginRequest, options?: any): AxiosPromise<ResponseDTOLoggedInMusicUser> {
            return MusicUserControllerApiFp(configuration).signInUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary signUp
         * @param {UserSignUpRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpUsingPOST(request: UserSignUpRequest, options?: any): AxiosPromise<ResponseDTO> {
            return MusicUserControllerApiFp(configuration).signUpUsingPOST(request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MusicUserControllerApi - object-oriented interface
 * @export
 * @class MusicUserControllerApi
 * @extends {BaseAPI}
 */
export class MusicUserControllerApi extends BaseAPI {
    /**
     * 
     * @summary myInfoChange
     * @param {any} profileImage profileImage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public myInfoChangeUsingPOST(profileImage: any, options?: any) {
        return MusicUserControllerApiFp(this.configuration).myInfoChangeUsingPOST(profileImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary myInfoChange
     * @param {NicknameChangeRequest} nicknameChangeRequest nicknameChangeRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public myInfoChangeUsingPUT(nicknameChangeRequest: NicknameChangeRequest, options?: any) {
        return MusicUserControllerApiFp(this.configuration).myInfoChangeUsingPUT(nicknameChangeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary refreshToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public refreshTokenUsingPOST(options?: any) {
        return MusicUserControllerApiFp(this.configuration).refreshTokenUsingPOST(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary secedeSelf
     * @param {string} password password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public secedeSelfUsingDELETE(password: string, options?: any) {
        return MusicUserControllerApiFp(this.configuration).secedeSelfUsingDELETE(password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary signIn
     * @param {UserLoginRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public signInUsingPOST(request: UserLoginRequest, options?: any) {
        return MusicUserControllerApiFp(this.configuration).signInUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary signUp
     * @param {UserSignUpRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MusicUserControllerApi
     */
    public signUpUsingPOST(request: UserSignUpRequest, options?: any) {
        return MusicUserControllerApiFp(this.configuration).signUpUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * RankingControllerApi - axios parameter creator
 * @export
 */
export const RankingControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getRankingInfoOfMonths
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoOfMonthsUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rank/month`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getRankingInfoOfSeason
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoOfSeasonUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rank/season`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getRankingInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rank/list`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RankingControllerApi - functional programming interface
 * @export
 */
export const RankingControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getRankingInfoOfMonths
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRankingInfoOfMonthsUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTORankViewModel>> {
            const localVarAxiosArgs = await RankingControllerApiAxiosParamCreator(configuration).getRankingInfoOfMonthsUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary getRankingInfoOfSeason
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRankingInfoOfSeasonUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTORankViewModel>> {
            const localVarAxiosArgs = await RankingControllerApiAxiosParamCreator(configuration).getRankingInfoOfSeasonUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary getRankingInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRankingInfoUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTORankViewModel>> {
            const localVarAxiosArgs = await RankingControllerApiAxiosParamCreator(configuration).getRankingInfoUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RankingControllerApi - factory interface
 * @export
 */
export const RankingControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary getRankingInfoOfMonths
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoOfMonthsUsingGET(options?: any): AxiosPromise<ResponseDTORankViewModel> {
            return RankingControllerApiFp(configuration).getRankingInfoOfMonthsUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getRankingInfoOfSeason
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoOfSeasonUsingGET(options?: any): AxiosPromise<ResponseDTORankViewModel> {
            return RankingControllerApiFp(configuration).getRankingInfoOfSeasonUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getRankingInfo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRankingInfoUsingGET(options?: any): AxiosPromise<ResponseDTORankViewModel> {
            return RankingControllerApiFp(configuration).getRankingInfoUsingGET(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RankingControllerApi - object-oriented interface
 * @export
 * @class RankingControllerApi
 * @extends {BaseAPI}
 */
export class RankingControllerApi extends BaseAPI {
    /**
     * 
     * @summary getRankingInfoOfMonths
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankingControllerApi
     */
    public getRankingInfoOfMonthsUsingGET(options?: any) {
        return RankingControllerApiFp(this.configuration).getRankingInfoOfMonthsUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getRankingInfoOfSeason
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankingControllerApi
     */
    public getRankingInfoOfSeasonUsingGET(options?: any) {
        return RankingControllerApiFp(this.configuration).getRankingInfoOfSeasonUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getRankingInfo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RankingControllerApi
     */
    public getRankingInfoUsingGET(options?: any) {
        return RankingControllerApiFp(this.configuration).getRankingInfoUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * RewardControllerApi - axios parameter creator
 * @export
 */
export const RewardControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * type 광고 시청 : \'ad_movie\', 노래 추천 : \'suggest_music\'
         * @summary rewardHeart
         * @param {string} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewardForWatchingAdUsingPOST: async (type: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling rewardForWatchingAdUsingPOST.');
            }
            const localVarPath = `/reward/types/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RewardControllerApi - functional programming interface
 * @export
 */
export const RewardControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * type 광고 시청 : \'ad_movie\', 노래 추천 : \'suggest_music\'
         * @summary rewardHeart
         * @param {string} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewardForWatchingAdUsingPOST(type: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOReward>> {
            const localVarAxiosArgs = await RewardControllerApiAxiosParamCreator(configuration).rewardForWatchingAdUsingPOST(type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RewardControllerApi - factory interface
 * @export
 */
export const RewardControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * type 광고 시청 : \'ad_movie\', 노래 추천 : \'suggest_music\'
         * @summary rewardHeart
         * @param {string} type type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewardForWatchingAdUsingPOST(type: string, options?: any): AxiosPromise<ResponseDTOReward> {
            return RewardControllerApiFp(configuration).rewardForWatchingAdUsingPOST(type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RewardControllerApi - object-oriented interface
 * @export
 * @class RewardControllerApi
 * @extends {BaseAPI}
 */
export class RewardControllerApi extends BaseAPI {
    /**
     * type 광고 시청 : \'ad_movie\', 노래 추천 : \'suggest_music\'
     * @summary rewardHeart
     * @param {string} type type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardControllerApi
     */
    public rewardForWatchingAdUsingPOST(type: string, options?: any) {
        return RewardControllerApiFp(this.configuration).rewardForWatchingAdUsingPOST(type, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SingerControllerApi - axios parameter creator
 * @export
 */
export const SingerControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAllRegisteredSingerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRegisteredSingerNameUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/singer/registered`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllSingerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSingerNameUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/singer/all`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllSongsBySingerName
         * @param {number} page page
         * @param {string} singerName singerName
         * @param {number} size size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSongsBySingerNameUsingGET: async (page: number, singerName: string, size: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            if (page === null || page === undefined) {
                throw new RequiredError('page','Required parameter page was null or undefined when calling getAllSongsBySingerNameUsingGET.');
            }
            // verify required parameter 'singerName' is not null or undefined
            if (singerName === null || singerName === undefined) {
                throw new RequiredError('singerName','Required parameter singerName was null or undefined when calling getAllSongsBySingerNameUsingGET.');
            }
            // verify required parameter 'size' is not null or undefined
            if (size === null || size === undefined) {
                throw new RequiredError('size','Required parameter size was null or undefined when calling getAllSongsBySingerNameUsingGET.');
            }
            const localVarPath = `/singer/songs`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (singerName !== undefined) {
                localVarQueryParameter['singerName'] = singerName;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getAllStandardSingerList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllStandardSingerListUsingGET: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/singer/standard-list`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 각 trackId에 해당하는 progressive url을 내려준다.
         * @summary progressive url 반환해주는 API
         * @param {Array<number>} trackIds trackIds
         * @param {string} u name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgressiveUrlUsingGET: async (trackIds: Array<number>, u: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackIds' is not null or undefined
            if (trackIds === null || trackIds === undefined) {
                throw new RequiredError('trackIds','Required parameter trackIds was null or undefined when calling getProgressiveUrlUsingGET.');
            }
            // verify required parameter 'u' is not null or undefined
            if (u === null || u === undefined) {
                throw new RequiredError('u','Required parameter u was null or undefined when calling getProgressiveUrlUsingGET.');
            }
            const localVarPath = `/singer/names/{name}/songs/progressive-url`
                .replace(`{${"가수 이름"}}`, encodeURIComponent(String(u)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (trackIds) {
                localVarQueryParameter['trackIds'] = trackIds;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getTrackListBySingerName
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackListBySingerNameUsingGET: async (name: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling getTrackListBySingerNameUsingGET.');
            }
            const localVarPath = `/singer/names/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SingerControllerApi - functional programming interface
 * @export
 */
export const SingerControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary getAllRegisteredSingerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRegisteredSingerNameUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOListSinger>> {
            const localVarAxiosArgs = await SingerControllerApiAxiosParamCreator(configuration).getAllRegisteredSingerNameUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary getAllSingerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSingerNameUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOSetstring>> {
            const localVarAxiosArgs = await SingerControllerApiAxiosParamCreator(configuration).getAllSingerNameUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary getAllSongsBySingerName
         * @param {number} page page
         * @param {string} singerName singerName
         * @param {number} size size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSongsBySingerNameUsingGET(page: number, singerName: string, size: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOPageSongResponse>> {
            const localVarAxiosArgs = await SingerControllerApiAxiosParamCreator(configuration).getAllSongsBySingerNameUsingGET(page, singerName, size, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary getAllStandardSingerList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllStandardSingerListUsingGET(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOListSinger>> {
            const localVarAxiosArgs = await SingerControllerApiAxiosParamCreator(configuration).getAllStandardSingerListUsingGET(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 각 trackId에 해당하는 progressive url을 내려준다.
         * @summary progressive url 반환해주는 API
         * @param {Array<number>} trackIds trackIds
         * @param {string} u name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgressiveUrlUsingGET(trackIds: Array<number>, u: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseBodyWrapperListstring>> {
            const localVarAxiosArgs = await SingerControllerApiAxiosParamCreator(configuration).getProgressiveUrlUsingGET(trackIds, u, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary getTrackListBySingerName
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrackListBySingerNameUsingGET(name: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Track>>> {
            const localVarAxiosArgs = await SingerControllerApiAxiosParamCreator(configuration).getTrackListBySingerNameUsingGET(name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SingerControllerApi - factory interface
 * @export
 */
export const SingerControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary getAllRegisteredSingerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRegisteredSingerNameUsingGET(options?: any): AxiosPromise<ResponseDTOListSinger> {
            return SingerControllerApiFp(configuration).getAllRegisteredSingerNameUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllSingerName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSingerNameUsingGET(options?: any): AxiosPromise<ResponseDTOSetstring> {
            return SingerControllerApiFp(configuration).getAllSingerNameUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllSongsBySingerName
         * @param {number} page page
         * @param {string} singerName singerName
         * @param {number} size size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSongsBySingerNameUsingGET(page: number, singerName: string, size: number, options?: any): AxiosPromise<ResponseDTOPageSongResponse> {
            return SingerControllerApiFp(configuration).getAllSongsBySingerNameUsingGET(page, singerName, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getAllStandardSingerList
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllStandardSingerListUsingGET(options?: any): AxiosPromise<ResponseDTOListSinger> {
            return SingerControllerApiFp(configuration).getAllStandardSingerListUsingGET(options).then((request) => request(axios, basePath));
        },
        /**
         * 각 trackId에 해당하는 progressive url을 내려준다.
         * @summary progressive url 반환해주는 API
         * @param {Array<number>} trackIds trackIds
         * @param {string} u name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgressiveUrlUsingGET(trackIds: Array<number>, u: string, options?: any): AxiosPromise<ResponseBodyWrapperListstring> {
            return SingerControllerApiFp(configuration).getProgressiveUrlUsingGET(trackIds, u, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getTrackListBySingerName
         * @param {string} name name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrackListBySingerNameUsingGET(name: string, options?: any): AxiosPromise<Array<Track>> {
            return SingerControllerApiFp(configuration).getTrackListBySingerNameUsingGET(name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SingerControllerApi - object-oriented interface
 * @export
 * @class SingerControllerApi
 * @extends {BaseAPI}
 */
export class SingerControllerApi extends BaseAPI {
    /**
     * 
     * @summary getAllRegisteredSingerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingerControllerApi
     */
    public getAllRegisteredSingerNameUsingGET(options?: any) {
        return SingerControllerApiFp(this.configuration).getAllRegisteredSingerNameUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllSingerName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingerControllerApi
     */
    public getAllSingerNameUsingGET(options?: any) {
        return SingerControllerApiFp(this.configuration).getAllSingerNameUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllSongsBySingerName
     * @param {number} page page
     * @param {string} singerName singerName
     * @param {number} size size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingerControllerApi
     */
    public getAllSongsBySingerNameUsingGET(page: number, singerName: string, size: number, options?: any) {
        return SingerControllerApiFp(this.configuration).getAllSongsBySingerNameUsingGET(page, singerName, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getAllStandardSingerList
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingerControllerApi
     */
    public getAllStandardSingerListUsingGET(options?: any) {
        return SingerControllerApiFp(this.configuration).getAllStandardSingerListUsingGET(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 각 trackId에 해당하는 progressive url을 내려준다.
     * @summary progressive url 반환해주는 API
     * @param {Array<number>} trackIds trackIds
     * @param {string} u name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingerControllerApi
     */
    public getProgressiveUrlUsingGET(trackIds: Array<number>, u: string, options?: any) {
        return SingerControllerApiFp(this.configuration).getProgressiveUrlUsingGET(trackIds, u, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getTrackListBySingerName
     * @param {string} name name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingerControllerApi
     */
    public getTrackListBySingerNameUsingGET(name: string, options?: any) {
        return SingerControllerApiFp(this.configuration).getTrackListBySingerNameUsingGET(name, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SongControllerApi - axios parameter creator
 * @export
 */
export const SongControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addNewSong
         * @param {SongRegisterRequest} registerRequest registerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewSongUsingPOST: async (registerRequest: SongRegisterRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequest' is not null or undefined
            if (registerRequest === null || registerRequest === undefined) {
                throw new RequiredError('registerRequest','Required parameter registerRequest was null or undefined when calling addNewSongUsingPOST.');
            }
            const localVarPath = `/song/new`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof registerRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(registerRequest !== undefined ? registerRequest : {}) : (registerRequest || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary getSong
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSongUsingGET: async (trackId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackId' is not null or undefined
            if (trackId === null || trackId === undefined) {
                throw new RequiredError('trackId','Required parameter trackId was null or undefined when calling getSongUsingGET.');
            }
            const localVarPath = `/song/{trackId}`
                .replace(`{${"trackId"}}`, encodeURIComponent(String(trackId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongControllerApi - functional programming interface
 * @export
 */
export const SongControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addNewSong
         * @param {SongRegisterRequest} registerRequest registerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNewSongUsingPOST(registerRequest: SongRegisterRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOSong>> {
            const localVarAxiosArgs = await SongControllerApiAxiosParamCreator(configuration).addNewSongUsingPOST(registerRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary getSong
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSongUsingGET(trackId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOSong>> {
            const localVarAxiosArgs = await SongControllerApiAxiosParamCreator(configuration).getSongUsingGET(trackId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SongControllerApi - factory interface
 * @export
 */
export const SongControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary addNewSong
         * @param {SongRegisterRequest} registerRequest registerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNewSongUsingPOST(registerRequest: SongRegisterRequest, options?: any): AxiosPromise<ResponseDTOSong> {
            return SongControllerApiFp(configuration).addNewSongUsingPOST(registerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary getSong
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSongUsingGET(trackId: number, options?: any): AxiosPromise<ResponseDTOSong> {
            return SongControllerApiFp(configuration).getSongUsingGET(trackId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongControllerApi - object-oriented interface
 * @export
 * @class SongControllerApi
 * @extends {BaseAPI}
 */
export class SongControllerApi extends BaseAPI {
    /**
     * 
     * @summary addNewSong
     * @param {SongRegisterRequest} registerRequest registerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongControllerApi
     */
    public addNewSongUsingPOST(registerRequest: SongRegisterRequest, options?: any) {
        return SongControllerApiFp(this.configuration).addNewSongUsingPOST(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary getSong
     * @param {number} trackId trackId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongControllerApi
     */
    public getSongUsingGET(trackId: number, options?: any) {
        return SongControllerApiFp(this.configuration).getSongUsingGET(trackId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SongHighlightControllerApi - axios parameter creator
 * @export
 */
export const SongHighlightControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addSongHighlight
         * @param {SongHighlightAddRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSongHighlightUsingPOST: async (request: SongHighlightAddRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'request' is not null or undefined
            if (request === null || request === undefined) {
                throw new RequiredError('request','Required parameter request was null or undefined when calling addSongHighlightUsingPOST.');
            }
            const localVarPath = `/highlight/new`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof request !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(request !== undefined ? request : {}) : (request || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary makeHighlight
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeHighlightUsingPOST: async (trackId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'trackId' is not null or undefined
            if (trackId === null || trackId === undefined) {
                throw new RequiredError('trackId','Required parameter trackId was null or undefined when calling makeHighlightUsingPOST.');
            }
            const localVarPath = `/highlight/{trackId}`
                .replace(`{${"trackId"}}`, encodeURIComponent(String(trackId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SongHighlightControllerApi - functional programming interface
 * @export
 */
export const SongHighlightControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary addSongHighlight
         * @param {SongHighlightAddRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSongHighlightUsingPOST(request: SongHighlightAddRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOSong>> {
            const localVarAxiosArgs = await SongHighlightControllerApiAxiosParamCreator(configuration).addSongHighlightUsingPOST(request, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary makeHighlight
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async makeHighlightUsingPOST(trackId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOSong>> {
            const localVarAxiosArgs = await SongHighlightControllerApiAxiosParamCreator(configuration).makeHighlightUsingPOST(trackId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SongHighlightControllerApi - factory interface
 * @export
 */
export const SongHighlightControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary addSongHighlight
         * @param {SongHighlightAddRequest} request request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSongHighlightUsingPOST(request: SongHighlightAddRequest, options?: any): AxiosPromise<ResponseDTOSong> {
            return SongHighlightControllerApiFp(configuration).addSongHighlightUsingPOST(request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary makeHighlight
         * @param {number} trackId trackId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        makeHighlightUsingPOST(trackId: number, options?: any): AxiosPromise<ResponseDTOSong> {
            return SongHighlightControllerApiFp(configuration).makeHighlightUsingPOST(trackId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SongHighlightControllerApi - object-oriented interface
 * @export
 * @class SongHighlightControllerApi
 * @extends {BaseAPI}
 */
export class SongHighlightControllerApi extends BaseAPI {
    /**
     * 
     * @summary addSongHighlight
     * @param {SongHighlightAddRequest} request request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongHighlightControllerApi
     */
    public addSongHighlightUsingPOST(request: SongHighlightAddRequest, options?: any) {
        return SongHighlightControllerApiFp(this.configuration).addSongHighlightUsingPOST(request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary makeHighlight
     * @param {number} trackId trackId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SongHighlightControllerApi
     */
    public makeHighlightUsingPOST(trackId: number, options?: any) {
        return SongHighlightControllerApiFp(this.configuration).makeHighlightUsingPOST(trackId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * VersioningControllerApi - axios parameter creator
 * @export
 */
export const VersioningControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary isNeedForceUpdate
         * @param {string} os os
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isNeedForceUpdateUsingGET: async (os: string, version: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'os' is not null or undefined
            if (os === null || os === undefined) {
                throw new RequiredError('os','Required parameter os was null or undefined when calling isNeedForceUpdateUsingGET.');
            }
            // verify required parameter 'version' is not null or undefined
            if (version === null || version === undefined) {
                throw new RequiredError('version','Required parameter version was null or undefined when calling isNeedForceUpdateUsingGET.');
            }
            const localVarPath = `/versioning/os/{os}/version/{version}`
                .replace(`{${"os"}}`, encodeURIComponent(String(os)))
                .replace(`{${"version"}}`, encodeURIComponent(String(version)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersioningControllerApi - functional programming interface
 * @export
 */
export const VersioningControllerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary isNeedForceUpdate
         * @param {string} os os
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isNeedForceUpdateUsingGET(os: string, version: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseDTOboolean>> {
            const localVarAxiosArgs = await VersioningControllerApiAxiosParamCreator(configuration).isNeedForceUpdateUsingGET(os, version, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VersioningControllerApi - factory interface
 * @export
 */
export const VersioningControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary isNeedForceUpdate
         * @param {string} os os
         * @param {string} version version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isNeedForceUpdateUsingGET(os: string, version: string, options?: any): AxiosPromise<ResponseDTOboolean> {
            return VersioningControllerApiFp(configuration).isNeedForceUpdateUsingGET(os, version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersioningControllerApi - object-oriented interface
 * @export
 * @class VersioningControllerApi
 * @extends {BaseAPI}
 */
export class VersioningControllerApi extends BaseAPI {
    /**
     * 
     * @summary isNeedForceUpdate
     * @param {string} os os
     * @param {string} version version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersioningControllerApi
     */
    public isNeedForceUpdateUsingGET(os: string, version: string, options?: any) {
        return VersioningControllerApiFp(this.configuration).isNeedForceUpdateUsingGET(os, version, options).then((request) => request(this.axios, this.basePath));
    }

}


